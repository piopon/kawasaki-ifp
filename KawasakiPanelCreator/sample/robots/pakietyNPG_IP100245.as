.***************************************************************************
.*=== AS GROUP ===         : AS_R1G0031L 2009/09/17 10:53
.*USER IF AS               : UASR1G0031L 2009/09/17 10:35
.*USER IF TP               : UTPR1G0031L 2009/09/17 10:47
.*ARM CONTROL AS           : AASR1G0031L 2009/09/17 10:50
.*USER IF AS MESSAGE FILE  : MAS1G031LEN 2009/09/17 10:33
.*USER IF TP MESSAGE FILE  : MTP1G031LEN 2009/09/17 08:59
.*ARM DATA FILE            : ARMR1G0031L 2009/09/17 09:47
.*USER IF IPL              : UIP02100000 2007/12/13
.*ARM CONTROL IPL          : AIP02100000 2007/12/13
.*=== SERVO GROUP ===      : SV_R500000F 2009/10/06 17:53
.*ARM CONTROL SERVO        : ASVR500000F 2009/10/06 17:49
.*SRV DATA FILE            : ASPR500000F 2009/10/06 17:52
.*ARM CONTROL SERVO CONT.  : ASCR500000F 2009/10/06
.*ARM CONTROL SERVO FPGA   : ASFR5000002 2007/08/21 08:20
.*   [Shipment setting data] 
.*There is no Shipment setting data.
.***************************************************************************
.NETCONF     10.0.24.5,"",255.255.255.0,10.0.24.1,0.0.0.0,0.0.0.0,""
.ROBOTDATA1
ZROBOT.TYPE    14   4   4 1229      -18766   ZD130S-D001 ( 2013-08-26 10:58 )
ZSYSTEM         1   5   1        -106
ZLINEAR         0   0   0   0   0   0  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1         179
CONT_CODE     701      -10516
ZZERO         268431434 268429580 268430769 268428168 268435456 268435456 268435456 268435456 268435456 268435456 268435456 268435456 268435456 268435456 268435456 268435456 268435456 268435456   537199006
ENDLESS_POS   0 100 1       -1516
ZLANGUAGE     ON  -3683
LANG_NO         0   1
ZSIGSPEC       32  32 512       -8641
ZSIGSPEC2     400 500      -13501
ZSETAPPLI          0      0      8      8      0    255       -4066
ZAXCONFIG       1  -1  -1  -1  -1  -1  -1  -1  -1  -1         119
ZMTNIMP_01    ON  -3361
ZMTNIMP_02    ON  -3386
ZMTNIMP_03    ON  -3411
ZMTNIMP_04    ON  -3437
ZMTNIMP_05    ON  -3463
ZMTNIMP_06    OFF -3491
ZSVSPEC         0          -1
ZSPEC01_05        3.000  1010827263
ZSPEC01_06        0.000          -1
ZSPEC01_09          500       -7501
ZSPEC01_10           10        -151
ZSPEC02_01        0.000          -1
ZSPEC02_02        0.500  1325400063
ZSLEWTIME        64.000   444596223
ZWCOMPK           0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000          -1
ZCPUCACHE     OFF -3595
ZULIMIT         180.000    90.000    15.000   360.000     0.000     0.000    10.000    10.000    10.000    10.000    10.000    10.000    10.000    10.000    10.000    10.000    10.000    10.000     4931583
ZLLIMIT        -180.000   -50.000  -120.000  -360.000     0.000     0.000   -10.000   -10.000   -10.000   -10.000   -10.000   -10.000   -10.000   -10.000   -10.000   -10.000   -10.000   -10.000  2136440831
ZSETACCEL       1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   680525823
ZSETDECEL       1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   680525823
ZSETENVCHK      1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   680525823
ZSETSPCHK       1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   680525823
ZSETKVFF        0.000   0.000   0.000   0.000   0.000   0.000  -1.000  -1.000  -1.000  -1.000  -1.000  -1.000  -1.000  -1.000  -1.000  -1.000  -1.000  -1.000 -1388314625
ZSETKVFFACC     0.000   0.000   0.000   0.000   0.000   0.000 -11.000 -11.000 -11.000 -11.000 -11.000 -11.000 -11.000 -11.000 -11.000 -11.000 -11.000 -11.000 -1832648705
ZSETKVFFJRK     0.000   0.000   0.000   0.000   0.000   0.000 -11.000 -11.000 -11.000 -11.000 -11.000 -11.000 -11.000 -11.000 -11.000 -11.000 -11.000 -11.000 -1832648705
ZSETKAFF2       0.000   0.000   0.000   0.000   0.000   0.000  -1.000  -1.000  -1.000  -1.000  -1.000  -1.000  -1.000  -1.000  -1.000  -1.000  -1.000  -1.000 -1388314625
ZSAVEMR             65436       65504       65475       38477       32768       32768           0           0           0           0           0           0           0           0           0           0           0           0    -4506421
ZRADIUS        3225.000  1250.000  1450.000   620.000   620.000   620.000     1.000     1.000     1.000     1.000     1.000     1.000     1.000     1.000     1.000     1.000     1.000     1.000  -424073217
ZJTSPEED        135.000   110.000   130.000   400.000   300.000   300.000  1000.000    10.000    10.000    10.000    10.000    10.000    10.000    10.000    10.000    10.000    10.000    10.000  -211398657
ZACCTIME          0.400     0.400     0.400     0.400     0.400     0.400     0.850     0.850     0.850     0.850     0.850     0.850     0.850     0.850     0.850     0.850     0.850     0.850   749731818
ZDEG_BIT       3.0574160000e-04  2.5850180000e-04  3.1389510000e-04  7.7097040000e-04  2.5101500000e-03  2.5101500000e-03  2.5101500000e-03  2.5101500000e-03  2.5101500000e-03  2.5101500000e-03  2.5101500000e-03  2.5101500000e-03  2.5101500000e-03  2.5101500000e-03  2.5101500000e-03  2.5101500000e-03  2.5101500000e-03  2.5101500000e-03  1037266066  1165324683
LIN_COOP        0   0   0   0   0   0   0   0   0   0   0   0          -1
LIN_CO_TYPE     0   0   0   0   0   0   0   0   0   0   0   0          -1
COUPFA7        0.0000000000e+00          -1          -1
ROT_TYPE        0          -1
ROT_TYPE2       0          -1
ROT_TYPE3       0          -1
ROT_TYPE4       0          -1
ROT_TYPE5       0          -1
ROT_L1            0.000          -1
ROT_L12           0.000          -1
ROT_L13           0.000          -1
ROT_L14           0.000          -1
ROT_L15           0.000          -1
ROT_L2            0.000          -1
ROT_L22           0.000          -1
ROT_L23           0.000          -1
ROT_L24           0.000          -1
ROT_L25           0.000          -1
ROT_MAT1          0.000     0.000     0.000     0.000     0.000     0.000          -1
ROT_MAT2          0.000     0.000     0.000     0.000     0.000     0.000          -1
ROT_MAT3          0.000     0.000     0.000     0.000     0.000     0.000          -1
ROT_MAT4          0.000     0.000     0.000     0.000     0.000     0.000          -1
ROT_MAT5          0.000     0.000     0.000     0.000     0.000     0.000          -1
ROT_MAT6          0.000     0.000     0.000     0.000     0.000     0.000          -1
ROT_BASE          0.000     0.000     0.000     0.000     0.000     0.000          -1
ROT_BASE2         0.000     0.000     0.000     0.000     0.000     0.000          -1
ROT_BASE3         0.000     0.000     0.000     0.000     0.000     0.000          -1
ROT_BASE4         0.000     0.000     0.000     0.000     0.000     0.000          -1
ROT_BASE5         0.000     0.000     0.000     0.000     0.000     0.000          -1
ROT_TOOL          0.000     0.000     0.000     0.000     0.000     0.000          -1
ROT_TOOL2         0.000     0.000     0.000     0.000     0.000     0.000          -1
ROT_TOOL3         0.000     0.000     0.000     0.000     0.000     0.000          -1
ROT_TOOL4         0.000     0.000     0.000     0.000     0.000     0.000          -1
ROT_TOOL5         0.000     0.000     0.000     0.000     0.000     0.000          -1
ROT_COOP        0   0   0   0   0   0   0   0   0   0   0   0          -1
ROT_COOP2       0   0   0   0   0   0   0   0   0   0   0   0          -1
ROT_COOP3       0   0   0   0   0   0   0   0   0   0   0   0          -1
ROT_COOP4       0   0   0   0   0   0   0   0   0   0   0   0          -1
ROT_COOP5       0   0   0   0   0   0   0   0   0   0   0   0          -1
TURN_MAT          0.000     0.000     0.000     0.000     0.000     0.000          -1
TURN_COOP       0   0   0   0   0   0   0   0   0   0   0   0          -1
TURNLIN         0          -1
TURN_DIR        0          -1
JTCHANNEL       0   1   2   3  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1         119
SRV_PARAM       0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0          -1
ZEXTENC_BATCHK    1   1         -31
CD_ID_CODE    241       -3616
ID_FBM_EX       0   0          -1
ARM_MOTION_ID    3         -46
ARM_MOTION_ID_EX    0   0          -1
TYPE_PB         4         -61
TYPE_PB_EX      0   0          -1
ZENDLESS               0          0          0          0          -1          -1
MOTOR_TYPE      0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0          -1
DUAL_SYS           0     10      0      0        -151
DUAL_OFF         0.0000          -1
ZSIGWAIT        0          -1
ZPLOOP          0   0   0          -1
ZCVAXIS              -1          14
ZSETMAXDAOUT  1         -16
ZSETTPNK          1.100     1.100     0.900     0.900
ZSETCYCOVER   3         -46
SG_CAL[1]      0.0000000000e+00  0.0000000000e+00  0.0000000000e+00  0.0000000000e+00  0.0000000000e+00          -1          -1
SG_CAL[2]      0.0000000000e+00  0.0000000000e+00  0.0000000000e+00  0.0000000000e+00  0.0000000000e+00          -1          -1
SG_CAL[3]      0.0000000000e+00  0.0000000000e+00  0.0000000000e+00  0.0000000000e+00  0.0000000000e+00          -1          -1
SG_CAL[4]      0.0000000000e+00  0.0000000000e+00  0.0000000000e+00  0.0000000000e+00  0.0000000000e+00          -1          -1
SG_CAL[5]      0.0000000000e+00  0.0000000000e+00  0.0000000000e+00  0.0000000000e+00  0.0000000000e+00          -1          -1
SG_CAL[6]      0.0000000000e+00  0.0000000000e+00  0.0000000000e+00  0.0000000000e+00  0.0000000000e+00          -1          -1
SG_CAL[7]      0.0000000000e+00  0.0000000000e+00  0.0000000000e+00  0.0000000000e+00  0.0000000000e+00          -1          -1
SG_CAL[8]      0.0000000000e+00  0.0000000000e+00  0.0000000000e+00  0.0000000000e+00  0.0000000000e+00          -1          -1
SG_CAL2[1]    0 0 0 0          -1
SG_CAL2[2]    0 0 0 0          -1
SG_CAL2[3]    0 0 0 0          -1
SG_CAL2[4]    0 0 0 0          -1
SG_CAL2[5]    0 0 0 0          -1
SG_CAL2[6]    0 0 0 0          -1
SG_CAL2[7]    0 0 0 0          -1
SG_CAL2[8]    0 0 0 0          -1
SGAXIS_NO     7
ZDGACCEF      1.0000 1.0000 3.2000 1.1000 1.0000 1.0000 1.0000 1.0000 1.0000 1.0000 1.0000 1.0000 1.0000 1.0000 1.0000 1.0000 1.0000 1.0000   662437893
ZDGDECEF      1.0000 0.9000 1.0000 1.0000 1.0000 1.0000 1.0000 1.0000 1.0000 1.0000 1.0000 1.0000 1.0000 1.0000 1.0000 1.0000 1.0000 1.0000   681312258
ZDGFRIST      3338.7070 130.4580 61.0110 9.5960 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000  -276203847
ZDGFRID0      3228.9419 130.4580 61.0110 9.5960 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000  -269459877
ZDGFRID1      0.2240 1444.6790 280.2420 43.7830 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000  -150257007
DTIMECONST      2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2        -541
DTIMECSTSFT     4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4       -1081
ZDCOLT          180   150   150   130     0     0     0     0     0     0     0     0     0     0     0     0     0     0       -9151
ZDCOLR          300   280   350   140     0     0     0     0     0     0     0     0     0     0     0     0     0     0      -16051
ZDCOLTJ          20    20    20    20     0     0     0     0     0     0     0     0     0     0     0     0     0     0       -1201
ZDCOLRJ          30    30    30    20     0     0     0     0     0     0     0     0     0     0     0     0     0     0       -1651
ZSETIPALM       1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   680525823
ZSETI2ALM       1.070   1.070   1.070   1.070   1.070   1.070   1.070   1.070   1.070   1.070   1.070   1.070   1.070   1.070   1.070   1.070   1.070   1.070   670616793
ZSETIPTIME           32
ZSETMAXPUMP   1         -16
TEACH_LCOOP     0   0   0   0   0   0   0   0   0   0   0   0          -1
ZCVDLYCYC             0
ZARMIDSET     ON   ON    -4331
ZKPCF3         -1.000
ZKPCF3JT_SW    1  1  1  1  1  1         -91
ZKPCF3JT_FREQ   -1.000  -1.000  -1.000  -1.000  -1.000  -1.000 -1262485505
ZLINSPEED     10000.000  -463978497
ZROTSPEED         6.109   881569293
ZLINSPEEDPARAM      0.900     0.900     0.950     0.950     0.950     0.950     0.950     0.950     0.950     0.950     0.950     0.950     0.000     0.000     0.000     0.000     0.000     0.000   770179083
ZLINACCTIME       0.900     0.900  1098907653
ZRADIUS_TEACH   3225.000  1250.000  1450.000   620.000   620.000   620.000     1.000     1.000     1.000     1.000     1.000     1.000     1.000     1.000     1.000     1.000     1.000     1.000  -424073217
ZRADIUS_TEACH2   3225.000  1250.000  1450.000   620.000   620.000   620.000     1.000     1.000     1.000     1.000     1.000     1.000     1.000     1.000     1.000     1.000     1.000     1.000  -424073217
EXSPIN                0         0          -1
ZFGEFTA       0.000000          -1
ZFGEFTB       0.000000          -1
ZFGEFTC       0.000000          -1
ZFTOLGA       0.000000          -1
ZFTOLGB       0.000000          -1
ZFTOLGC       0.000000          -1
ZFACCTA       0.000000          -1
ZFACCTB       0.000000          -1
ZFACCTC       0.000000          -1
ACTIVE_SPN_JT          0
MSPIN_DATA1   0 100 1       -1516
MSPIN_DATA2   0 100 1       -1516
MSPIN_DATA3   0 100 1       -1516
MSPIN_DATA4   0 100 1       -1516
MSPIN_DATA5   0 100 1       -1516
MSPIN_DATA6   0 100 1       -1516
MSPIN_ZENDLESS1           0          0          0          0          -1          -1
MSPIN_ZENDLESS2           0          0          0          0          -1          -1
MSPIN_ZENDLESS3           0          0          0          0          -1          -1
MSPIN_ZENDLESS4           0          0          0          0          -1          -1
MSPIN_ZENDLESS5           0          0          0          0          -1          -1
MSPIN_ZENDLESS6           0          0          0          0          -1          -1
NETCONF      10.0.24.5,"",255.255.255.0,10.0.24.1,0.0.0.0,0.0.0.0,""
ZSETREFFLT_T         48        48        48       -2161
ZSETREFSIG_T         24        -361
ZCINTFAC          0.000     0.000     1.000   120.000    10.000    48.000     0.000     0.000     0.000     0.000   268632063
ZCVENCTYPE    0          -1
ZVREC         OFF -3145
CE_ERRMASK    OFF -4302
KCOMJUMPR         1.500     1.500     1.500     1.500     1.300     1.300     1.300     1.300     1.300     1.300     1.300     1.300     1.300     1.300     1.300     1.300     1.300     1.300
ZMTWST        8.000   822083583
OP_GENK       ON  -3816
OP_NEWSERVO   ON  -4911
OP_ZSCPSWSET  ON  -5116
OP_JT23WSRV   ON  -4944
OP_WEIGHTACC  ON  -3993
OP_DYCOMP     OFF -4425
OP_DRYRUN     ON  -4702
OP_VELCOIN    OFF -4353
OP_REFFLT     OFF -4414
OP_2STEPDEC   OFF -3910
OP_NOBRKTOOL  OFF -4766
OP_REFCOIN    OFF -4286
OP_VACDC      ON  -3506
OP_VACDCTYPE    0
OP_VACDCRATIO  1.000
OP_MIRROR     ON  -4649
OP_SHIFT      ON  -4287
OP_DATACONV   ON  -4759
OP_AUTOTOOL   ON  -4732
OP_4P_CONV    OFF -4838
OP_ABSCMP     OFF -4234
OP_FTOOL      OFF -4230
OP_WORKDIME   OFF -4235
OP_PALLET     OFF -4374
OP_SENSING    OFF -4258
OP_CHGGAIN    OFF -4098
OP_CVF        OFF -3668
CVF_TRACK     OFF -3998
OP_STRTDLY    OFF -5020
OP_SFTABS     OFF -4287
OP_FLEXCOMP   OFF -4637
OP_IFP        ON  -3800
OP_INTDEFSIG  ON  -4326
OP_MLTOXWX    OFF -5336
OP_OUTCUBE    ON  -4106
OP_MTROFFERR  OFF -4853
OP_OXKEEPHLD  OFF -4262
OP_STORAGE    OFF -4060
OP_OXWXEXT    OFF -5150
OP_ROUTESIG   OFF -4434
OP_BSPEED     OFF -3768
OP_DIRECTSP   OFF -4733
OP_CONSTAD    OFF -4042
OP_MLTSPDSET  OFF -4926
OP_SPLMT      OFF -4530
OP_ROTVEL     ON  -4383
OP_SPTYPE2    ON  -3727
OP_ACCUTYPE2  ON  -3818
OP_MTN_CHK    OFF -4417
OP_COLDET     OFF -4300
OP_BLTARM     ON  -4279
OP_IPKALM     OFF -4145
OP_KADOUINFO  ON  -4586
OP_IMON2      OFF -3341
OP_AUTOHELP   OFF -4590
OP_INVCPY     OFF -4838
OP_COOP       OFF -4120
OP_ROBNET     OFF -4426
OP_1TP_ROBNET  OFF -4967
OP_EDIEXE     OFF -4012
OP_CIRCLE     ON  -3854
OP_HYBINT     OFF -4548
OP_BUILT      OFF -4398
OP_BUILT2     OFF -3559
OP_VISION     OFF -4445
OP_FDD        OFF -3287
OP_RELAY      OFF -4422
OP_COMMU1     ON  -3561
OP_FIELDBUS   ON  -4657
OP_CCLINK     OFF -4078
OP_RIO        OFF -3931
OP_CNET       OFF -4086
OP_KLOGIC     OFF -3816
OP_SLOGIC     OFF -3869
OP_HI_KLOGIC  OFF -4253
OP_SPIN       OFF -4090
OP_OUTDISIG   OFF -4363
OP_HANDCC     OFF -3571
OP_EXTSPIN    OFF -4610
OP_OUTSPEED   OFF -4190
OP_TOSYUT     OFF -5059
OP_SENSOR3D   OFF -3965
OP_GRAVCOMP   OFF -4635
ROBNETID        2  -1         -16
STEPPER2      OFF -3247
ZSETSTEPDEC          48        32       -1201
SRVPRM_JTA_A      0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0          -1
SRVPRM_JTA_B      0     0     0     0     0     0     0     0          -1
SRVPRM_JTB_A      0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0          -1
SRVPRM_JTB_B      0     0     0     0     0     0     0     0          -1
SEP_CNTL_BASIC      0     1     0         -16
SEP_CNTL_JT       0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0          -1
SEP_CNTL_MC     150   150   150   150   150   150   150   150   150   150   150   150      -27001
SEPARATE_GROUP      0     0     0     0     0     0     0     0          -1
SEP_1GRP_PLURALAXS    0
GROUP_POS_FIX       0    0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
STAGE_NUM     0          -1
STAGE_FRAME1    0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0          -1
STAGE_FRAME2    0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0          -1
STAGE_FRAME3    0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0          -1
STAGE_FRAME4    0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0          -1
STAGE_FRAME5    0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0          -1
STAGE_CONV_JT7 0   0.0   0.0   0.0   0.0   0.0 -537364489
STAGE_CONV_JT8 0   0.0   0.0   0.0   0.0   0.0 -537364517
STAGE_CONV_JT9 0   0.0   0.0   0.0   0.0   0.0 -537364545
STAGE_CONV_JT10 0   0.0   0.0   0.0   0.0   0.0 -537364573
STAGE_CONV_JT11 0   0.0   0.0   0.0   0.0   0.0 -537364601
STAGE_CONV_JT12 0   0.0   0.0   0.0   0.0   0.0 -537364629
STAGE_CONV_JT13 0   0.0   0.0   0.0   0.0   0.0 -537364657
STAGE_CONV_JT14 0   0.0   0.0   0.0   0.0   0.0 -537364685
STAGE_CONV_JT15 0   0.0   0.0   0.0   0.0   0.0 -537364713
STAGE_CONV_JT16 0   0.0   0.0   0.0   0.0   0.0 -537364741
STAGE_CONV_JT17 0   0.0   0.0   0.0   0.0   0.0 -537364769
STAGE_CONV_JT18 0   0.0   0.0   0.0   0.0   0.0 -537364797
SEPARATE_CUBE1    0.0   0.0   0.0   0.0   0.0   0.0          -1
SEPARATE_CUBE2    0.0   0.0   0.0   0.0   0.0   0.0          -1
SEPARATE_CUBE3    0.0   0.0   0.0   0.0   0.0   0.0          -1
SEPARATE_CUBE4    0.0   0.0   0.0   0.0   0.0   0.0          -1
SEPARATE_CUBE5    0.0   0.0   0.0   0.0   0.0   0.0          -1
SEPARATE_ALIGN      0     0     0     0     0     0     0     0     0     0     0     0          -1
POS_HOME_GR1_1      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR1_1_ALN_DIS    0
POS_HOME_GR1_2      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR1_2_ALN_DIS    0
POS_HOME_GR1_3      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR1_3_ALN_DIS    0
POS_HOME_GR1_4      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR1_4_ALN_DIS    0
POS_HOME_GR1_5      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR1_5_ALN_DIS    0
POS_HOME_GR1_6      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR1_6_ALN_DIS    0
POS_HOME_GR1_7      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR1_7_ALN_DIS    0
POS_HOME_GR2_1      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR2_1_ALN_DIS    0
POS_HOME_GR2_2      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR2_2_ALN_DIS    0
POS_HOME_GR2_3      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR2_3_ALN_DIS    0
POS_HOME_GR2_4      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR2_4_ALN_DIS    0
POS_HOME_GR2_5      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR2_5_ALN_DIS    0
POS_HOME_GR2_6      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR2_6_ALN_DIS    0
POS_HOME_GR2_7      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR2_7_ALN_DIS    0
POS_HOME_GR3_1      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR3_1_ALN_DIS    0
POS_HOME_GR3_2      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR3_2_ALN_DIS    0
POS_HOME_GR3_3      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR3_3_ALN_DIS    0
POS_HOME_GR3_4      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR3_4_ALN_DIS    0
POS_HOME_GR3_5      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR3_5_ALN_DIS    0
POS_HOME_GR3_6      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR3_6_ALN_DIS    0
POS_HOME_GR3_7      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR3_7_ALN_DIS    0
POS_HOME_GR4_1      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR4_1_ALN_DIS    0
POS_HOME_GR4_2      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR4_2_ALN_DIS    0
POS_HOME_GR4_3      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR4_3_ALN_DIS    0
POS_HOME_GR4_4      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR4_4_ALN_DIS    0
POS_HOME_GR4_5      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR4_5_ALN_DIS    0
POS_HOME_GR4_6      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR4_6_ALN_DIS    0
POS_HOME_GR4_7      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR4_7_ALN_DIS    0
POS_HOME_GR5_1      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR5_1_ALN_DIS    0
POS_HOME_GR5_2      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR5_2_ALN_DIS    0
POS_HOME_GR5_3      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR5_3_ALN_DIS    0
POS_HOME_GR5_4      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR5_4_ALN_DIS    0
POS_HOME_GR5_5      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR5_5_ALN_DIS    0
POS_HOME_GR5_6      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR5_6_ALN_DIS    0
POS_HOME_GR5_7      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000   0
POS_HOME_GR5_7_ALN_DIS    0
SGRP_JT_MC_MAP          7         8         9        10        11         1
ZSWITCH ZDISP_GANTI     OFF  -513
ZSWITCH ZKILL_LOAD      OFF  -511
ZSWITCH ZLANGUAGE       ON   -507
ZSWITCH ZSAFE_CE        ON   -505
ZSWITCH ZSAFE_STD       OFF  -509
ZSWITCH ZWELD.COMP      OFF  -511
ZSWITCH ZTPLIGHT_ON     OFF  -513
ZSWITCH Z1HS.HAND       OFF  -509
ZSWITCH ZSPLMT          OFF  -503
ZSWITCH ZWSPACE         ON   -503
ZSWITCH ZFIXED          OFF  -503
ZSWITCH ZCLAMP_PULSE1   OFF  -517
ZSWITCH ZHYBINT         OFF  -505
ZSWITCH ZHYBINT.AUTO    OFF  -515
ZSWITCH ZHYBINT.TCH     OFF  -513
ZSWITCH ZIGNCONF        OFF  -507
ZSWITCH ZIGNCONF.TCH    OFF  -515
ZSWITCH ZMODEM          OFF  -503
ZSWITCH ZINCHI_POSCTRL  OFF  -519
ZSWITCH ZROTOPT         OFF  -505
ZSWITCH ZCINT           ON   -499
ZSWITCH ZCINT.FIXSP     OFF  -513
ZSWITCH ZCINT.AUTO      ON   -509
ZSWITCH ZCINT.C1C1      OFF  -511
ZSWITCH ZCINT.SHORT     ON   -511
ZSWITCH ZNEWPLAN        ON   -505
ZSWITCH ZNEWPLAN.OAT    ON   -513
ZSWITCH ZNEWPLAN.NXT    ON   -513
ZSWITCH ZNSP            ON   -497
ZSWITCH ZJINT           OFF  -501
ZSWITCH ZYCP            ON   -497
ZSWITCH ZSINACC         OFF  -505
ZSWITCH ZCHKCOIN        ON   -505
ZSWITCH ZLADMX          ON   -501
ZSWITCH ZDECKAI         ON   -503
ZSWITCH ZCINTVEKAI      ON   -509
ZSWITCH ZCYCFIX         ON   -503
ZSWITCH ZCMNDJUMPDSP    OFF  -515
ZSWITCH ZSOUKOU         ON   -503
ZSWITCH ZREFFLT         OFF  -505
ZSWITCH ZFIRFLT         OFF  -505
ZSWITCH ZREFKAI         ON   -503
ZSWITCH ZREFSIG         OFF  -505
ZSWITCH ZRELATE         OFF  -505
ZSWITCH ZEMGRESET       OFF  -509
ZSWITCH ZCHKHOME        OFF  -507
ZSWITCH ZADFIX          OFF  -503
ZSWITCH ZIPEAKWRN       ON   -507
ZSWITCH ZI2MONWRN       ON   -507
ZSWITCH ZCMNDJ_STOP     OFF  -513
ZSWITCH ZPSB.FANCTL     ON   -511
ZSWITCH ZPSB.HOLDTIME   ON   -515
ZSWITCH ZPSB.PTYPE      OFF  -511
ZSWITCH ZERRLOGALL      OFF  -511
ZSWITCH ZUSR_SENSOR     ON   -511
ZSWITCH ZBUILT_VALVE    ON   -513
ZSWITCH ZVALVE_COMMON   ON   -515
ZSWITCH ZROBNETCMNSIG   OFF  -517
ZSWITCH ZVSW_CAMERA     OFF  -513
ZSWITCH ZCHGCONF        OFF  -507
ZSWITCH ZEXIST_TP       ON   -507
ZSWITCH ZEXIST1_PNL     ON   -511
ZSWITCH ZEXIST2_PNL     OFF  -513
ZSWITCH ZEXIST_ENC      OFF  -511
ZSWITCH ZEXIST1_SH      ON   -509
ZSWITCH ZEXIST2_SH      ON   -509
ZSWITCH ZEXIST3_SH      ON   -509
ZSWITCH ZEXIST4_SH      ON   -509
ZSWITCH ZTP.TRG.SW      ON   -509
ZSWITCH ZMASK1_SV       OFF  -509
ZSWITCH ZMASK2_SV       OFF  -509
ZSWITCH ZMASK1_LS       OFF  -509
ZSWITCH ZMASK2_LS       OFF  -509
ZSWITCH ZMASK1_PU       ON   -507
ZSWITCH ZMASK2_PU       ON   -507
ZSWITCH ZCONSTAD        OFF  -507
ZSWITCH ZSCP            ON   -497
ZSWITCH ZFCP            OFF  -499
ZSWITCH ZF2CP           OFF  -501
ZSWITCH ZMCP            OFF  -499
ZSWITCH ZTCH_TOPPEN     OFF  -513
ZSWITCH ZCHK_TOPPEN     OFF  -513
ZSWITCH ZREP_TOPPEN     OFF  -513
ZSWITCH ZTCH2_TOPPEN    ON   -513
ZSWITCH ZCHK2_TOPPEN    ON   -513
ZSWITCH ZREP2_TOPPEN    OFF  -515
ZSWITCH ZWAITENCPWR     ON   -511
ZSWITCH ZTPPORT         OFF  -505
ZSWITCH ZINSIG          OFF  -503
ZSWITCH ZEXTSW          OFF  -503
ZSWITCH ZADCCAL         OFF  -505
ZSWITCH Z_IVAR          ON   -501
ZSWITCH ZNCHVAR         OFF  -505
ZSWITCH ZPCMDFLT        OFF  -507
ZSWITCH ZPCMD3FLT       ON   -507
ZSWITCH ZNOTCH          OFF  -503
ZSWITCH ZSRVCHK         ON   -503
ZSWITCH ZCHKASCYC       ON   -507
ZSWITCH ZRESTORE        ON   -505
ZSWITCH ZCALJL          ON   -501
ZSWITCH ZCALGRAV        ON   -505
ZSWITCH ZCALFS          ON   -501
ZSWITCH ZCALKSPVP       ON   -507
ZSWITCH ZCALKOBS        ON   -505
ZSWITCH ZPDFF           ON   -499
ZSWITCH ZVDFF           ON   -499
ZSWITCH ZCOLDET         OFF  -505
ZSWITCH ZATGEF          OFF  -503
ZSWITCH ZCALNCHPRM      OFF  -511
ZSWITCH ZIBS.WORD       OFF  -509
ZSWITCH ZIBS.RVS        OFF  -507
ZSWITCH ZCHKROT6        ON   -505
ZSWITCH ZWX.OLD         OFF  -505
ZSWITCH ZMTN1FLT        ON   -505
ZSWITCH ZLINACC         OFF  -505
ZSWITCH ZDIRECTHELP     OFF  -513
ZSWITCH ZAUTOHELP       ON   -507
ZSWITCH ZREFSP          OFF  -503
ZSWITCH ZSNS_SINGULAR   OFF  -517
ZSWITCH ZSGMWELD_MODE   OFF  -517
ZSWITCH ZSSC_SVPRM_NOCHK_LIM OFF  -531
ZSWITCH ZSSC_ENC_ORG    OFF  -515
ZSWITCH ZBEAD.OLD       OFF  -509
ZSWITCH ZHSSENSOR       OFF  -509
ZSWITCH ZHSVALVE        OFF  -507
ZSWITCH ZREFJNT         OFF  -505
ZSWITCH ZSAFE_USA       OFF  -509
ZSWITCH ZVMESTOP_ACFAIL OFF  -521
ZSWITCH ZLMCOMP         ON   -503
ZSWITCH ZBKLCOMP        ON   -505
ZSWITCH ZENCERRCHK      OFF  -511
ZSWITCH ZCALINERTIA     OFF  -513
ZSWITCH ZXYZSFT_NO_SYSBASE OFF  -527
ZSWITCH ZSP_NEWMTN_MOD  OFF  -519
ZSWITCH ZREFFLT_DOUBLE  ON   -517
ZSWITCH ZKLG_DSP_WARN   OFF  -517
ZSWITCH ZSAFE_TPON      OFF  -511
ZSWITCH ZSAFE_HOLD_FORD OFF  -521
ZSWITCH Z_ALWAYSSEP     OFF  -513
ZSWITCH ZSGRP_TCH_SRV   OFF  -517
ZSWITCH ZLIMSPINANGRESET OFF  -523
ZSWITCH ZSAFE_TAPON     OFF  -513
ZSWITCH ZSEAL_NOTDISP   OFF  -517
ZSWITCH ZSKIP_ENCERR    ON   -513
ZSWITCH ZENA_FB_HSENSE  OFF  -519
ZSWITCH ZFIXSPINANGRESET OFF  -523
ZSWITCH ZTPCAMERADISP   OFF  -517
ZSWITCH ZFIX_CINT_SP    OFF  -515
ZSWITCH ZBLINE_EUROPE   ON   -515
ZSWITCH ZFIX_SLOW_SP    OFF  -515
.END
.OPE_INFO1
OPEINFO  14 4 6 1229  1263830092  ;(10/1/18 15:54:52) ZD130S-D001 
CONT_TIM  21880.9 
SERV_TIM  508.2 
MTON_CNT  13938 
ESTP_CNT  52 
BRKE_CNT  15814 
OPEINFO COLDET_CNT  0 
MOVE_TJT  108.1 134.2 123.1 93.4 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 
DIST_DJT  4917.264 4217.560 4288.968 6199.776 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 
M_OPEINFO  14 4 6 1229  -1601903448  ;(70/1/1 0:00:00) ZD130S-D001 
M_CONT_TIM  21883.6 
M_SERV_TIM  509.3 
M_MTON_CNT  13980 
M_ESTP_CNT  52 
M_BRKE_CNT  15856 
M_OPEINFO COLDET_CNT  0 
M_MOVE_TJT  108.5 134.8 123.7 93.8 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 
M_DIST_DJT  4974.376 4283.056 4360.080 6287.632 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 
HOUR_MTR  21883.6 
.END
.SYSDATA
REG_POINT       0
BASE              0.000     0.000     0.000     0.000     0.000     0.000
ENV_DATA              0   0   0   0   0   0   0   0   0   0
ENV2_DATA       0   0   0   0   0   0   0   0   0   0
CHECK_SPEC      1   1   1   1   1   1   0   1   0   1
DEFSIG_I EXT_MTRON       OFF  1032
DEFSIG_I EXT_ERR_RESET   OFF  1036
DEFSIG_I EXT_CYC_START   ON   1369
DEFSIG_I EXT_PROGRM_RST  ON   1382
DEFSIG_I EXT_JUMP        OFF
         JUMP_ON             0
         JUMP_OFF            0
         JUMP_ST             0
DEFSIG_I EXT_RPS         OFF
         RPS_ON              0
         RPS_ST              0
         RPS_CODE            0     0     0
DEFSIG_I EXT_IT          OFF  1035
DEFSIG_I EXT_SLOW_REP.   OFF     0
DEFSIG_I GUN_ACCEPT      OFF     0
DEFSIG_I SENSING         OFF     0
DEFSIG_I SENS_SPD        OFF     0
DEFSIG_I SENSWAIT        OFF     0
DEFSIG_I EXT_HOLD_RESET  OFF     0
DEFSIG_I EXT_PH_PULSE.   OFF     0
DEFSIG_I I/F_PAGE1       OFF     0
DEFSIG_I I/F_PAGE2       OFF     0
DEFSIG_I I/F_PAGE3       OFF     0
DEFSIG_I I/F_PAGE4       OFF     0
DEFSIG_I OPTIMIZE_MODE   OFF     0
DEFSIG_I AUTOSAVE_C1     OFF     0
DEFSIG_I AUTOSAVE_C2     OFF     0
DEFSIG_I AUTOSAVE_C3     OFF     0
DEFSIG_I PCEXT_START     OFF     0
DEFSIG_I PCEXT_ABORT     OFF     0
DEFSIG_I EXT_GUN1_OUT    OFF     0
DEFSIG_I EXT_GUN2_OUT    OFF     0
DEFSIG_I EXT_GUN3_OUT    OFF     0
DEFSIG_I EXT_GUN4_OUT    OFF     0
DEFSIG_I EXT_KOUSEI      OFF     0
DEFSIG_I EXT_KEISOKU     OFF     0
DEFSIG_I EXT_TUSIN       OFF     0
DEFSIG_I EXT_HO_KIRI     OFF     0
DEFSIG_I EXT_CAMERA_G    OFF     0
DEFSIG_I EXT_INTSTART1   OFF     0
DEFSIG_I EXT_INTSTART2   OFF     0
DEFSIG_I EXT_INTSTART3   OFF     0
DEFSIG_I EXT_AXIS_REGULATION_SIGNAL  OFF
         JT_7             1000  1000  1000  1000  1000  1000
DEFSIG_I GROUP_0         OFF     0
DEFSIG_I GROUP_-1        OFF     0
DEFSIG_I SEP_GROUP1_IN   OFF
         GR1_PN_CMD          0     0  1000  1000
DEFSIG_I SEP_GROUP2_IN   OFF
         GR2_PN_CMD          0     0  1000  1000
DEFSIG_I SEP_GROUP3_IN   OFF
         GR3_PN_CMD          0     0  1000  1000
DEFSIG_I SEP_GROUP4_IN   OFF
         GR4_PN_CMD          0     0  1000  1000
DEFSIG_I SEP_GROUP5_IN   OFF
         GR5_PN_CMD          0     0  1000  1000
DEFSIG_I SEP_GROUP_JT7_IN  OFF
         JT7_PN_CMD          0     0
DEFSIG_I SEP_GROUP_JT8_IN  OFF
         JT8_PN_CMD          0     0
DEFSIG_I SEP_GROUP_JT9_IN  OFF
         JT9_PN_CMD          0     0
DEFSIG_I SEP_GROUP_JT10_IN  OFF
         JT10_PN_CMD         0     0
DEFSIG_I SEP_GROUP_JT11_IN  OFF
         JT11_PN_CMD         0     0
DEFSIG_I SEP_GROUP_JT12_IN  OFF
         JT12_PN_CMD         0     0
DEFSIG_I SEP_GROUP_IN_KEY  OFF
         NO1_PKEY         1000  1000  1000  1000  1000  1000  1000  1000  1000  1000  1000  1000
DEFSIG_I SEP_GROUP1_REP_SIG  OFF
         DRIVE_COM_G1     1000
         DRIVE_SPD_G1     1000
         END_LOC_CNT_G1      0  1000
DEFSIG_I SEP_GROUP2_REP_SIG  OFF
         DRIVE_COM_G2     1000
         DRIVE_SPD_G2     1000
         END_LOC_CNT_G2      0  1000
DEFSIG_I SEP_GROUP3_REP_SIG  OFF
         DRIVE_COM_G3     1000
         DRIVE_SPD_G3     1000
         END_LOC_CNT_G3      0  1000
DEFSIG_I SEP_GROUP4_REP_SIG  OFF
         DRIVE_COM_G4     1000
         DRIVE_SPD_G4     1000
         END_LOC_CNT_G4      0  1000
DEFSIG_I SEP_GROUP5_REP_SIG  OFF
         DRIVE_COM_G5     1000
         DRIVE_SPD_G5     1000
         END_LOC_CNT_G5      0  1000
DEFSIG_I EXT_CVSET       OFF     0
DEFSIG_I DELAYCNT_RESET  OFF     0
DEFSIG_O MOTOR_ON        OFF    37
DEFSIG_O ERROR           OFF   533
DEFSIG_O AUTOMATIC       OFF     3
         CND_RUN         ON 
         CND_EHOLD       OFF
         CND_REPEAT      ON 
         CND_CCONT       ON 
         CND_SCONT       ON 
         CND_TLOCK       OFF
         CND_CYCLE       OFF
         CND_RGSO        OFF
         CND_DRYOFF      OFF
         CND_CYC_EXT     OFF
DEFSIG_O CYCLE_START     OFF    33
DEFSIG_O TEACH_MODE      OFF    28
DEFSIG_O HOME1           OFF    27
DEFSIG_O HOME2           OFF     0
DEFSIG_O POWER_ON        OFF     0
DEFSIG_O RGSO            OFF     0
DEFSIG_O RPS             OFF     0
DEFSIG_O WORK_SPACE_1    OFF     0
DEFSIG_O WORK_SPACE_2    OFF     0
DEFSIG_O WORK_SPACE_3    OFF     0
DEFSIG_O WORK_SPACE_4    OFF     0
DEFSIG_O WORK_SPACE_5    OFF     0
DEFSIG_O WORK_SPACE_6    OFF     0
DEFSIG_O WORK_SPACE_7    OFF     0
DEFSIG_O WORK_SPACE_8    OFF     0
DEFSIG_O WORK_SPACE_9    OFF     0
DEFSIG_O OUT_SPRAY_OK    OFF     0
DEFSIG_O OUT_RPS_OK      OFF     0
DEFSIG_O OUT_RPS_PROG    OFF
         OUT_RPS_CODE        0     0
DEFSIG_O STEP_CODE       OFF
         OUT_STEP_CNT        0     0
DEFSIG_O OUT_DISIG       OFF     4    13  1013
DEFSIG_O RB2AUTOMATIC    OFF     0
DEFSIG_O RB2HOME1        OFF     0
DEFSIG_O RB2HOME2        OFF     0
DEFSIG_O RB2WORK_SPACE_1  OFF     0
DEFSIG_O RB2WORK_SPACE_2  OFF     0
DEFSIG_O RB2WORK_SPACE_3  OFF     0
DEFSIG_O RB2WORK_SPACE_4  OFF     0
DEFSIG_O RB2WORK_SPACE_5  OFF     0
DEFSIG_O RB2WORK_SPACE_6  OFF     0
DEFSIG_O RB2WORK_SPACE_7  OFF     0
DEFSIG_O RB2WORK_SPACE_8  OFF     0
DEFSIG_O RB2WORK_SPACE_9  OFF     0
DEFSIG_O CVF_LS2         OFF     0
DEFSIG_O CVF_PH2         OFF     0
DEFSIG_O CHECK_MODE      OFF     0
DEFSIG_O ENCBRK_OFF      OFF    15
DEFSIG_O WAITING         OFF     0
DEFSIG_O IBS_SLA_ERR     OFF     0
DEFSIG_O MECHA_WARNING   OFF     0
DEFSIG_O OUT_EBVCMD      OFF     0
DEFSIG_O OUT_MATCIR1     OFF     0
DEFSIG_O OUT_MATCIR2     OFF     0
DEFSIG_O CVSIMU          OFF     0
DEFSIG_O AUTOSAVE_WA     OFF     0
DEFSIG_O MTN_CHECK       OFF     0
DEFSIG_O SENS_ERR1       OFF     0
DEFSIG_O SENS_ERR2       OFF     0
DEFSIG_O SENS_ERR3       OFF     0
DEFSIG_O SENS_ERR4       OFF     0
DEFSIG_O SENS_ERR5       OFF     0
DEFSIG_O PC_EXE          OFF     0
DEFSIG_O EMERGENCY       OFF     0
DEFSIG_O DRYRUN          OFF     0
DEFSIG_O OUT_KOUSEI      OFF     0
DEFSIG_O OUT_KEISOKU     OFF     0
DEFSIG_O OUT_INCOMMU     OFF     0
DEFSIG_O OUT_COMMU_ERR   OFF     0
DEFSIG_O DELAY_QUE_OK    OFF     0
DEFSIG_O SEP_GROUP1_OUT  OFF
         GR1_ENABLE          0
DEFSIG_O SEP_GROUP2_OUT  OFF
         GR2_ENABLE          0
DEFSIG_O SEP_GROUP3_OUT  OFF
         GR3_ENABLE          0
DEFSIG_O SEP_GROUP4_OUT  OFF
         GR4_ENABLE          0
DEFSIG_O SEP_GROUP5_OUT  OFF
         GR5_ENABLE          0
DEFSIG_O SEP_GR1_REP_OSIG  OFF
         POS_DRIVE_RDY_G1      0
         POS_DRIVE_G1        0
         POS_SRVING_G1       0
         POS_STOP_G1         0
         POS_HOME_CNT_G1      0     0
DEFSIG_O SEP_GR2_REP_OSIG  OFF
         POS_DRIVE_RDY_G2      0
         POS_DRIVE_G2        0
         POS_SRVING_G2       0
         POS_STOP_G2         0
         POS_HOME_CNT_G2      0     0
DEFSIG_O SEP_GR3_REP_OSIG  OFF
         POS_DRIVE_RDY_G3      0
         POS_DRIVE_G3        0
         POS_SRVING_G3       0
         POS_STOP_G3         0
         POS_HOME_CNT_G3      0     0
DEFSIG_O SEP_GR4_REP_OSIG  OFF
         POS_DRIVE_RDY_G4      0
         POS_DRIVE_G4        0
         POS_SRVING_G4       0
         POS_STOP_G4         0
         POS_HOME_CNT_G4      0     0
DEFSIG_O SEP_GR5_REP_OSIG  OFF
         POS_DRIVE_RDY_G5      0
         POS_DRIVE_G5        0
         POS_SRVING_G5       0
         POS_STOP_G5         0
         POS_HOME_CNT_G5      0     0
DEFSIG_O SEP_GROUP_NO_OSIG  OFF
         GROUP_NO_CNT        4     0
RMTOUT960     1 17 16385 16401 16417 16433 16449 16465 16481 32769 32785 32801 32817 32833 32849 32865 32881 32897 32913 32929 32945 32961 32977 32993 33009 33025 33041 33057 33073 33089 33105 33121 33137 33153 33169 33185 33201 33217 33233 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   -16576186
RMTIN960      1001 1017 17385 17401 17417 17433 17449 17465 17481 17497 17513 17529 17545 17561 17577 17593 17609 17625 17641 17657 17673 17689 17705 33769 33785 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    -6570256
FIBUS_MASTER    3
FIBUS_SLAVE     4
FB_SIGNAL_ORDER_MAS  0 0
FB_SIGNAL_ORDER_SLA  0 0
FB_CCLINK_COM_PARM 1 3 1 0 0 0
FB_CCLINK_UNIT_PARM[1] 1 1 2 1 4 1 128
FIBUS_INTDATA_SIZE_PORT   16  16
FIBUS_INTDATA_SIZE_UNIT    0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0
FB_ETNIP_IPA 192.168.0.2,255.255.255.0,0.0.0.0,10
FB_ETNIP_IPA2 192.168.0.1,255.255.255.0,0.0.0.0,10
FB_EIP_CONF  0.0.0.0,0.0.0.0,"",""
FB_EIP_CONF2 0.0.0.0,0.0.0.0,"",""
FBDNSCANNER  1 10 75 1
FB_EIP_IO_CONN    0
FB_EIP_IO_CONN2    0
FB_ETN_TIMEOUT      10
FB_ETN_TIMEOUT2      10
CONFIGVISION    0   0
ARM_OX_TOP            1
ARM_OX_NUM            0
ARM_WX_TOP         1013
ARM_WX_NUM            2
CHECK_SPEED2     10.000    20.000    30.000
MTNCHK_KEYS   OFF OFF
SYS_BASE          0.000     0.000     0.000     0.000     0.000     0.000
TOOL              0.000     0.000     0.000  -180.000     0.000     0.000
FTOOL             0.000     0.000     0.000     0.000     0.000     0.000
DFF             130.000     0.000     0.000     0.000     0.000     0.000     0.000
SETSIO             9600         2
PROTOCOL          5.000     5.000     5.000         1         1         1
SET2SIO            9600         2
CVDIRECT          1.000     0.000
CVSCALE        0.500000
CVMAXSPD        500.000
CVGAIN           50.000
CVPITCH           0.000
CVFNONPITCH       0.000
CVFLS2            0.000
CVFPH2            0.000
CVFMAX            0.000
CVSMAX         1000.000
CVSPEED         100.000
SETOUTDA[1]   3000 8 1 10.0 0.0 0 0 0 0 0
SETOUTDA[2]   3000 8 1 10.0 0.0 0 0 0 0 0
SETOUTDA[3]   3000 8 1 10.0 0.0 0 0 0 0 0
SETOUTDA[4]   3000 8 1 10.0 0.0 0 0 0 0 0
SETOUTDA[5]   3000 8 1 10.0 0.0 0 0 0 0 0
SETOUTDA[6]   3000 8 1 10.0 0.0 0 0 0 0 0
SETOUTDA[7]   3000 8 1 10.0 0.0 0 0 0 0 0
SETOUTDA[8]   3000 8 1 10.0 0.0 0 0 0 0 0
SETOUTDA[9]   3000 8 1 10.0 0.0 0 0 0 0 0
SETOUTDA[10]  3000 8 1 10.0 0.0 0 0 0 0 0
ARMPROTOCOL        5000       100         3
SCSETSIO           9600         0
SCSETSIO7          9600         0
SCPROTOCOL           50        20         3
SCPROTOCOL7          50        20         3
SC_TOP_CODE           0         0         0         0         0         0         0         0         0         0         0         0         0         0         0
SC_END_CODE           0         0         0         0         0         0         0         0         0         0         0         0         0         0         0
SC_TOP_CODE7          0         0         0         0         0         0         0         0         0         0         0         0         0         0         0
SC_END_CODE7          0         0         0         0         0         0         0         0         0         0         0         0         0         0         0
SETCOMMODE            0         0
SIOTBL_SIG          128       128       128       128        64        64        64        64        64        64       128        16        16         0        16        16        80        24         8
SIOTBL_HEAD           1      1001       301      1301       501      1501       601      1601       729      1729      2301      2501      2601         0      2701      2801      2901       451      1451
SIOTBL_DATA           0         4         8        12        16        20        24        28        64        68        32        36        40        -1        44        48        52        56        60
SIOTBL_OFF           72
DEFAULT_DEVICE    0
FD_VERIFY       1
CARD_VERIFY     0
PSB_FANCTL            1        30        30
ERRLOG_SIGNO          0         0         0         0         0         0         0         0
OPLOG_SIGNO           0         0         0         0         0         0         0         0
ERRLOG_FLTNO          0         0         0         0         0         0         0         0         0         0
ZELOG_DEBUG           0
USR_P_LEVEL     0   0
LSQ_CYCMAX         1000
FSPAL           0
ZAUTOSCDL[1]    0   0   0   0
ZAUTOCMND[1] 
ZSAVECNFG[1] 0 0      
ZAUTOSCDL[2]    0   0   0   0
ZAUTOCMND[2] 
ZSAVECNFG[2] 0 0      
ZAUTOSCDL[3]    0   0   0   0
ZAUTOCMND[3] 
ZSAVECNFG[3] 0 0      
ROBNET_SIG         0   1000
SWITCH CHECK.HOLD      OFF
SWITCH CP              ON 
SWITCH CYCLE.STOP      OFF
SWITCH OX.PREOUT       ON 
SWITCH PREFETCH.SIGINS OFF
SWITCH QTOOL           OFF
SWITCH REP_ONCE        OFF
SWITCH RPS             OFF
SWITCH STP_ONCE        OFF
SWITCH AFTER.WAIT.TMR  OFF
SWITCH FLEXCOMP        OFF
SWITCH MESSAGES        ON 
SWITCH SCREEN          ON 
SWITCH AUTOSTART.PC    ON 
SWITCH AUTOSTART2.PC   OFF
SWITCH AUTOSTART3.PC   OFF
SWITCH AUTOSTART4.PC   OFF
SWITCH AUTOSTART5.PC   OFF
SWITCH ERRSTART.PC     OFF
SWITCH DISPIO_01       ON 
SWITCH HOLD.STEP       ON 
SWITCH WS_COMPOFF      OFF
SWITCH WS.ZERO         OFF
SWITCH SLOW_START      OFF
SWITCH ABS.SPEED       OFF
SWITCH UDP_EMSG        ON 
SWITCH TOUCH.ENA       ON 
SWITCH PLC.CHECK       OFF
SWITCH FLOWRATE        OFF
SWITCH FLOWRATE2       OFF
SWITCH FLOWRATE3       OFF
SWITCH FLOWRATE4       OFF
SWITCH EBMATCIRC       OFF
SWITCH EB2MATCIRC      OFF
SWITCH SINGULAR        OFF
SWITCH TPSPEED.RESET   OFF
SWITCH NO_SJISCONV     OFF
SWITCH OXZERO          OFF
SWITCH CONF_VARIABLE   OFF
SWITCH DN_DISCON_ERR   OFF
SWITCH CAMIMG_CYC      OFF
.END
.AUXDATA
ROB_START_LIM      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000
ROB_START_LIM1      2.000     2.000     2.000     2.000     0.100     0.100     0.100     0.100     0.100     0.100     0.100     0.100     0.100     0.100     0.100     0.100     0.100     0.100
FTOOL1            0.000     0.000     0.000     0.000     0.000     0.000
FTOOL2            0.000     0.000     0.000     0.000     0.000     0.000
FTOOL3            0.000     0.000     0.000     0.000     0.000     0.000
FTOOL4            0.000     0.000     0.000     0.000     0.000     0.000
FTOOL5            0.000     0.000     0.000     0.000     0.000     0.000
FTOOL6            0.000     0.000     0.000     0.000     0.000     0.000
FTOOL7            0.000     0.000     0.000     0.000     0.000     0.000
FTOOL8            0.000     0.000     0.000     0.000     0.000     0.000
FTOOL9            0.000     0.000     0.000     0.000     0.000     0.000
TOOL1             0.000     0.000     0.000     0.000     0.000     0.000
DFF1            130.000     0.000     0.000     0.000
TOOL2             0.000     0.000     0.000     0.000     0.000     0.000
DFF2            130.000     0.000     0.000     0.000
TOOL3             0.000     0.000     0.000     0.000     0.000     0.000
DFF3            130.000     0.000     0.000     0.000
TOOL4             0.000     0.000     0.000     0.000     0.000     0.000
DFF4            130.000     0.000     0.000     0.000
TOOL5             0.000     0.000     0.000     0.000     0.000     0.000
DFF5            130.000     0.000     0.000     0.000
TOOL6             0.000     0.000     0.000     0.000     0.000     0.000
DFF6            130.000     0.000     0.000     0.000
TOOL7             0.000     0.000     0.000     0.000     0.000     0.000
DFF7            130.000     0.000     0.000     0.000
TOOL8             0.000     0.000     0.000     0.000     0.000     0.000
DFF8            130.000     0.000     0.000     0.000
TOOL9             0.000     0.000     0.000     0.000     0.000     0.000
DFF9            130.000     0.000     0.000     0.000
WORK1             0.000     0.000     0.000     0.000     0.000     0.000
WORK2             0.000     0.000     0.000     0.000     0.000     0.000
WORK3             0.000     0.000     0.000     0.000     0.000     0.000
WORK4             0.000     0.000     0.000     0.000     0.000     0.000
WORK5             0.000     0.000     0.000     0.000     0.000     0.000
WORK6             0.000     0.000     0.000     0.000     0.000     0.000
WORK7             0.000     0.000     0.000     0.000     0.000     0.000
WORK8             0.000     0.000     0.000     0.000     0.000     0.000
WORK9             0.000     0.000     0.000     0.000     0.000     0.000
UP-LIM          180.000    90.000    15.000   360.000     0.000     0.000    10.000    10.000    10.000    10.000    10.000    10.000    10.000    10.000    10.000    10.000    10.000    10.000
LO-LIM         -180.000   -50.000  -120.000  -360.000     0.000     0.000   -10.000   -10.000   -10.000   -10.000   -10.000   -10.000   -10.000   -10.000   -10.000   -10.000   -10.000   -10.000
ACCUR             1.000    10.000    50.000   100.000     1.000
SPEED            10.000    20.000    30.000    40.000    50.000    60.000    70.000    80.000    90.000   100.000
ACCEL           100.000   100.000   100.000   100.000   100.000   100.000   100.000   100.000   100.000   100.000
DECEL           100.000   100.000   100.000   100.000   100.000   100.000   100.000   100.000   100.000   100.000
SLOW_REPEAT      10.000
CHECK_SPEED      10.000   100.000   250.000
TEACH_SPEED      10.000   100.000   250.000     0.016
TIMER             0.000     0.100     0.200     0.300     0.400     0.500     0.600     0.700     0.800     0.900
FLOWGAIN        100.000
FLOWGAIN2       100.000
FLOWGAIN3       100.000
FLOWGAIN4       100.000
LINEAR1           0.00     0.50     1.00     1.50     2.00     2.50     3.00     3.50     4.00     4.50     5.00     5.50     6.00     6.50     7.00     7.50     8.00     8.50     9.00     9.50    10.00
LINEAR2              0     1500     3000     4500     6000     7500     9000    10500    12000    13500    15000    16500    18000    19500    21000    22500    24000    25500    27000    28500    30000
LINEAR1_2         0.00     0.50     1.00     1.50     2.00     2.50     3.00     3.50     4.00     4.50     5.00     5.50     6.00     6.50     7.00     7.50     8.00     8.50     9.00     9.50    10.00
LINEAR2_2            0     1500     3000     4500     6000     7500     9000    10500    12000    13500    15000    16500    18000    19500    21000    22500    24000    25500    27000    28500    30000
LINEAR1_3         0.00     0.50     1.00     1.50     2.00     2.50     3.00     3.50     4.00     4.50     5.00     5.50     6.00     6.50     7.00     7.50     8.00     8.50     9.00     9.50    10.00
LINEAR2_3            0     1500     3000     4500     6000     7500     9000    10500    12000    13500    15000    16500    18000    19500    21000    22500    24000    25500    27000    28500    30000
LINEAR1_4         0.00     0.50     1.00     1.50     2.00     2.50     3.00     3.50     4.00     4.50     5.00     5.50     6.00     6.50     7.00     7.50     8.00     8.50     9.00     9.50    10.00
LINEAR2_4            0     1500     3000     4500     6000     7500     9000    10500    12000    13500    15000    16500    18000    19500    21000    22500    24000    25500    27000    28500    30000
OUTSPED           0.00  2000.00    10.00     0.00      0 3000   8   1      0 0
OUTSPED2          0.00  2000.00    10.00     0.00      0 3000   8   1      0 0
OUTSPED3          0.00  2000.00    10.00     0.00      0 3000   8   1      0 0
OUTSPED4          0.00  2000.00    10.00     0.00      0 3000   8   1      0 0
3D_GAUGE2         0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000
3D_GAUGE3         0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000
3D_GAUGE4         0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000
3D_GAUGE5         0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000
3D_GAUGE6         0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000
3D_GAUGE7         0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000
3D_GAUGE8         0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000
3D_GAUGE9         0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000
3D_GAUGE10        0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000
3D_GAUGE11        0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000
3D_GAUGE12        0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000
3D_GAUGE13        0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000
3D_GAUGE14        0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000
3D_GAUGE15        0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000
3D_GAUGE16        0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000
3D_GAUGE_ENABLE    0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0
3D_MSTRANS        0.000     0.000     0.000     0.000     0.000     0.000
3D_MASTER         0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000
3D_SLAVE          0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000
3D_ETC           30.000   0   0
1HOME             0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000
2HOME             0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000    10.000
WORK_SPACE_1      0.000     0.000     0.000     0.000     0.000     0.000         0
WORK_SPACE_2      0.000     0.000     0.000     0.000     0.000     0.000         0
WORK_SPACE_3      0.000     0.000     0.000     0.000     0.000     0.000         0
WORK_SPACE_4      0.000     0.000     0.000     0.000     0.000     0.000         0
WORK_SPACE_5      0.000     0.000     0.000     0.000     0.000     0.000         0
WORK_SPACE_6      0.000     0.000     0.000     0.000     0.000     0.000         0
WORK_SPACE_7      0.000     0.000     0.000     0.000     0.000     0.000         0
WORK_SPACE_8      0.000     0.000     0.000     0.000     0.000     0.000         0
WORK_SPACE_9      0.000     0.000     0.000     0.000     0.000     0.000         0
         OUTFLOW_CALIB[1]      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000
         OUTFLOW_CALIB[2]      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000
         OUTFLOW_PRVT[1]      0.000     0.000     0.000     0.000
         OUTFLOW_PRVT[2]      0.000     0.000     0.000     0.000
         OUTFLOW_MAG[1]      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000
         OUTFLOW_MAG[2]      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000
         OUTFLOW_MAG[3]      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000
         OUTFLOW_MAG[4]      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000
         OUTFLOW_DRAG[1]      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000
         OUTFLOW_DRAG[2]      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000
         OUTFLOW_DRAG[3]      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000
         OUTFLOW_DRAG[4]      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000
         OUTFLOW_FIXP[1]      0.000     0.000     0.000     0.000
         OUTFLOW_FIXP[2]      0.000     0.000     0.000     0.000
         OUTFLOW_PRTP[1]      0.000     0.000     0.000     0.000     0.000     0.000
         OUTFLOW_PRTP[2]      0.000     0.000     0.000     0.000     0.000     0.000
         OUTFLOW_ENV[1]   1000.000   100.000  1000.000   0     0.000     0.000
         OUTFLOW_ENV[2]   1000.000   100.000  1000.000   0     0.000     0.000
         OUTFLOW_GP        0   0   0   0
         OUTFLOW_MATC[1]      0.000     0.000
         OUTFLOW_MATC[2]      0.000     0.000
         OUTFLOW_EBPARA[1]      0.700     0.100     9.000     0.999     0.100     1.000     0.000     0.000     1.000     1.000     0.000     3.000     3.000     0.000     0.000     0.000
         OUTFLOW_EBPARA[2]      0.700     0.100     9.000     0.999     0.100     1.000     0.000     0.000     1.000     1.000     0.000     3.000     3.000     0.000     0.000     0.000
OUTFLOW_HSPARA[1]       0      0      0      0      0      0      0      0
OUTFLOW_HSPARA[2]       0      0      0      0      0      0      0      0
         OUTFLOW_CLOGG[1]      0.000
         OUTFLOW_CLOGG[2]      0.000
         OUTFLOW_CLOGG[3]      0.000
         OUTFLOW_CLOGG[4]      0.000
CL_APPLI        2   2   2   0   0   0   0   0
CL_CND[1]     0.000 0.300   1 PG90
CL_CND[2]     0.000 0.300   2 PG90
CL_CND[3]     0.000 0.300   3 PG90
CL_CND[4]     0.000 0.300   4 PG90
CL_CND[5]     0.000 0.300   5 PG90
CL_CND[6]     0.000 0.300   6 PG90
CL_CND[7]     0.000 0.300   7 PG90
CL_CND[8]     0.000 0.300   8 PG90
CL_CND[9]     0.000 0.300   1 PG90
BEADCC             0.0      0.0      0.0      0.0      0.0      0.0      0.0      0.0      0.0      0.0
CL_CND_GCLO     0.00   0.00   0.00   0.00   0.00   0.00   0.00   0.00   0.00
CL_CND_GDT      0.00   0.00   0.00   0.00   0.00   0.00   0.00   0.00   0.00
CL_CND_T3     0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00
BEADPAR       0.0 100.0 100.0 100.0 100.0 100.0 100.0 100.0 100.0 100.0
OUTSPFLG      0 0 0 0 0 0 0 0 0 0
CL_SPW[1]       1    22     0     0     0     0     0     0
CL_SPW[2]       1    22     0     0     0     0     0     0
CL_SPW[3]       1    22     0     0     0     0     0     0
CL_SPW[4]       1    22     0     0     0     0     0     0
CL_SPW[5]       1    22     0     0     0     0     0     0
CL_SPW[6]       1    22     0     0     0     0     0     0
CL_SPW[7]       1    22     0     0     0     0     0     0
CL_SPW[8]       1    22     0     0     0     0     0     0
SPW_CTRL[1]      23  0.000    17     4   0  1029   3     0     0
SPW_CTRL[2]      23  0.000    17     4   0  1029   3     0     0
SPW_CTRL[3]      23  0.000    17     4   0  1029   3     0     0
SPW_CTRL[4]      23  0.000    17     4   0  1029   3     0     0
SPW_CTRL[5]      23  0.000    17     4   0  1029   3     0     0
SPW_CTRL[6]      23  0.000    17     4   0  1029   3     0     0
SPW_CTRL[7]      23  0.000    17     4   0  1029   3     0     0
SPW_CTRL[8]      23  0.000    17     4   0  1029   3     0     0
SPW_GUN[1]      1   0  0.500  1.000   0   0  0.500  0.200
SPW_GUN[2]      1   0  0.500  1.000   0   0  0.500  0.200
SPW_GUN[3]      1   0  0.500  1.000   0   0  0.500  0.200
SPW_GUN[4]      1   0  0.500  1.000   0   0  0.500  0.200
SPW_GUN[5]      1   0  0.500  1.000   0   0  0.500  0.200
SPW_GUN[6]      1   0  0.500  1.000   0   0  0.500  0.200
SPW_GUN[7]      1   0  0.500  1.000   0   0  0.500  0.200
SPW_GUN[8]      1   0  0.500  1.000   0   0  0.500  0.200
CL_HDL[1]         9    10
CL_HDL[2]        11    12
CL_HDL[3]        13    14
CL_HDL[4]        24     0
CL_HDL[5]        24     0
CL_HDL[6]        24     0
CL_HDL[7]        24     0
CL_HDL[8]        24     0
CL_GUN[1]         9
CL_GUN[2]        10
CL_GUN[3]         0
CL_GUN[4]         0
OX_SPEC_1      0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
OX_SPEC_2      0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
OX_SPEC_3      0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
OX_SPEC_4      0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
OX_SPEC_5      0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
OX_SPEC_6      0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
OX_SPEC_7      0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
OX_SPEC_8      0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
INSPECTION     0 -1 -1 -1 -1
DCOLT            180    150    150    130      0      0      0      0      0      0      0      0      0      0      0      0      0      0
DCOLTSW       255
DCOLTJ            20     20     20     20      0      0      0      0      0      0      0      0      0      0      0      0      0      0
DCOLTJSW      255
DCOLR            300    280    350    140      0      0      0      0      0      0      0      0      0      0      0      0      0      0
DCOLRSW       255
DCOLRJ            30     30     30     20      0      0      0      0      0      0      0      0      0      0      0      0      0      0
DCOLRJSW      255
LOAD1           130.000     0.000     0.000     0.000     0.000     0.000     0.000
LOAD2           130.000     0.000     0.000     0.000     0.000     0.000     0.000
LOAD3           130.000     0.000     0.000     0.000     0.000     0.000     0.000
LOAD4           130.000     0.000     0.000     0.000     0.000     0.000     0.000
LOAD5           130.000     0.000     0.000     0.000     0.000     0.000     0.000
LOAD6           130.000     0.000     0.000     0.000     0.000     0.000     0.000
LOAD7           130.000     0.000     0.000     0.000     0.000     0.000     0.000
LOAD8           130.000     0.000     0.000     0.000     0.000     0.000     0.000
LOAD9           130.000     0.000     0.000     0.000     0.000     0.000     0.000
AUX_START_DELAY_COM          0
AUX_START_DELAY_SEPA01      0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
AUX_START_DELAY_SEPA02      0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
AUX_START_DELAY_SEPA03      0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
AUX_START_DELAY_SEPA04      0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
AUX_START_DELAY_SEPA05      0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
AUX_START_DELAY_SEPA06      0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
AUX_START_DELAY_SEPA07      0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
AUX_START_DELAY_SEPA08      0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
AUX_START_DELAY_SEPA09      0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
AUX_START_DELAY_SEPA10      0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
AUX_START_DELAY_SEPA11      0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
AUX_START_DELAY_SEPA12      0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
AUX_START_DELAY_SEPA13      0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
AUX_START_DELAY_SEPA14      0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
AUX_START_DELAY_SEPA15      0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
AUX_START_DELAY_SEPA16      0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
AUX_START_DELAY_SEPA17      0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
AUX_START_DELAY_SEPA18      0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
AUX_START_DELAY_SEPA19      0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
AUX_START_DELAY_SEPA20      0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
ARM_LOAD          0.000     0.000
BASE_LOAD         0.000     0.000     0.000     0.000     0.000
SINGULAR1         5.000
RIO_PLC        0  0  0  0  1  0  0
RIO_WELD       0  0  0
LAN_HOST_IPAD   192.168.0.1
LAN_HOST_USER   
LAN_HOST_PSW   
LAN_HOST_PATH   ,,
LAN_HOST_ACNT   
LAN_HOST_ASCBIN    0
LAN_HOST_EUSJ    0
LAN_HOST_FNP    1
LAN_HOST_OS    0,75,0,WIN32,120  1,75,1,UNIX,120  2,75,0,Windows_NT,120  3,75,0,,120  4,75,0,,120  5,75,0,,120  6,75,0,,120  7,75,0,,120  8,75,0,,120  9,75,0,,120
AUX_PASSWD      2
AUX_CHOOSE1   2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
AUX_CHOOSE2   2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
AUX_CHOOSE3   2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
AUX_CHOOSE4   2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
AUX_CHOOSE5   2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
AUX_CHOOSE6   2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
AUX_CHOOSE7   2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
AUX_CHOOSE8   1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1 1
AUX_CHOOSE11  2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
AUX_CHOOSE12  2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
AUX_CHOOSE15  2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
AUX_CHOOSE18  2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
CYC_ST_COND       0
RST_OSIG_NO       0     0     0     0     0
ENC_ALARM              0          0          0          0          0          0
AUX_FNC_OPLVL1    2   2   2
AUX_FNC_OPLVL2    2
AUX_FNC_OPLVL3    2   2
AUX_FNC_OPLVL4    2   2   2   2   2   2
SLOW_REPEAT_TIM          0
ROB_START_POS_LIM      0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000     0.000
SENSING_SPEED     10.000     0.000 255
SENS_STROKE       0.000
DCOLRTH1          0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
DCOLRTH2          0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
DCOLRTH3          0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
DCOLRTH4          0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
DCOLRTH5          0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
DCOLRTH6          0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
DCOLRTH7          0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
DCOLRTH8          0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
DCOLRTH9          0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
DCOLJTH1          0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
DCOLJTH2          0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
DCOLJTH3          0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
DCOLJTH4          0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
DCOLJTH5          0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
DCOLJTH6          0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
DCOLJTH7          0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
DCOLJTH8          0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
DCOLJTH9          0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0
DCOLHJID1         0
DCOLHJID2         0
DCOLHJID3         0
DCOLHJID4         0
DCOLHJID5         0
DCOLHJID6         0
DCOLHJID7         0
DCOLHJID8         0
DCOLHJID9         0
INTPGNAME1         0
INTPGNAME2         0
INTPGNAME3         0
HOME_CHK              1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1         1
KVPLOW_AXIS   0          -1
CAMIMG_CYC         2000
CAMIMG_ID      1 "1L"  2 "1R"
CAMIMG_IP    192.168.0.10
ZCAMIMG_PORT       8120
.END
.INTER_PANEL_D
4,2,"mantr1f","","","",10,4,2,2001,0
5,2,"mantr2f","","","",10,4,2,2003,0
6,2,"mantr3f","","","",10,4,2,2005,0
11,2,"mantr1b","","","",10,4,2,2002,0
12,2,"mantr2b","","","",10,4,2,2004,0
13,2,"mantr3b","","","",10,4,2,2006,0
21,4,1,"trmanual","","","",10,4,2,2019,0,0
25,2,"moveReq 1","","","",10,4,2,2081,0
26,2,"moveReq 2","","","",10,4,2,2082,0
27,2,"moveReq 3","","","",10,4,2,2083,0
28,8,"pos","pos","",10,0,5,1,0
29,4,1,"Manual SCH","","","",10,4,2,2040,0,0
30,4,1,"SCHK MOVE?","","","",10,4,2,2022,0,0
31,8,"sch_move"," SCHK DIST","",10,0,5,1,0
33,8,"response1","RESPONSE 1","",10,0,5,1,0
34,8,"response2","RESPONSE 2","",10,0,5,1,0
36,2,"  RESET","  SHUNK","  ERROR","",10,6,0,2043,0
37,2,"   OPEN","  SHUNK"," FINGERS","",10,6,0,2041,0
38,2,"  CLOSE","  SHUNK"," FINGERS","",10,6,0,2042,0
44,8,"move_pass","MoveToSafe","Password",10,0,5,1,0
45,4,1,"  Allow","  ROBOT","   MOVE","  TO SAFE",10,4,2,2045,0,0
56,8,"pType","pType","",10,0,2,1,0
58,4,1,"packWaits","","","",10,4,2,2068,0,0
59,4,1,"Test in pr","","","",10,4,2,2074,0,0
60,4,1,"pot on crs","","","",10,4,2,2077,0,0
62,4,1,"pauseCycle","","","",10,4,2,2080,0,0
65,4,1,"TestOK","","","",10,4,2,2075,0,0
72,4,1,"TestNOK","","","",10,4,2,2076,0,0
74,4,1,"doNext","","","",10,4,2,2090,0,0
76,4,1,"enterReq","","","",10,4,2,2079,0,0
84,4,1,"posTOP","","","",10,4,2,58,0,0
85,4,1,"pos1","","","",10,4,2,59,0,0
86,4,1,"pos2","","","",10,4,2,60,0,0
87,4,1,"pos3","","","",10,4,2,61,0,0
88,4,1,"pos4","","","",10,4,2,62,0,0
89,4,1,"pos5","","","",10,4,2,63,0,0
92,4,1,"ref1","","","",10,4,2,52,0,0
93,4,1,"ref2","","","",10,4,2,53,0,0
94,4,1,"ref3","","","",10,4,2,54,0,0
95,4,1,"ref4","","","",10,4,2,55,0,0
96,4,1,"ref5","","","",10,4,2,56,0,0
98,4,1,"hat","","","",10,4,2,65,66,0
101,4,1,"move","","","",10,4,2,57,0,0
104,4,1,"calibrate","","","",10,4,2,64,0,0
.END
.INTER_PANEL_COLOR_D
182,3,224,244,28,159,252,255,251,255,0,31,2,241,52,219,
.END
.SIG_COMMENT
.END
.PROGRAM allowentrance()
;sprawdzanie i zezwalanie na pauze oraz wejscie operatora do strefy zaladunku 
;IF SIG(PauseCycle)  THEN
;	SIGNAL PauseConf
;	WAIT SIG(-PauseCycle)
;	SIGNAL -PauseConf
;END
;IF SIG(EnterReq) OR SIG(PauseCycle) THEN	;jesli ktos chce wejsc w strefe to
IF SIG(enterreq) THEN ;jesli ktos chce wejsc w strefe to
WAIT SIG(-movingback[1],-movingback[2],-movingforward[3]) ;czekam az transportery stana
SIGNAL stoptransporter[1]
SIGNAL stoptransporter[2] ; zatrzymuje transportery
SIGNAL enterconf ;zezwolenie na wejscie
;SIGNAL PauseConf ;zezwolenie na pauze 
;tutaj powinienem byc wylaczony 
;WAIT SIG(-EnterReq,-PauseCycle)		;operator wyszedl ze sterfy, zazbroil kurtyny - sygnal gasnie
WAIT SIG(-enterreq)  ;operator wyszedl ze sterfy, zazbroil kurtyny - sygnal gasnie
SIGNAL -enterconf     ;sciagam sygnal zezwolenia
;SIGNAL -PauseConf
SIGNAL -stoptransporter[1]
SIGNAL -stoptransporter[2] ;wlaczam na nowo transportery 
END
;jeszcze raz sprawdze czy nikt nie wywolal pauzy podczas gdy operator byl w strefie 
;IF SIG(PauseCycle)  THEN
;	SIGNAL PauseConf
;	WAIT SIG(-PauseCycle)
;	SIGNAL -PauseConf
;END
RETURN
.END
.PROGRAM anull()
LMOVE NULL
.END
.PROGRAM ateq()
;oblsuga ateq - wystawia sygnal a cala obsluga jest w signals - dzieje sie rownolegle 
;robot w tym czasie moze przygotowac stanowisko 
SIGNAL makingtestateq ;w signals odpala sie watek oblsugujacy ateq - zjazd i docisk kapelusza
SIGNAL fpositionnextat ;jestem przed ateq, jesli bede chcial jechac po chwytak to musze wykonac 
;najpierw 'move2safe' 
CALL conveyors;w trakcie testu moge ustawiac stanowisko na tr3 
IF SIG(-fpositionnextat) THEN
;jesli w conveyors gdzies pojechalem to musze z powrotem wrocic przed ateq 
CALL move2ateq
END
CALL allowentrance
WHILE SIG(makingtestateq) DO ;czekam az zakonczy sie test zgasnie w signals po skonczeniu testu 
BREAK
TWAIT 0.5
CALL allowentrance;najlepszy moment zeby ktos wszedl - i tak czekam na test ateq 
$actualdates = $DATE(1)
IF $prevdates<>$actualdates THEN ;jesli mamy nowy dzien to przejedz shunkiem max-min zeby go nasmarowac
CALL lubricateshunk
$prevdates = $actualdates
END
END
SIGNAL -fpositionnextat
RETURN
.END
.PROGRAM ateqtest()
CALL setreference;odkomentowac jak bedzie obsluga z kodowaniem pakietow 
SIGNAL ateqpos[type+1] ; +1 bo pierwsza pozycja to TOP
TWAIT 0.2
SIGNAL hatdown
SIGNAL -hatup
;WAIT SIG(HatIsDown,-HatIsUp)	;dociskam kapeluszem
SIGNAL changepos
TWAIT 2
WAIT SIG(ateqinpos) ;	ustawiam pozycje i czekam az ateq zjedzie 
SIGNAL -changepos
TWAIT 0.2
SIGNAL -heatextaken
SIGNAL heatexputtedina   ;daje sygnal leszkowi ze mozna zaczac test 
TWAIT 1
WAIT SIG(-testinprogres)   ;czekam az zakonczy sie test w ateq 
TWAIT 1
SIGNAL -ateqpos[type+1]     ;sciagam sygnal obecnej pozycji
SIGNAL ateqpos[1] ; odjazd max do gory
TWAIT 0.2
SIGNAL changepos
TWAIT 2
SIGNAL hatup
SIGNAL -hatdown
TWAIT 2
WAIT SIG(hatisup,-hatisdown) ;podnosze kapelusz
WAIT SIG(ateqinpos) ;czekam az podjedzie do gory
SIGNAL -ateqpos[1]
SIGNAL -changepos
TWAIT 0.2
;resetuje sygnaly referencji
SIGNAL -ref[1]
SIGNAL -ref[2]
SIGNAL -ref[3]
SIGNAL -ref[4]
SIGNAL -ref[5]
SIGNAL -makingtestateq
readytotest = TRUE
.END
.PROGRAM autostart.pc()
PCEXECUTE 4: signals,-1
.END
.PROGRAM baza()
;"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
bazatop:
CP ON
SPEED slow ALWAYS
ACCEL acc ALWAYS
DECEL acc ALWAYS
ACCURACY acu ALWAYS
BASE global
TOOL laser
JMOVE #search
POINT searchstart = sy2
POINT searchend = SHIFT(sy2 BY 2000)
CALL lasersearch
POINT y2 = searchpoint
POINT searchstart = sy1
POINT searchend = SHIFT(sy1 BY 2000)
CALL lasersearch
POINT y1 = searchpoint
angle = ATAN2(DX(y2)-DX(y1),DY(y2)-DY(y1))
PRINT "Angle: ",angle
IF ABS(angle)>angletolerance THEN
PRINT "Kat poza tolerancja"
GOTO bazatop
ELSE
PRINT "Kat OK"
END
POINT baza = y1
POINT/OAT baza = NULL
POINT baza = global+baza
POINT baza = baza-RZ(angle)
BASE baza
LMOVE NULL+RZ(-90)
BREAK
POINT searchstart = TRANS(150,-170)+RZ(-90)
POINT searchend = TRANS(150,0)+RZ(-90)
CALL lasersearch
POINT baza = baza+TRANS(0,DY(searchpoint))
BASE baza
LMOVE NULL+RZ(-90)
POINT/Z baza = TRANS(0,0,600)
TOOL schunk
POINT baza = global+baza
POINT pal = baza
BASE global
JMOVE #search
RETURN
.END
.PROGRAM bazamanual()
;"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
angle = ATAN2(DX(y2)-DX(y1),DY(y2)-DY(y1))
POINT baza = y1
POINT/OAT baza = NULL
POINT baza = global+baza
POINT baza = baza-RZ(angle)
.END
.PROGRAM bity()
FOR i = 0 TO 7
BITS 1+32+i*8,8 = out[i]
END
TWAIT 1
FOR i = 0 TO 7
in[i] = BITS(1001+32+i*8,8)
END
.END
.PROGRAM calbiggr()
BASE NULL
POINT tempbiggrip1 = big_gripper+TRANS(517.85,288.21)
POINT tempbiggrip2 = big_gripper+TRANS(-525.82,-335.13)
CALL calgetgrip
POINT temptool = big_gripper
SPEED slow MM/S ALWAYS
TOOL tempbiggrip1
PRINT "Ustaw stojak do kalibracji"
JMOVE #calibbig
BREAK
PAUSE
;KALIBRACJA I-szego rogu
SPEED searchspeed MM/S ALWAYS
ACCURACY supacu ALWAYS
POINT/OAT calibbig0 = RY(180)+RZ(180)
LMOVE calibbig0
BREAK
PRINT "Wyrownaj pozycje nad stozek i przejdz dalej"
PAUSE
POINT calibbig0 = HERE
BREAK
POINT p1 = calibbig0+RZ(90)
POINT p2 = calibbig0-RZ(90)
LMOVE p1
BREAK
PRINT "Wyrownaj pozycje nad stozek i przejdz dalej"
PAUSE
POINT t1 = HERE
LMOVE calibbig0
LMOVE p2
BREAK
PRINT "Wyrownaj pozycje nad stozek i przejdz dalej"
PAUSE
POINT t2 = HERE
tx = (DX(t1)-DX(t2))/2
ty = (DY(t1)-DY(t2))/2
POINT tempbiggrip1 = tempbiggrip1+TRANS(ty,tx)
BREAK
TOOL tempbiggrip1
PRINT "tx:",tx
PRINT "ty:",ty
PRINT ""
LMOVE calibbig0
SPEED slow MM/S ALWAYS
JMOVE #calibbig
;KALIBRACJA II-go rogu
TOOL tempbiggrip2
SPEED searchspeed MM/S ALWAYS
ACCURACY supacu ALWAYS
POINT/OAT calibbig1 = RY(180)+RZ(90)
LMOVE calibbig1
BREAK
PRINT "Wyrownaj pozycje nad stozek i przejdz dalej"
PAUSE
POINT calibbig1 = HERE
BREAK
POINT p1 = calibbig1+RZ(90)
POINT p2 = calibbig1-RZ(90)
LMOVE p1
BREAK
PAUSE
PRINT "Wyrownaj pozycje nad stozek i przejdz dalej"
POINT t1 = HERE
LMOVE calibbig1
LMOVE p2
BREAK
PRINT "Wyrownaj pozycje nad stozek i przejdz dalej"
PAUSE
POINT t2 = HERE
tx = (DX(t1)-DX(t2))/2
ty = (DY(t1)-DY(t2))/2
POINT tempbiggrip2 = tempbiggrip2+TRANS(-tx,ty)
TOOL tempbiggrip2
PRINT "tx:",tx
PRINT "ty:",ty
PRINT ""
LMOVE calibbig1
SPEED slow MM/S ALWAYS
JMOVE #calib
PRINT "Tera zostanie wyliczony tool bedacy usrednieniem wlasnie wyliczonych"
PAUSE
POINT temptool = AVE_TRANS(tempbiggrip1,tempbiggrip2)
TOOL temptool
POINT temp = temptool+TRANS(3.983,23.463)
CALL putoutgripper
.END
.PROGRAM calgetgrip()
;jade po chwytak 
SPEED spd MM/S ALWAYS
JMOVE #safet
nogriperror = TRUE
WHILE nogriperror DO
TOOL big_gripper
JMOVE #over_gripper
LAPPRO get_grip,500
SPEED slow MM/S ALWAYS
SIGNAL closefingers
SIGNAL (-openfingers)     ;zamykanie chwytaka do podoszenia pakietow
WAIT SIG(leftfingerc,rightfingerc,-leftfingero,-rightfingero)
SIGNAL -leavepalette
SIGNAL grabpalette  ;przed wjazdem zamknij silownik od palet zeby nie udzezyc w chwytak 
WAIT SIG(-palettegrippero,palettegripperc)
LMOVE inside_grip
SIGNAL leavepalette      ;rozsuniecie chwytaka palet - chwytak pobierany jest w poz otwartej
SIGNAL -grabpalette
WAIT SIG(palettegrippero,-palettegripperc)
SIGNAL leavegripper      ; zeby podjazd po chwytak byl z zamknietym bolcem
SIGNAL -grabgripper
WAIT SIG(leftgripper,-havegripper)
SIGNAL -connectoron
LMOVE get_grip
TWAIT (0.5)
BREAK
SIGNAL connectoron
SIGNAL -leavegripper
SIGNAL grabgripper
WAIT SIG(havegripper,-leftgripper)
TWAIT 0.2
IF SIG(-palettedetect) THEN ;nie mam chwytaka 
SIGNAL -connectoron
SIGNAL leavegripper
SIGNAL -grabgripper
WAIT SIG(-havegripper,leftgripper)
TWAIT 0.2
LMOVE inside_grip
SIGNAL -leavepalette
SIGNAL grabpalette
WAIT SIG(-palettegrippero,palettegripperc)
LAPPRO get_grip,500
LMOVE #over_gripper
;!! ERROR NIE MA CHWYTAKA !!
;wyslac sygnal do plc
SIGNAL errornogripper ;po tym wchodze do petli z ktorej juz nie wyjde
;i tak cale stanowisko musi byc zrestartowane bo ktos przetnie bariere
nogriperror = TRUE
ELSE
nogriperror = FALSE
END
END
LAPPRO get_grip,200
SPEED spd MM/S ALWAYS
LMOVE #over_gripper;odjazd nad pobranie chwytaka
;koniec procedury calgetgrip
.END
.PROGRAM calibbiggripper()
POINT tempbiggrip1 = big_gripper+TRANS(300,-400)
POINT tempbiggrip2 = big_gripper+TRANS(-300,400)
CALL getgripper
POINT temptool = big_gripper
SPEED slow MM/S ALWAYS
TOOL tempbiggrip1
PRINT "Ustaw stojak do kalibracji"
JMOVE #calib
BREAK
PAUSE
;KALIBRACJA I-szego rogu	
SPEED searchspeed MM/S ALWAYS
ACCURACY supacu ALWAYS
POINT/OAT calibbig0 = RY(180)
LMOVE calibbig0
BREAK
PRINT "Wyrownaj pozycje nad stozek i przejdz dalej"
PAUSE
POINT calibbig0 = HERE
BREAK
POINT p1 = calibbig0+RZ(90)
POINT p2 = calibbig0-RZ(90)
LMOVE p1
BREAK
PRINT "Wyrownaj pozycje nad stozek i przejdz dalej"
PAUSE
POINT t1 = HERE
LMOVE calibbig0
LMOVE p2
BREAK
PRINT "Wyrownaj pozycje nad stozek i przejdz dalej"
PAUSE
POINT t2 = HERE
tx = (DX(t1)-DX(t2))/2
ty = (DY(t1)-DY(t2))/2
POINT tempbiggrip1 = tempbiggrip1+TRANS(-ty,-tx)
TOOL tempbiggrip1
PRINT "tx:",tx
PRINT "ty:",ty
PRINT ""
LMOVE calibbig0
SPEED slow MM/S ALWAYS
JMOVE #calib
;KALIBRACJA II-szego rogu
TOOL tempbiggrip2
SPEED searchspeed MM/S ALWAYS
ACCURACY supacu ALWAYS
POINT/OAT calibbig0 = RY(180)
LMOVE calibbig0
BREAK
PRINT "Wyrownaj pozycje nad stozek i przejdz dalej"
PAUSE
POINT calibbig0 = HERE
BREAK
POINT p1 = calibbig0+RZ(90)
POINT p2 = calibbig0-RZ(90)
LMOVE p1
BREAK
PAUSE
PRINT "Wyrownaj pozycje nad stozek i przejdz dalej"
POINT t1 = HERE
LMOVE calibbig0
LMOVE p2
BREAK
PRINT "Wyrownaj pozycje nad stozek i przejdz dalej"
PAUSE
POINT t2 = HERE
tx = (DX(t1)-DX(t2))/2
ty = (DY(t1)-DY(t2))/2
POINT tempbiggrip2 = tempbiggrip2+TRANS(-ty,-tx)
TOOL tempbiggrip2
PRINT "tx:",tx
PRINT "ty:",ty
PRINT ""
LMOVE calibbig0
SPEED slow MM/S ALWAYS
JMOVE #calib
PRINT "Tera zostanie wyliczony tool bedacy usrednieniem wlasnie wyliczonych"
PAUSE
POINT temptool = AVE_TRANS(tempbiggrip1,tempbiggrip2)
TOOL temptool
CALL putoutgripper
.END
.PROGRAM calibsmallgripp()
POINT temptool = small_gripper
POINT temp = RZ(10)
SPEED slow MM/S ALWAYS
BASE temp
TOOL temptool
PRINT "Ustaw stojak do kalibracji"
JMOVE #calib
BREAK
BITS 81+16,16 = 0
BITS 81+16+8,16 = 150
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
PRINT "wloz w lapki przyrzd do kalibracji malego grippera i przejdz dalej"
PAUSE
SPEED searchspeed MM/S ALWAYS
ACCURACY supacu ALWAYS
POINT/OAT calib0 = RY(180)
LMOVE calib0
BREAK
PRINT "Wyrownaj stozki ze soba i przejdz dalej"
PAUSE
POINT calib0 = HERE
BREAK
POINT p1 = calib0+RZ(90)
POINT p2 = calib0-RZ(90)
LMOVE p1
BREAK
PAUSE
PRINT "Wyrownaj stozki ze soba i przejdz dalej"
POINT t1 = HERE
LMOVE calib0
LMOVE p2
BREAK
PAUSE
PRINT "Wyrownaj stozki ze soba i przejdz dalej"
POINT t2 = HERE
tx = (DX(t1)-DX(t2))/2
ty = (DY(t1)-DY(t2))/2
POINT temptool = temptool+TRANS(-ty,-tx)
TOOL temptool
PRINT "tx:",tx
PRINT "ty:",ty
PRINT ""
LMOVE calib0
SPEED slow MM/S ALWAYS
JMOVE #calib
BITS 81+16,16 = 0
BITS 81+16+8,16 = 153
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
PRINT "wyjmin przyrzd do kalibracji i przejdz dalej"
.END
.PROGRAM calsmagr()
POINT temptool = small_gripper
;POINT temp = RZ(10)
SPEED slow MM/S ALWAYS
;BASE temp
BASE NULL
TOOL temptool
PRINT "Ustaw stojak do kalibracji"
JMOVE #calib
JMOVE #calib2
BREAK
;otworzenie szczek do wlozenia przyrzadu do kalibracji malego grippera
BITS 81+16,16 = 0
BITS 81+16+8,16 = 20
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
PRINT "wloz w lapki przyrzad do kalibracji malego grippera i przejdz dalej"
PAUSE
;zacisniecie szczek na przyrzadzie do kalibracji malego grippera
BITS 81+16+8,16 = 0
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
SPEED searchspeed MM/S ALWAYS
ACCURACY supacu ALWAYS
;wyrownanie obrotu aby miec kat prosty
POINT/OAT calib0 = RY(180)+RZ(90)
;wyzerowanie wspolrzednej Y
BREAK
LMOVE calib0
BREAK
PRINT "Wyrownaj stozki ze soba i przejdz dalej"
PAUSE
POINT calib0 = HERE
PRINT "Punkt calib0 zaktualizowany"
BREAK
POINT p1 = calib0+RZ(90)
POINT p2 = calib0-RZ(90)
LMOVE p1
BREAK
PRINT "Wyrownaj stozki ze soba i przejdz dalej"
PAUSE
POINT t1 = HERE
PRINT "Punkt t1 zaktualizowany"
LMOVE calib0
LMOVE p2
BREAK
PRINT "Wyrownaj stozki ze soba i przejdz dalej"
PAUSE
POINT t2 = HERE
PRINT "Punkt t2 zaktualizowany"
tx = (DX(t1)-DX(t2))/2
ty = (DY(t1)-DY(t2))/2
POINT temptool = temptool+TRANS(-tx,ty)
TOOL temptool
PRINT "tx:",tx
PRINT "ty:",ty
PRINT ""
LMOVE calib0
SPEED slow MM/S ALWAYS
JMOVE #calib2
BITS 81+16,16 = 0
BITS 81+16+8,16 = 20
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
PRINT "wyjmij przyrzad do kalibracji i przejdz dalej"
PAUSE
JMOVE #calib
PRINT "Punkt TEMP zostanie obliczony(przesuniety)"
PRINT "w oparciu o wyniki nowej kalibracji"
POINT temp = temptool+TRANS(5.45,0.26)
PRINT "teraz mozna narzedziem TEMP"
PRINT "nadpisac narzedzie SMALL_GRIPPER"
.END
.PROGRAM cartsel()
PRINT "Czekam na wozek..."
waitcart:
IF SIG(-onpositionl) OR SIG(newl) THEN
SIGNAL -emptyl
END
IF SIG(-onpositionr) OR SIG(newr) THEN
SIGNAL -emptyr
END
IF SIG(-onpositionl,-onpositionr) GOTO waitcart
IF SIG(emptyl,emptyr) GOTO waitcart
PRINT "Znaleziono wozek"
;----------------------------- P R A W Y ---------------------------------------------
IF cartno==2 THEN
IF SIG(onpositionr,-emptyr) THEN
SIGNAL -unlockr
IF SIG(newr) THEN
layer = layers-1
weight = 0
END
SIGNAL notnewr
WAIT SIG(-newr)
SIGNAL -notnewr
POINT cart = cartr
PRINT "Wybrano prawy wozek"
cartswitched = FALSE
ELSE ;prawy ale nie ma go
cartno = 1
cartswitched = TRUE
PRINT "Zmieniono wozek na lewy"
END
END
;----------------------------- L E W Y ---------------------------------------------
IF cartno==1 THEN
IF SIG(onpositionl,-emptyl) THEN
SIGNAL -unlockl
IF SIG(newl) THEN
layer = layers-1
weight = 0
END
SIGNAL notnewl
WAIT SIG(-newl)
SIGNAL -notnewl
POINT cart = cartl
PRINT "Wybrano lewy wozek"
cartswitched = FALSE
ELSE ;Lewy ale nie ma go
cartno = 2
cartswitched = TRUE
PRINT "Zmieniono wozek na prawy"
END
END
IF cartswitched==TRUE GOTO waitcart
RETURN
.END
.PROGRAM checkateqcor()
;program sprawdzajacy czy korekty pozycji do ATEQ'a nie sa zbyt duze
;zeby nie przywalic robotem i rozwalic czegos w ateq'u
IF ABS(ateqcorx[1])>10 THEN
PRINT "ateqcorx[1] wieksza niz 10, zmniejsz korekte"
PAUSE
END
IF ABS(ateqcorx[2])>10 THEN
PRINT "ateqcorx[2] wieksza niz 10, zmniejsz korekte"
PAUSE
END
IF ABS(ateqcorx[3])>10 THEN
PRINT "ateqcorx[3] wieksza niz 10, zmniejsz korekte"
PAUSE
END
IF ABS(ateqcorx[4])>10 THEN
PRINT "ateqcorx[4] wieksza niz 10, zmniejsz korekte"
PAUSE
END
IF ABS(ateqcorx[5])>3 THEN
PRINT "ateqcorx[5] wieksza niz 3, zmniejsz korekte"
PAUSE
END
IF ABS(ateqcory[1])>10 THEN
PRINT "ateqcory[1] wieksza niz 10, zmniejsz korekte"
PAUSE
END
IF ABS(ateqcory[2])>10 THEN
PRINT "ateqcory[2] wieksza niz 10, zmniejsz korekte"
PAUSE
END
IF ABS(ateqcory[3])>10 THEN
PRINT "ateqcory[3] wieksza niz 10, zmniejsz korekte"
PAUSE
END
IF ABS(ateqcory[4])>10 THEN
PRINT "ateqcory[4] wieksza niz 10, zmniejsz korekte"
PAUSE
END
IF ABS(ateqcory[5])>3 THEN
PRINT "ateqcory[5] wieksza niz 3, zmniejsz korekte"
PAUSE
END
RETURN
.END
.PROGRAM checkgripper()
TOOL big_gripper
JMOVE #over_gripper
;JAPPRO get_grip, 1000
LAPPRO get_grip,200
SPEED slow MM/S ALWAYS
SIGNAL (-openfingers)     ;zamykanie chwytaka do podoszenia pakietow
SIGNAL closefingers
WAIT SIG(leftfingerc,rightfingerc,-leftfingero,-rightfingero)
SIGNAL -leavepalette
SIGNAL grabpalette
WAIT SIG(-palettegrippero,palettegripperc)
LMOVE inside_grip
SIGNAL leavepalette      ;rozsuniecie chwytaka palet - chwytak pobierany jest w poz otwartej
SIGNAL -grabpalette
WAIT SIG(palettegrippero,-palettegripperc)
SIGNAL leavegripper      ; zeby podjazd po chwytak byl z zamknietym bolcem
SIGNAL -grabgripper
WAIT SIG(leftgripper,-havegripper)
SIGNAL -connectoron
LMOVE get_grip
TWAIT (0.5)
SIGNAL connectoron
SIGNAL -leavegripper
SIGNAL grabgripper
WAIT SIG(havegripper,-leftgripper)
TWAIT 0.5
nogriperr = FALSE
IF SIG(-palettedetect) THEN ;teraz sprawdzam czy jest chwytak czy nie 
nogriperr = TRUE
END
SIGNAL -connectoron
SIGNAL leavegripper
SIGNAL -grabgripper
WAIT SIG(-havegripper,leftgripper)
TWAIT 0.5
LMOVE inside_grip
SIGNAL -leavepalette
SIGNAL grabpalette
WAIT SIG(-palettegrippero,palettegripperc)
LAPPRO get_grip,200
SPEED spd MM/S ALWAYS
LMOVE #over_gripper
gotosafe = FALSE ;nie idz do #safe bo zaraz bedziesz kladl palete i pojedziesz po chwytak 
IF nogriperr THEN
JMOVE #safet
;wystaw sygnal do PLC ze nie ma chwytaka 
SIGNAL errornogripper
;ERROR - brak chwytaka
END
IF SIG(palettedetect) THEN
;jesli pomimo tego, ze odjechalem, a czujnik od wykrywania palet nadal pokazuje 1 tzn ze cos jest popsute
;na laczach - przecierz nie mam komunikacji teraz z nim 
SIGNAL errorpalettesen
END
.END
.PROGRAM checkpaletts()
;sprawdza ile jest palet przy robocie 
LAPPRO pick_palette,paletteheight*maxnrofpaletts+200
;sprawdzenie czy mamy sygnal wykrycia palety, jesli tak to blad
IF SIG(palettedetect) THEN
SIGNAL errorpalettesen
PAUSE
END
BREAK
ACCURACY 1
SPEED srchspd MM/S
PCABORT 2: 
PCEXECUTE 2: srch
ONI palettedetect GOTO skip
LMOVE pick_palette
BREAK
skip:
IGNORE palettedetect
POINT picks = rise
IF found==FALSE THEN
;ERROR NIE MA JEDNAK PALET 
LAPPRO pick_palette,paletteheight*maxnrofpaletts+200
BREAK
PCABORT 2: 
SIGNAL trready[1]
nrofpaletts = 0
palettenotfound = TRUE
;wystawic ERROR  ze nie ma palet
SIGNAL qtynok[1]
SIGNAL -qtyok[1]
SIGNAL errortr[1]
;WAIT SIG(SensorBack[1])
ELSE
;cos znalazlem 
PCABORT 2: 
heightp = DZ(picks)
;obliczanie ilosc palet, 30 mm to bufor poniewaz paleta mierzy ciut mniej niz 160 mm
nrofpaletts = (heightp-DZ(pick_palette)+30)/paletteheight
nrofpaletts = INT(nrofpaletts)+1
palettenotfound = FALSE
SIGNAL -errortr[1]
;tylko jedna paleta 
IF nrofpaletts<2 THEN
SIGNAL qtynok[1]
SIGNAL -qtyok[1]
END
;wystarczajaco palet 
IF nrofpaletts>1 THEN
SIGNAL -qtynok[1]
SIGNAL qtyok[1]
SIGNAL -needpaletts
END
;za duzo palet 
IF nrofpaletts>4 THEN
SIGNAL -qtyok[1]
SIGNAL qtynok[1]
SIGNAL errortr[1] ;wystawienie erroru i za chwile w 'putpalette' bedzie odjazd w gore
palettenotfound = TRUE
END
;PAUSE	;sprawdzic nrofpaletts - ile wg niego jest palet
;WAIT SIG(doNext)
;SIGNAL -doNext
SPEED slow MM/S ALWAYS
LAPPRO pick_palette,paletteheight*(nrofpaletts-1)
correctionoy = 0
CALL checkposition;jesli tu doszedl tzn ze moge sprawdzic polozenie palety/przekladki nic nie zaszkodzi
;ACCURACY acu ALWAYS
IF localizationok==FALSE THEN
palettenotfound = TRUE ;nie udalo mi sie zlokalizowac po OY palety 
SIGNAL -qtyok[1]
SIGNAL qtynok[1]
SIGNAL errortr[1] ;wystawienie erroru i za chwile w 'putpalette' bedzie odjazd w gore
SIGNAL needpaletts
END
END
.END
.PROGRAM checkposition()
;sprawdzam przesuniecie po OY - wiem jak ustawic chwytak 
;otwory w palecie i przekladce sa takie same wiec moge uzyc jednej funkcji 
BREAK
POINT pick = HERE ;punkt do podniesienia gdyby paleta/przekladka stala idealnie 
BREAK
IF DX(pick)<0 THEN
;sprawdzam palety - musze zejsc troche nizej
checkcorrection = -60
ELSE
;sprawdzam przekladki - 15 mm wyzej
checkcorrection = 15
END
LMOVE SHIFT(pick BY 0,0,checkcorrection);zjazd 6cm w dol jesli to palety zeby sensor byl na wysokosci otworow
BREAK
ACCURACY 1
SPEED srchspd MM/S
PCABORT 2: 
PCEXECUTE 2: srchoy
IF SIG(-palettedetect) THEN
ONI palettedetect GOTO skip1
LMOVE SHIFT(pick BY 0,-250,checkcorrection);trafilem w otwor bede jechal do robota
ELSE
ONI -palettedetect GOTO skip1
LMOVE SHIFT(pick BY 0,250,checkcorrection);trafilem w scianke bede jechal od robota
END
BREAK
skip1:
IGNORE palettedetect
PCABORT 2: 
;jesli jechalem oddalajac sie od robota to teraz wracam, zeby zawsze miec pozycje poczatku otworu 
;od strony otworu a nie od strony 'zabudowanej' 
IF SIG(-palettedetect) THEN
BREAK
ACCURACY 1
SPEED srchspd MM/S
PCABORT 2: 
PCEXECUTE 2: srchoy
ONI palettedetect GOTO skip2
LMOVE SHIFT(pick BY 0,-250,checkcorrection)
END
BREAK
skip2:
IGNORE palettedetect
PCABORT 2: 
;teraz z mala predkoscia (dokladnie) szukam poczatku otworu, zawsze od tej samej strony 
BREAK
ACCURACY 1
SPEED slowsrchspd MM/S
PCABORT 2: 
PCEXECUTE 2: srchoy
ONI -palettedetect GOTO skip3
LMOVE SHIFT(pick BY 0,250,checkcorrection);z mala predkoscia szukam poczatku otworu
BREAK
skip3:
IGNORE palettedetect
PCABORT 2: 
POINT picks = rise
localizationok = TRUE
;pause
;WAIT SIG(doNext)
;SIGNAL -doNext
IF found==FALSE THEN
;bezpieczny wyjazd do gory w obu przypadkach i moze jakis blad 
localizationok = FALSE ;flaga, ze nie udalo mi sie zlokalizowac palety/przekladki
ELSE
;znalazlem poczatek otworu w palecie/przekladce 
correctionoy = DY(picks)-DY(pick)
END
.END
.PROGRAM checkshunk()
PRINT "START: checkshunk()"
IF SIG(-heatexingripper) THEN ;kalibruj sie tylko wtedy, gdy nie trzymasz pakietu
;PAUSE
;response1 = BITS(1185,8)	;tak bylo przed dodaniem dodakowego modulu wago 
;response2 = BITS(1193,8)
response1 = BITS(1249,8)
response2 = BITS(1257,8)
;communication error - resetujemy 
BITS 81+16,16 = 0  ;zerowanie dalszych parametrow wysylanych shunkowi
BITS 81+16+16,16 = 0  ;zerowanie dalszych parametrow wysylanych shunkowi
shunkfail = TRUE
failcount = 0
WHILE shunkfail DO
PRINT "   WHILE(1) shunkfail"
IF response1==136 AND (response2==118 OR response2==116) THEN ;jesli jest error i 
;jest to "cable break" lub "motor voltage low"
PRINT "   jest error i jest to cable break lub motor voltage low"
BITS 81,8 = 1
BITS 89,8 = 139 ;zresetuj ten error
PRINT "   schunk reset"
TWAIT 0.5
END
BITS 81,8 = 1
BITS 89,8 = 146
TWAIT (0.5)
TIMER (1) = 0
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov) OR TIMER(1)>maxtimershunk ;czekam na odpowiedz shunka
IF SIG(-waitforshunkmov) THEN  ;shunk odpowiedzial porpawnie
shunkfail = FALSE
ELSE
PRINT "   ...dalej blad schunk"
failcount = failcount+1
IF failcount>1 THEN ;gdy to juz druga nieudana proba - wystaw blad
SIGNAL errorshunkfail
shunkfail = FALSE
END
END
END
;ustawienie wartosci pradu (maksymalnej sily)
BITS 81,8 = 5
BITS 89,8 = 163 ;ustawienie komendy jazdy z okreslona sila
BITS 81+16+8,16 = 0
BITS 81+16,16 = 10000 ;ustawienie wartosci pradu na 10 A
TWAIT 0.5
shunkfail = TRUE
failcount = 0
WHILE shunkfail DO
PRINT "   WHILE(2) shunkfail"
;PAUSE
BITS 81,8 = 5
BITS 89,8 = 176
BITS 81+16,16 = 0
BITS 81+16+8,16 = 530
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov) OR TIMER(1)>maxtimershunk ;czekam na odpowiedz shunka
IF SIG(-waitforshunkmov) THEN  ;shunk odpowiedzial porpawnie
shunkfail = FALSE
ELSE
failcount = failcount+1
IF failcount>=3 THEN
SIGNAL errorshunkfail
shunkfail = FALSE
END
END
PRINT "   END WHILE(2) shunkfail"
END
ELSE
PRINT " NIE KALIBRUJE SCHUNK-A BO OBECNY PAKIET: heatexingripper"
END
PRINT "END: checkshunk()"
RETURN
.END
.PROGRAM checkspacers()
;sprawdzam ile jest przekladek 
LAPPRO pick_spacer,spacerheight*maxnrofspacers+200
BREAK
ACCURACY 1
SPEED srchspd MM/S
PCABORT 2: 
PCEXECUTE 2: srch
ONI palettedetect GOTO skip
LAPPRO pick_spacer,(-paletteheight/2-50) ;zeby uwzglednic tez czy stoi tam paleta
BREAK
skip:
IGNORE palettedetect
POINT picks = rise
IF found==FALSE THEN
;ERROR NIE MA PRZEKLADEK ANI PALETY 
LAPPRO pick_spacer,spacerheight*maxnrofspacers+200
BREAK
SIGNAL trready[2]
nrofspacers = -1
PCABORT 2: 
;WYSTAWIC ERROR ZE NIE MA PRZEKLADEK 
spacernotfound = TRUE
SIGNAL -qtyok[2]
SIGNAL qtynok[2]
SIGNAL errortr[2]
;WAIT SIG(SensorBack[2])
ELSE
;cos znalazlem 
heights = DZ(picks)
nrofspacers = (heights-DZ(pick_spacer))/spacerheight
nrofspacers = INT(nrofspacers)+1
spacernotfound = FALSE
SIGNAL -errortr[2]
IF nrofspacers<1 THEN
;znalazlem tylko palete 
nrofspacers = 0
spacernotfound = TRUE
SIGNAL needspacers
END
;wystarczajaco palet 
IF nrofspacers>2 THEN
SIGNAL -qtynok[2]
SIGNAL qtyok[2]
SIGNAL -needspacers
END
IF nrofspacers>9 THEN
;wjechalo za duzo przekladek 
SIGNAL -qtyok[2]
SIGNAL qtynok[2]
;czy tutaj mam stanac ????
SIGNAL errortr[2]
spacernotfound = TRUE
SIGNAL needspacers
END
SPEED slow MM/S ALWAYS
LAPPRO pick_spacer,spacerheight*(nrofspacers-1)
correctionoy = 0
IF nrofspacers>0 THEN ;pozycje sprawdz tylko jesli znalazles przekladke
CALL checkposition
END
IF localizationok==FALSE THEN
spacernotfound = TRUE ;nie udalo mi sie zlokalizowac po OY - bedzie odjazd w gore i wysuniecie
SIGNAL -qtyok[2]
SIGNAL qtynok[2]
SIGNAL needspacers
END
END
.END
.PROGRAM checktypspacers()
IF (heatexcode<>prevcode) AND palettenotempty THEN ;jezeli pakiet, ktory przyjechal jest inny niz te na palecie i paleta nie jest pusta to sprawdz ilosc przekladek
IF nrofspacers<1 THEN
WHILE nrofspacers<1 DO
SIGNAL needspacers ;wystawienie sygnalu ze sie skonczyly przekladki
;wyjechanie paletka z pakietami na transporterze 3 gdy musi jej tam nie byc
SIGNAL trready[3]
WAIT SIG(sensorfront[3])
SIGNAL -trready[3]
WHILE SIG(-sensorback[2]) DO
CALL allowentrance
END
CALL getgripper
CALL checkspacers
;odjazd w gore aby sprawnie odlozyc gripper po sprawdzeniu ilosci przekladek
LAPPRO pick_spacer,spacerheight*maxnrofspacers+200
CALL putoutgripper
END
SIGNAL -needspacers
END
END
.END
.PROGRAM closeschunkfimg()
SIGNAL closefingers
SIGNAL -openfingers
TIMER (1) = 0
WAIT SIG(leftfingerc,rightfingerc,-leftfingero,-rightfingero) OR TIMER(1)>5
IF NOT SIG(leftfingerc,rightfingerc,-leftfingero,-rightfingero) THEN
PRINT "Przekroczona czas otwierania palcow na schunku."
PRINT "leftfingerc =",SIG(leftfingerc)
PRINT "rightfingerc =",SIG(rightfingerc)
PRINT "-leftfingero =",SIG(-leftfingero)
PRINT "-rightfingero =",SIG(-rightfingero)
HOLD.STEP ON
END
.END
.PROGRAM conveyors()
PRINT "START: conveyors()"
;sprawdzam stan transporterow i ustawiam odpowiednio stanowisko
IF SIG(sensorback[3]) THEN   ;calosc przy robocie na tr3
PRINT "IF SIG(sensorback[3])"
IF (heatexcode<>prevcode) AND palettenotempty THEN ;jezeli pakiet, ktory przyjechal jest inny niz te na palecie to wysun palete 
PRINT "IF (heatexcode<>prevcode) AND palettenotempty"
IF SIG(layerfull[1],-spacerputted[1]) THEN ;paleta ma wyjechac z pelna 1 warstwa ale nie ma przekladki
PRINT "IF (heatexcode<>prevcode) AND palettenotempty"
CALL putspacer
;IF nrOfspacers < 1 AND nrOfSpacers >=0 THEN	;znalazlem tylko palete lub zostala tylko paleta
;CALL relocatePalette
;END
JMOVE #safet
END
IF SIG(layerfull[2],-spacerputted[2]) THEN
CALL putspacer
JMOVE #safet
END
WHILE SIG(sensorfront[3]) DO  ;w rzeczywistosci nigdy nie powinno byc tej sytuacji
PRINT "18 WHILE SIG(sensorfront[3])"
;wystaw sygnal dla PLC zeby ktos odebral palete
SIGNAL getpalette
SIGNAL -getpalettteblin
CALL allowentrance
END ;nie ma nic do odbioru
SIGNAL -getpalette  ;skoro tu doszedl tzn ze nic nie stoi na tr3 z przodu
SIGNAL trready[3] ;calosc do odbioru - sygnal zeby wyjechal tr3
PRINT "28 WAIT SIG(sensorfront[3]"
WAIT SIG(sensorfront[3]) ;czekam az calosc dojedzie do konca
SIGNAL -trready[3]
WHILE SIG(sensorfront[3]) DO ;zezwalaj na wejscie i czekaj az ktos zabierze z tr3
PRINT "30 WHILE SIG(sensorfront[3])"
SIGNAL -getpaletteblink
TWAIT 0.2
SIGNAL getpalette
CALL allowentrance
END
SIGNAL -getpalette
CALL putpalette
ELSE
;sprawdzamy czy warstwa 2 jest pelna			
IF SIG(layerfull[2],-spacerputted[2]) THEN
;poloz przekladke i wypchnij palete
CALL moveoutfullpale
ELSE
;sprawdzamy czy warstwa 1 jest pelna
IF SIG(layerfull[1],-spacerputted[1]) THEN
;poloz przekladke i pracuj nad druga warstwa	
CALL putspacer
SIGNAL spacerputted[1]
CALL putoutgripper;odlozenie chwytaka
JMOVE #safet
END
END
END
ELSE ;nie ma nic na tr3 - poloz palete
CALL putpalette
END
PRINT "END: conveyors()"
RETURN
.END
.PROGRAM datainit()
;inicjalizacja zmiennych 
SPEED spd MM/S ALWAYS
SPEED deg ALWAYS
ACCURACY acu ALWAYS
;Outputs
;TR1
goforward[1] = 33
goback[1] = 34
qtyok[1] = 39
qtynok[1] = 40
;TR2
goforward[2] = 35
goback[2] = 36
qtyok[2] = 41
qtynok[2] = 42
;TR3
goforward[3] = 37
goback[3] = 38
getpalette = 43
;Gripper
closefingers = 44
openfingers = 45
grabpalette = 46
leavepalette = 47
grabgripper = 48
leavegripper = 49
connectoron = 67
;ATEQ
ref[1] = 52
ref[2] = 53
ref[3] = 54
ref[4] = 55
ref[5] = 56
changepos = 57
ateqpos[1] = 58
ateqpos[2] = 59
ateqpos[3] = 60
ateqpos[4] = 61
ateqpos[5] = 62
ateqpos[6] = 63
ateqcal = 64
hatup = 66  ;na odwrot niz w tabeli z exela - tam jest podana pozycja silownika 
hatdown = 65 ;w programie zeby bylo czytelniej traktujemy to jako pozycje kapelusza
heatextaken = 593  ;wzialem pakiet ze skrzyzowania
heatexputtedina = 594 ;wstawilem pakiet do ateq
heatexonpalette = 595 ;ustawilem pakiet na palecie - dobry pakiet	
heatexoncross = 596  ;odstawilem pakiet na skrzyzowanie - zly pakiet
heatexongalante = 4
initok = 597
enterconf = 598   ;potwierdzenie, ze operator moze teraz wejsc w strefe	
errornogripper = 599 ;nie znalazlem chwytaka do palet
errorateq = 600   ;w ateq stoi niewiadomy pakiet lub wstawilem pakiet a on zniknal(przy podnoszeniu nic nie ma)
errortr3full = 601  ;cos stoi na tr3 i nie wiem co to
errorstuck = 602  ;jestem w strefie z ktorej sam nie wyjade - potrzebny reczny odjazd
errorholdinghea = 603 ; trzymam niewiadomy pakiet
errorshunkfail = 604 ;shunk nie odpowiada
errortr[1] = 605 ;czujnik mowi ze cos stoi na tr1 ale nic tam nie znajduje lub wjechalo za duzo palet
errortr[2] = 606 ;czujnik mowi ze cos stoi na tr2 ale nic tam nie znajduje lub wjechalo za duzo przekladek 
errornoheatex = 607  ;dostalem sygnal ze przyjechal pakiet ale nic tam nie zjaduje 
endconf = 608   ;potwierdzenie ze zakonczylem procedure oprozniania lini  
errortrblocked[1] = 609 ;chce wysunac tr1, bo jest za duzo palet ale cos stoi na przedzie 
errortrblocked[2] = 610 ;chce wysunac tr2, bo jest za duzo przekladek ale cos stoi na przedzie 
errorheatexwron = 611 ;dostalem dziwny kod pakietu - nie moge go przypsisac do zadnego typu 
errorheatexsens = 612 ;gdy po odstawieniu pakietu to ateq czujnik nadal pokazuje 1 ->zepsol sie 
errorpalettesen = 613 ;gdy czujnik od wykrywania palet zawsze pokazuje 1 ->zepsol sie 
errorateqsensor = 614 ;gdy czujnik w ateq (obecnosc pakietu) nie zmienia swojego stanu pomimo
;wstawiania/zabierania pakietow 
needpaletts = 615 ;potrzebuje palet
needspacers = 616 ;potrzebuje przekladek 
;Inputs
palettegalanter = 1001
;TR1
enginesafety[1] = 1033
movingforward[1] = 1034
movingback[1] = 1035
sensorback[1] = 1042
sensorfront[1] = 1045
objectnotin[1] = 1048
;MoveRequest[1] = 1069	;ODKOMENTOWAC JAK BEDZIE PEDAL 
;TR2
enginesafety[2] = 1036
movingforward[2] = 1037
movingback[2] = 1038
sensorback[2] = 1043
sensorfront[2] = 1046
objectnotin[2] = 1049
;MoveRequest[2] = 1070	;ODKOMENTOWAC JAK BEDZIE PEDAL 
;TR3
enginesafety[3] = 1039
movingforward[3] = 1040
movingback[3] = 1041
sensorback[3] = 1044
sensorfront[3] = 1047
;MoveRequest[3] = 1071	;ODKOMENTOWAC JAK BEDZIE PEDAL
;Gripper
leftfingero = 1050
leftfingerc = 1051
rightfingero = 1052
rightfingerc = 1053
heatexingripper = 1054
palettegrippero = 1055
palettegripperc = 1056
havegripper = 1057
leftgripper = 1058
lasersensor = 1059
palettedetect = 1068
;ATEQ
ateqsafety = 1060
engineup = 1061
enginedown = 1062
ateqinpos = 1063
ateqcalok = 1064
hatisdown = 1065
hatisup = 1066
heatexinateq = 1067
;PLC
;======================zakomentowac ponizej jak juz bedzie komunikacja z PLC
;PackageWaits = 2068		;TEST bylo 2069
;PackageType = 2069    	;TEST bylo 2070
;TestInProgres = 2074	;TEST
;TestOK = 2075			;TEST
;TestNOK = 2076			;TEST
;PotOnCross = 2077		;TEST
;EndCycle = 2078 		;TEST oproznij stanowisko i zakoncz program
;EnterReq = 2079			;TEST
;PauseCycle = 2080		;TEST
;TO ZAKOMENTOWAC TEZ - obsluga pedalow 
moverequest[1] = 2081
moverequest[2] = 2082
moverequest[3] = 2083
;ErrorConf = 2084
;TrManual = 2019		;reczna obsluga transporterow
;ManTrForward[1] = 2001
;ManTrBack[1] = 2002
;ManTrForward[2] = 2003
;ManTrBack[2] = 2004
;ManTrForward[3] = 2005
;ManTrBack[3] = 2006
;zakomentowac powyzej =================
startcycle = 1369
packagetype = 1370
packagewaits = 1375
testinprogres = 1376
testok = 1377
testnok = 1378
potoncross = 1379
pausecycle = 1380
endcycle = 1381
resetcycle = 1382
enterreq = 1383
errorconf = 1384
;CurtainBreak = 1385		;nie uzywane - mozna usunac
trmanual = 1386
mantrforward[1] = 1387
mantrback[1] = 1388
mantrforward[2] = 1389
mantrback[2] = 1390
mantrforward[3] = 1391
mantrback[3] = 1392
gotogalanteria = 1393 ;rozkaz odlozenia wymiennika do galanterii
;Internal
trready[1] = 2007
trready[2] = 2008
trready[3] = 2009
moveobject[1] = 2012 ;- podtrzymanie sygnalu ObjectNotIn[1]
moveobject[2] = 2013 ;- podtrzymanie sygnalu ObjectNotIn[2]
moveobject[3] = 2014 ;- podtrzymanie ruchu transportera
fpositionnextat = 2015 ;flaga ustawiana gdy stoje przed ateq gaszona gdy jade zmieniac cos na tr3
;potrzebna zebym wiedzial czy musze wykonac 'move2safe' a pozniej ewentualnie powrot
;wolny slot 2016
layerfull[1] = 2017
layerfull[2] = 2018
spacerputted[1] = 2020
spacerputted[2] = 2021
waitforshunkmov = 2022
stoptransporter[1] = 2023 ;zatrzymuje transporter 1
stoptransporter[2] = 2024 ;zatrzymuje transporter 2
testokk = 2025    ;podtrzymanie sygnalu o tescie z ateq 
;PaletteWithoutSpacer = 2026
getpaletteblink = 2027  ;gdy paleta jest zapelniona w 80% to zacznij mrugac lampka
;zapalaj i gas 'getPalette'
moveout[1] = 2028  ;gdy chce wysunac tr1 bo wjechalo za duzo palet
moveout[2] = 2029  ;gdy chce wysunac tr2 bo wjechalo za duzo przekladek
moveobjectout[1] = 2030 ;podtrzymanie sygnalu wysuniecia palet
moveobjectout[2] = 2031 ;podtrzymanie sygnalu wysuniecia przekladek
makingtestateq = 2033
errorconfhold = 2034
donext = 2090
; do analizy zmian sygnalow ATQ
tok_m = 2100
tnok_m = 2101
tokk_m = 2102
ptc_m = 2103 ;potoncross
tip_m = 2104 ;testinprogres
;constans
minpacheight = 395 ;to zmienic i zebrac pozycje do chwytania/odlkadania pakietu z najnizszego pakietu
spacerthicknes = 20 ;grubosc przekladki - miedzy czubkiem pakietu na warstwie 1 a spodem pakietu na warstwie 2
spacerheight = 60 ;wysokosc 1 scianki gdy pobieram ja z palety - grubosc + wysokosc jednej scianki 		
paletteheight = 160 ;wysokosc palety 	
maxnrofspacers = 10  ;ile max przekladek moze byc na transporterze
maxnrofpaletts = 5  ;ile max palet moze byc na transporterze
width = 0     ;sluzy jako parametr jak szeroko rozstawic shunka
;jak bardzo rozsunac shunka zeby zlapac pakiet 
jawwidth[1] = 20
jawwidth[2] = 50
jawwidth[3] = 140
jawwidth[4] = 340
jawwidth[5] = 530
;wysokosci pakietow
pacheight[1] = 395
pacheight[2] = 396
pacheight[3] = 400
pacheight[4] = 406
pacheight[5] = 410
;odleglosci potrzebne w paletyzacji - dystans po OX miedzy srodkami pakietow
xdist[1] = 260   ;r80
xdist[2] = 262   ;r90
xdist[3] = 400   ;r100
xdist[4] = 425   ;r135
xdist[5] = 400    ;pakiet r140
;odleglosci potrzebne w paletyzacji - dystans po OY miedzy srodkami pakietow
ydist[1] = 230
ydist[2] = 230
ydist[3] = 280
ydist[4] = 283
ydist[5] = 390
;max ilosc kolumn na palecie 
maxcolcount[1] = 3
maxcolcount[2] = 3
maxcolcount[3] = 2
maxcolcount[4] = 2
maxcolcount[5] = 2
;max ilosc wierszy na palecie
maxrowcount[1] = 5
maxrowcount[2] = 5
maxrowcount[3] = 4
maxrowcount[4] = 4
maxrowcount[5] = 3
;przy wyjmowaniu z ateq - ile nizej mam podjechac zeby shunk byl na wysokosci sita po srodku szczek,by bezpiecznie go pobrac 
underateq[1] = 3
underateq[2] = 2
underateq[3] = 3
underateq[4] = 2
underateq[5] = 3
;przy podnoszeniu pakietu z paletki - korekcja gora/dol zeby shunk byl na wysokosci sita i dobrze zlapal pakiet
pickcorrection[1] = 14    ;ZMIENIC
pickcorrection[2] = 12
pickcorrection[3] = 8
pickcorrection[4] = 4
pickcorrection[5] = -2
;przy wstawianiu do ateq - przesuniecie w zaleznosci od typu pakietu 
;ateqShift[1] = 2
;ateqShift[2] = 2
;ateqShift[3] = 2
;ateqShift[4] = 1
;ateqShift[5] = 0
maxtimershunk = 20  ;max czas jaki ma shunk na odp
;maxTimerFingers = 3 	;max czas po jakich palce powinny sie zamknac 
filllvl = 0    ;przy ukladaniu drugiej warstwy liczy ile procent juz zapelnilem
gotobp = TRUE
gotosafe = TRUE
firstcycle = TRUE
safeprocedure = FALSE  ;zaraz po wlaczeniu uruchamiana jest procedura goSafe
;flaga potrzebna by recznie obsluzyc transportery
;gdy nic nie ma na zadnym sensorze to przez 15s krece transporterem, 
;jesli cos na nim jest to dojedzie i zatrzyma sie przy robocie 
checkingsafe = TRUE  ;flaga mowiaca o tym, ze trzymam palete/przekladke 
;nie moge wtedy jechac np sprawdzic czy jest chwytak 
localizationok = FALSE
readytotest = FALSE  ;mowi czy ateq jest gotowy do przeprowadzenia testu np czy juz czegos nie testuje 
layercount = 1
rowcount = 1
colcount = 1
type = 1
prevtype = -1
heatexcode = 1
prevcode = -1
nrofspacers = 0
nrofpaletts = 0
;preset signals
FOR i = 1 TO 2
SIGNAL -trready[i]
SIGNAL -layerfull[i]
SIGNAL -spacerputted[i]
SIGNAL -errortr[i]
SIGNAL -errortrblocked[i]
END
SIGNAL -trready[3]
SIGNAL -waitforshunkmov
SIGNAL -heatextaken
SIGNAL -heatexputtedina
SIGNAL -heatexonpalette
SIGNAL -heatexoncross
SIGNAL -heatexongalante
SIGNAL stoptransporter[1]
SIGNAL stoptransporter[2]
SIGNAL -moveout[1]
SIGNAL -moveout[2]
;SIGNAL -trmanual
SIGNAL -enterconf
SIGNAL -pauseconf
SIGNAL -testokk
SIGNAL -tokk_m
;gasze wszystkie errory 
SIGNAL -errornogripper
SIGNAL -errorateq
SIGNAL -errortr3full
SIGNAL -errorstuck
SIGNAL -errorholdinghea
SIGNAL -errorshunkfail
SIGNAL -errortr[1] ;w trakcie pracy brak palet choc sensor cos wykryl
SIGNAL -errortr[2] ;w trakcie pracy brak przekladek choc sensor cos wykryl
SIGNAL -errornoheatex ;w trakcie pracy brak wymiennika choc dostalem sygnal
SIGNAL -errorheatexsens ;gdy po odstawieniu pakietu do ateq czujnik nadal pokazuje 1 ->zepsol sie 
;lub zabrudzil 
SIGNAL -errorheatexwron ;dostalem dziwny kod pakietu - nie moge go przypsisac do zadnego typu 
SIGNAL -errorpalettesen ;gdy po pobraniu chwytaka i odjechaniu w gore czujnik od wykrywania palet nadal
;pokazuje 1 -> zepsol sie lub zabrudzil
SIGNAL -errorateqsensor  ;gdy czujnik w ateq (obecnosc pakietu) nie zmienia swojego stanu
;pomimo wstawainia/zabierania pakietow 
SIGNAL -errortrsensorsf[1]
SIGNAL -errortrsensorsf[2] ;wykryto popsucie sie sensorow na transporterach 
SIGNAL -errortrsensorsf[3]
;SIGNAL -PaletteWithoutSpacer	;wystawiany, gdy polozylismy palete ale jeszcze nie ma przekladki
;gaszony w putSpacer po polozeniu przekladki
SIGNAL -getpaletteblink   ;ustawiany gdy paleta jest zapelniona w ponad 80% 
;sygnal 'getPalette' zaczyna mrugac (obsluga w signals)
SIGNAL -getpalette
SIGNAL -initok
SIGNAL -errorconfhold
SIGNAL -checksensorsfor[1]
SIGNAL -checksensorsfor[2]
SIGNAL -checksensorsfor[3]
SIGNAL -checksensorsbac[1]
SIGNAL -checksensorsbac[2]
SIGNAL -makingtestateq
SIGNAL -fpositionnextat
;tylko jeden punkt odlkladania pakietu jest zteachowany - 1,1 dla najwiekszego pakietu
;punkty dla pozostalych pakietow jest obliczana ponizej na podstawie schematow paletyzacji
POINT initial_put[1] = SHIFT(init_put[1] BY 65,50)
POINT initial_put[2] = SHIFT(init_put[1] BY 65,55)
POINT initial_put[3] = SHIFT(init_put[1] BY -5,20)
POINT initial_put[4] = SHIFT(init_put[1] BY 15,25)
POINT initial_put[5] = init_put[1]
TIMER (1) = 0 ;timer uzywany w safe podczas czekania na odpowiedzi shunka i toczenia transporterow 
TIMER (2) = 0 ;timer uzywany do mrugania lampka gdy paleta sie zapelnia 
$prevdates = "0" ;zmienna potrzebna by raz dziennie shunk przejechal caly zakres ruchow zeby sie nie zatarl	
$actualdates = $DATE(1) ;zmienna potrzebna jw. okresla aktualna date 
$prevdatea = "0" ;zmienna potrzebna by raz dziennie wykalibrowac ateq 
$actualdatea = $DATE(1) ;zmienna potrzebna jw. okresla aktualna date
SIGNAL -sch_manual ;wylaczenie recznej obslugi shunka (z IFPanel'u)
move_pass = 0 ;zerowanie hasla powrotu robota do pozycji safe
;DO TESTOW
SIGNAL -donext
;curtainbreak = enterconf
;SIGNAL TestOk
;SIGNAL -TestNOK 
;SIGNAL -33			;zatrzymanie tr1
;SIGNAL -EndCycle
;
PRINT "! ! ! testok =",SIG(testok)
IF SIG(testok) THEN
SIGNAL tok_m
ELSE
SIGNAL -tok_m
END
PRINT "! ! ! testnok =",SIG(testnok)
IF SIG(testnok) THEN
SIGNAL tnok_m
ELSE
SIGNAL -tnok_m
END
PRINT "! ! ! testokk =",SIG(testokk)
IF SIG(testokk) THEN
SIGNAL tokk_m
ELSE
SIGNAL -tokk_m
END
PRINT "! ! ! potoncross =",SIG(potoncross)
IF SIG(potoncross) THEN
SIGNAL ptc_m
ELSE
SIGNAL -ptc_m
END
PRINT "! ! ! testinprogres =",SIG(testinprogres)
IF SIG(testinprogres) THEN
SIGNAL tip_m
ELSE
SIGNAL -tip_m
END
;
;
RETURN
.END
.PROGRAM decodetype()
PRINT "START: decodetype()"
;na podstawie kodu pakietu otrzymanego od PLC okreslam jaki to typ wg rozmiaru - wiem jak go palletyzowac
; i jak mocno otwierac szczeki shunka 
; modyfikacja przeliczania na kody pakietw 1 z 12 Krzysztof Olejnik
decoded = FALSE
IF heatexcode==1 OR heatexcode==2 THEN
type = 1
decoded = TRUE
PRINT "   heatexcode = 16A / 24A"
END
IF heatexcode>=3 AND heatexcode<=5 THEN
type = 2
decoded = TRUE
PRINT "   heatexcode = 16 / 24 / 32"
END
IF heatexcode>=6 AND heatexcode<=7 THEN
type = 3
decoded = TRUE
PRINT "   heatexcode = 32A / 45A"
END
IF heatexcode>=8 AND heatexcode<=9 THEN
type = 4
decoded = TRUE
PRINT "   heatexcode = 40 / 50/60 / 75/80"
END
IF heatexcode>=10 AND heatexcode<=12 THEN
type = 5
decoded = TRUE
PRINT "   heatexcode = 100 / 120"
END
IF heatexcode<1 OR heatexcode>12 THEN
PRINT "   nie prawidowy heatexcode ! ! ! ! !"
END
PRINT "END: decodetype()"
RETURN
.END
.PROGRAM drivesafe()
LMOVE #safe
POINT safe1 = HERE
POINT safe1 = safe1+RZ(90)
LMOVE safe1
POINT #safet = HERE
.END
.PROGRAM emptyworkstatio()
;gdy przyjdzie sygnal o koncu pracy, wykonywany jest ten program, jesli potrzeba robot kladzie przekladke a potem
;wysuwa to co stoi na tr3 
IF SIG(sensorback[3]) THEN
IF SIG(layerfull[1],-spacerputted[1]) THEN ;paleta ma wyjechac z pelna 1 warstwa ale nie ma przekladki
CALL putspacer
JMOVE #safet
END
IF SIG(layerfull[2],-spacerputted[2]) THEN
CALL putspacer
JMOVE #safet
END
WHILE SIG(sensorfront[3]) DO  ;w rzeczywistosci nigdy nie powinno byc tej sytuacji
;wystaw sygnal dla PLC zeby ktos odebral palete
SIGNAL getpalette
SIGNAL -getpalettteblin
CALL allowentrance
END ;nie ma nic do odbioru
SIGNAL -getpalette  ;skoro tu doszedl tzn ze nic nie stoi na tr3 z przodu
SIGNAL trready[3] ;calosc do odbioru - sygnal zeby wyjechal tr3
WAIT SIG(sensorfront[3]) ;czekam az calosc dojedzie do konca
SIGNAL -trready[3]
END
IF SIG(havegripper,-leftgripper) THEN
CALL putoutgripper
END
RETURN
.END
.PROGRAM errlogudprecv()
PRINT "    ErrLogRecv: ",logudpcounter
RETURNE
.END
.PROGRAM errlogudprecv2()
PRINT "    ErrLogRecv2: ",logudpcounter2
RETURNE
.END
.PROGRAM errlogudpsend()
PRINT "    errLogSend: ",logudpcounter
RETURNE
.END
.PROGRAM errlogudpsend2()
PRINT "    errLogSend2: ",logudpcounter2
RETURNE
.END
.PROGRAM exit_tr()
TIMER (1) = 0
SIGNAL goback[1]
WAIT SIG(sensorback[1]) OR TIMER(1)>5
SIGNAL -goback[1]
.END
.PROGRAM exittr()
TIMER (1) = 0
SIGNAL trready[1]
WAIT SIG(sensorfront[1]) OR TIMER(1)>15
IF SIG(-sensorfront[1]) THEN
PRINT " timeout   sensorfront[1] =",SIG(sensorfront[1])
END
SIGNAL -trready[1]
RETURN
.END
.PROGRAM getatq()
;####################################################################
;# Pobranie pakietu z testu szczelnoci ATQ
;####################################################################
SPEED ateqspd MM/S ALWAYS
WAIT SIG(-makingtestateq)
LMOVE wait_test
;LMOVE wait_ateq
;upewniam sie ze mam otwarte palce do lapania pakietow i shunk jest otwarty odpowiednio szeroko 
SIGNAL -closefingers
SIGNAL openfingers
WAIT SIG(-leftfingerc,-rightfingerc,leftfingero,rightfingero)
IF type<5 THEN
width = (jawwidth[type]+110)
ELSE
width = (jawwidth[type]+70)
END
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
TWAIT (0.2)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
;sprawdzenie czy korekty pozycji pakietow w ATEQ nie sa zbyt duze
CALL checkateqcor
;wprowadzenie korekty odlozenia pakietu w ATEQ'u
POINT ateq = SHIFT(ateqorg BY ateqcorx[type],ateqcory[type])
SPEED spd MM/S
LAPPRO ateq,-20
TWAIT (0.5)
LAPPRO ateq,-underateq[type]    ;jestem w ATEQ - podjazd zeby sito bylo miedzy szczekami
TWAIT 0.5
IF SIG(-heatexingripper) THEN
SIGNAL errorateq   ;wstawilem cos do ateq a teraz to zniknelo 
LMOVE wait_ateq
;zaciskam szczeki zeby nie uderzyc w nic jak mam je otwarte do chwytania
width = jawwidth[1]
BITS 81+16,16 = 0
BITS 81+16+8,16 = width-20 ;zaciskanie 'za mocno' shunk odpowie 'Move Blocked'
TWAIT (0.2)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
;odjazd do safeT
SPEED spd MM/S ALWAYS
LMOVE #before_ateqr
JMOVE #safe90
JMOVE #safet
;wchodze w nieskonczona petle - i tak trzeba bedzie zresetowac stanowisko 
WHILE SIG(errorateq) DO
SIGNAL errorateq
END
END
;WAIT SIG(doNext)	;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
;SIGNAL -doNext
width = jawwidth[type]
BITS 81+16,16 = 0
BITS 81+16+8,16 = width-20 ;zaciskanie 'za mocno' shunk odpowie 'Move Blocked'
TWAIT (0.2)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
;cShunkPos = BITS(1201,16)	;stare nr bitow przed dodaniem wyspy wago - moze sie przyda 
cshunkpos = BITS(1265,16) ;current Shunk Position odczytanie na jakiej pozycji stanal shunk
IF (type==2) OR (type==3) THEN
BITS 81+16,16 = 0
BITS 81+16+8,16 = cshunkpos+10  ;lekkie rozwarcie - pakiet nie spadnie a shunk bedzie "na pozycji"
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
LMOVE ateq
TWAIT (0.5)
LAPPRO ateq,5 ;troche w gore - gorne sito opiera sie na szczekach 
TWAIT (0.5)
BITS 81+16,16 = 0
BITS 81+16+8,16 = cshunkpos+3  ;lekkie rozwarcie - pakiet nie spadnie a shunk bedzie "na pozycji"
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
ELSE
BITS 81+16,16 = 0
BITS 81+16+8,16 = cshunkpos+3  ;lekkie rozwarcie - pakiet nie spadnie a shunk bedzie "na pozycji"
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
LMOVE ateq
TWAIT (0.5)
LAPPRO ateq,5 ;troche w gore - gorne sito opiera sie na szczekach 
TWAIT (0.5)
END
;---------------ROZWARCIE-----
BITS 81+16,16 = 0
BITS 81+16+8,16 = cshunkpos+8  ;rozwarcie szczek aby pakiet opadl na "polki" szczek
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
;-----------------------------	
;---------------CENTROWANIE---
TWAIT (0.5)
BITS 81+16,16 = 0
BITS 81+16+8,16 = cshunkpos  ;zacisniecie shunka za mocno - odpowie Move Blocked
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
TWAIT (0.5)
;-----------------------------
;--------------ROZLUZOWANIE---
BITS 81+16,16 = 0
BITS 81+16+8,16 = cshunkpos+3  ;lekkie rozwarcie - pakiet nie spadnie a shunk bedzie "na pozycji"
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
TWAIT (0.5)
;-----------------------------
SIGNAL closefingers
SIGNAL -openfingers
WAIT SIG(leftfingerc,rightfingerc,-leftfingero,-rightfingero)
LAPPRO ateq,20
;WAIT SIG(doNext)	;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
;SIGNAL -doNext
;trzymam pakiet - moge wyjezdzac 
LMOVE wait_ateq
SPEED spd MM/S ALWAYS
LMOVE #before_ateqr
.END
.PROGRAM getgripper()
;jade po chwytak 
SPEED spd MM/S ALWAYS
;jesli jade po odstawieniu pakietu lub przy inicjalizacji to nie jade do #safeT tylko bzposrednio nad chwytak 
IF gotosafe THEN
JMOVE #safet
END
gotosafe = TRUE
SIGNAL trready[1]
SIGNAL trready[2]
nogriperror = TRUE
WHILE nogriperror DO
TOOL big_gripper
JMOVE #over_gripper
LAPPRO get_grip,500
SPEED slow MM/S ALWAYS
SIGNAL closefingers
SIGNAL (-openfingers)     ;zamykanie chwytaka do podoszenia pakietow
WAIT SIG(leftfingerc,rightfingerc,-leftfingero,-rightfingero)
SIGNAL -leavepalette
SIGNAL grabpalette  ;przed wjazdem zamknij silownik od palet zeby nie udzezyc w chwytak 
WAIT SIG(-palettegrippero,palettegripperc)
LMOVE inside_grip
SIGNAL leavepalette      ;rozsuniecie chwytaka palet - chwytak pobierany jest w poz otwartej
SIGNAL -grabpalette
WAIT SIG(palettegrippero,-palettegripperc)
SIGNAL leavegripper      ; zeby podjazd po chwytak byl z zamknietym bolcem
SIGNAL -grabgripper
WAIT SIG(leftgripper,-havegripper)
SIGNAL -connectoron
LMOVE get_grip
TWAIT (0.5)
BREAK
SIGNAL connectoron
SIGNAL -leavegripper
SIGNAL grabgripper
WAIT SIG(havegripper,-leftgripper)
TWAIT 0.2
IF SIG(-palettedetect) THEN ;nie mam chwytaka 
SIGNAL -connectoron
SIGNAL leavegripper
SIGNAL -grabgripper
WAIT SIG(-havegripper,leftgripper)
TWAIT 0.2
LMOVE inside_grip
SIGNAL -leavepalette
SIGNAL grabpalette
WAIT SIG(-palettegrippero,palettegripperc)
LAPPRO get_grip,500
LMOVE #over_gripper
;!! ERROR NIE MA CHWYTAKA !!
;wyslac sygnal do plc
SIGNAL errornogripper ;po tym wchodze do petli z ktorej juz nie wyjde
;i tak cale stanowisko musi byc zrestartowane bo ktos przetnie bariere
nogriperror = TRUE
WHILE nogriperror DO
;czekac na syg od plc czekam w nieskonczonosc
SIGNAL errornogripper
END
ELSE
nogriperror = FALSE
END
END
LAPPRO get_grip,200
SPEED spd MM/S ALWAYS
LMOVE #over_gripper;odjazd nad pobranie chwytaka
IF layercount>1 THEN
;jesli mam ulozone juz 2 warstwy na tr3 to musze przejechac przez pozycje bezpieczna 
;inaczej uderze w stojace juz pakiety 
JMOVE poz2
END
JMOVE #safet
IF SIG(palettedetect) THEN
;jesli pomimo tego, ze odjechalem do safe, czujnik od wykrywania palet nadal pokazuje 1 tzn ze sie zepsol
;lub zabrudzil
SIGNAL errorpalettesen
SIGNAL initok
;wystawiam blad i sie zatrzymuje - wchodze w nieskonczona petle i tak, gdy ktos przetnie bariere to 
;stanowisko bedzie musialo byc zrestartowane 
WHILE SIG(errorpalettesen) DO
SIGNAL errorpalettesen
END
END
.END
.PROGRAM gosafe()
PRINT "START: gosafe()"
safeprocedure = TRUE
BREAK
SPEED slow MM/S ALWAYS
;TOOL big_gripper
HERE current
cx = DX(current)
cy = DY(current)
cz = DZ(current)    ;mam swoje aktualne polozenie 
;########  I  #######		;nad transporterami
IF cx>=(DX(conveyors_borde)+400) AND cy>=(DY(conveyors_borde)-150) THEN  ;jestem nad transporterami
PRINT "IF cx>=(DX(conveyors_borde)+400) AND cy>=(DY(conveyors_borde)-150)"
zdif = DZ(pick_spacer)+spacerheight*maxnrofspacers+200
zdif = zdif-DZ(current)
POINT goup = SHIFT(current BY 0,0,zdif)
LMOVE goup
SPEED spd MM/S ALWAYS
TOOL big_gripper
IF cx>=(DX(put_palette)-500) THEN ;jestem nad tr3 
PRINT "IF cx>=(DX(put_palette)-500)"
HERE current1
zdif = DZ(pick_spacer)+(pacheight[5]+spacerthicknes)*2+100
zdif = zdif-DZ(current1)
POINT goup = SHIFT(current1 BY 0,0,zdif)
SPEED slow MM/S
LMOVE goup
IF SIG(havegripper,-leavegripper) THEN
IF (cy>=(DY(put_spacer)-10)) AND (cy<(DY(put_spacer)+10)) THEN
;wlasnie odlozylem przekladke - odjechanie prostopadle do robota w kierunku tr1 
BREAK
POINT pavoid = HERE
POINT pavoid = SHIFT(pavoid BY -1300,0,50)
LMOVE pavoid
END
ELSE
JMOVE #before_putr
JMOVE #safet
END
END
IF SIG(heatexingripper) THEN
JMOVE #safe90
ELSE
IF SIG(palettedetect) THEN
LMOVE #safet
ELSE
JMOVE #safet
END
END
END
;#######    II		#######		;przed transporterami
;jestem przed transporterami albo jade po/z pakiet(em) 
;+/- 150 jest po to zebym nie przywalil w winde jadac z pakietem 
IF cx>=(DX(conveyors_borde)+400) AND cy<(DY(conveyors_borde)-150) THEN
PRINT "IF cx>=(DX(conveyors_borde)+400) AND cy<(DY(conveyors_borde)-150)"
SPEED slow MM/S ALWAYS
TOOL big_gripper
;obsluga co gdy wlasnie odstawilem gripper - nie moge od razu do #safeT
IF (cx>=(DX(get_grip)-10)) AND (cx<(DX(get_grip)+10)) AND (cy>=(DY(get_grip)-10)) AND (cy<(DY(get_grip)+10)) THEN  ;jestem w 																				;gripperze lub w poblizu - musze odjechac do gory
IF cz<=(DZ(inside_grip)) THEN ;jestem w srodku chwytaka zbyt nisko zeby chowac silownik do palet 
SPEED slow MM/S ALWAYS
SIGNAL leavepalette
SIGNAL -grabpalette
PRINT "   WAIT SIG(palettegrippero,-palettegripperc)"
WAIT SIG(palettegrippero,-palettegripperc)
PRINT "   WAIT OK"
LMOVE get_grip
TWAIT 0.5
SIGNAL -connectoron
SIGNAL leavegripper
SIGNAL -grabgripper
PRINT "   WAIT SIG(leftgripper,-havegripper)"
WAIT SIG(leftgripper,-havegripper)
PRINT "   WAIT OK"
LMOVE inside_grip
TWAIT 0.5
SIGNAL -leavepalette
SIGNAL grabpalette
PRINT "   WAIT SIG(-palettegrippero,palettegripperc)"
WAIT SIG(-palettegrippero,palettegripperc)
PRINT "   WAIT OK"
LAPPRO get_grip,200
END
LMOVE #over_gripper
ELSE
zdif = DZ(pick_spacer)+spacerheight*maxnrofspacers+200
zdif = zdif-DZ(current)
POINT goup = SHIFT(current BY 0,0,zdif)
LMOVE goup
END
SPEED spd MM/S ALWAYS
IF cx>0 THEN ;jestem po prawej stronie robota - na wysokosci tr3   
IF SIG(havegripper,-leavegripper) THEN ;jesli trzymam chwytak to bezpiecznie jechac przez poz2 
LMOVE poz2
END
END
IF SIG(heatexingripper) THEN
JMOVE #safe90;jesli trzymam pakiet to pewnie jechalem go odlozyc 
;bezpieczna pozycja jest #safe90, bo w #safeT istnieje ryzyko ze uderze w szybe
ELSE
IF SIG(palettedetect) THEN
LMOVE #safet
ELSE
JMOVE #safet;jesli nie trzymam pakietu to jade do #safeT - pozycja 'pod siebie'
END
END
END
; NA PEWNO JESTEM W #SAFET - MOGA RUSZYC TRANSPORTERY 
;JESLI NIE BYLEM ANI W 'I' ANI W 'II' TO I TAK JEST BEZPIECZNIE I TEZ MOGA JECHAC 
;sprawdzam czy cos sie nie zgubilo na transporterach - czy nie stoi w polowie
;SIGNAL TrManual
SIGNAL -goforward[3]
FOR i = 1 TO 2
SIGNAL -goback[i]
IF SIG(-sensorfront[i],-sensorback[i],objectnotin[i]) THEN  ;zaden sensor nic nie wykrywa 
;SIGNAL mantrback[i] ;rusz tym transporterem by dojechal do robota 
;tam sie zatrzyma bo sa mechaniczne zderzaki
END
END
SIGNAL -goback[3]
IF SIG(-sensorfront[3],-sensorback[3]) THEN
;SIGNAL mantrback[3]
END
IF SIG(mantrback[1]) OR SIG(mantrback[2]) OR SIG(mantrback[3]) THEN ;jesli wlaczylem ktorys transporter
TWAIT 15  ; to wstrzymaj program i daj czas zeby cokolwiek moglo dojechac do sensorow 
END
FOR i = 1 TO 3
;SIGNAL -mantrback[i] ;wylacz wszystkie transportery
;SIGNAL -mantrforward[i]
SIGNAL -goback[i]
SIGNAL -goforward[i]
END
BREAK
;SIGNAL -trmanual
;jesli cokolwiek bylo na transporterach to powinno teraz stac przy robocie -zatrzymac sie na mechanicznych zderzakach
;jesli niczego nie bylo to po prostu transportery chwile sie pokreca 
IF SIG(sensorfront[3]) OR SIG(sensorback[3]) OR SIG(havegripper,palettedetect,-leavepalette) THEN
SIGNAL errortr3full
END
IF SIG(sensorback[3],-sensorfront[3]) THEN
SIGNAL trready[3]
PRINT "   WAIT SIG(sensorfront[3])"
WAIT SIG(sensorfront[3])  ;jesli cos stoi przy robocie i ma mozliwosc to wyjazd i czekaj az wyjedzie
PRINT "   WAIT OK"
SIGNAL -trready[3]
END
;SPRAWDZAM CZY CZEGOS NIE TRZYMAM W DUZYM CHWYTAKU 
IF SIG(havegripper,palettedetect) THEN ;trzymam cos - palete lub przekladke - odstawie to na tr3
IF SIG(-sensorback[3]) THEN ; nie ma nic na tr3 przy robocie - moge tam odstawic to co trzymam
LAPPRO put_palette,spacerheight*maxnrofspacers+paletteheight+140
LAPPRO put_palette,200
SPEED slow MM/S ALWAYS
LAPPRO put_palette,-70
TWAIT 0.5
SIGNAL leavepalette
SIGNAL -grabpalette
PRINT "   WAIT SIG(palettegrippero,-palettegripperc)"
WAIT SIG(palettegrippero,-palettegripperc)
PRINT "   WAIT OK)"
LAPPRO put_palette,200
SPEED spd MM/S ALWAYS
LAPPRO put_palette,spacerheight*maxnrofspacers+paletteheight+140
LMOVE #safet
SIGNAL trready[3]
PRINT "   WAIT SIG(sensorfront[3])"
WAIT SIG(sensorfront[3])
PRINT "   WAIT OK"
SIGNAL errortr3full
SIGNAL -trready[3]
ELSE ;TR3 jest zajety - musze stanac i czekac az ktos recznie mnie ustawi
PRINT "TR3 jest zajety - musze stanac i czekac az ktos recznie mnie ustawi"
checkingsafe = FALSE
LMOVE #safet
END
END
;#######    III		#######				; jesli tylko znajde sie za winda to wystaw sygnal zeby ktos recznie wyjechal 
IF cx<(DX(conveyors_borde)+400) THEN
PRINT "jesli tylko znajde sie za winda to wystaw sygnal zeby ktos recznie wyjechal"
SIGNAL errorstuck
checkingsafe = FALSE
END
;wyjechalem w bezpieczne pozycje
IF checkingsafe THEN
IF SIG(heatexingripper) THEN ;trzymam pakiet - wystaw blad i czekaj
;SIGNAL ErrorHoldingHeatEx
checkingsafe = FALSE
CALL putoutheatex
END
CALL checkshunk
IF SIG(havegripper,-leftgripper) THEN
CALL putoutgripper;odlozenie chwytaka do palet 
gotosafe = FALSE  ;zeby nie jechal niepotrzebnie do #safeT (i tak zaraz by wracal) 
ELSE
PRINT "przed CALL checkgripper"
CALL checkgripper;sprawdzenie czy chwytak do palet jest na miejscu
PRINT "po CALL checkgripper"
END
END
IF SIG(-heatexinateq) THEN ;jesli nie ma pakietu w ateq to zrob kalibracje
SIGNAL -hatdown
SIGNAL hatup
BREAK
PRINT "   WAIT SIG(hatisup,-hatisdown)"
WAIT SIG(hatisup,-hatisdown)
PRINT "   WAIT OK)"
SIGNAL ateqcal
TWAIT 1
PRINT "   WAIT SIG(ateqcalok)"
WAIT SIG(ateqcalok)
PRINT "   WAIT OK"
SIGNAL -ateqcal
readytotest = TRUE
SIGNAL -errorateq
ELSE
PRINT "SIGNAL errorateq"
SIGNAL errorateq
readytotest = FALSE
END
;readyToTest = TRUE ; ZAKOMENTOWAC JAK BEDZIE ODKOMENTOWANE TO POWYZEJ 
;jesli sa errory to wystawiam sygnal zezwalajacy na wejscie 
IF SIG(errornogripper) OR SIG(errorateq) OR SIG(errortr3full) OR SIG(errorstuck) OR SIG(errorholdinghea) OR SIG(errorshunkfail) THEN
SIGNAL enterconf
END
TOOL big_gripper
safeprocedure = FALSE
PRINT "END: gosafe()"
RETURN
.END
.PROGRAM gotoateq()
JMOVE #before_ateqr
LMOVE wait_ateq
SPEED ateqspd MM/S ALWAYS
;stoje przed ateq
;ODKOMENTOWAC GDY BEDZIE JUZ OBSLUGA ATEQ
SIGNAL -changepos
FOR i = 1 TO 5
SIGNAL -ref[i]
END
BREAK
FOR i = 1 TO 6
SIGNAL -ateqpos[i]
END
BREAK
SIGNAL hatup
SIGNAL -hatdown
WAIT SIG(hatisup,-hatisdown)
BREAK
SIGNAL ateqpos[1] ; odjazd max do gory
SIGNAL changepos
WAIT SIG(ateqinpos)
SIGNAL -ateqpos[1]
SIGNAL -changepos
BREAK
;KONIEC PRZYGOTOWANIA ATEQ
LAPPRO ateq,15
TWAIT 0.5 ;jestem w ATEQ - trzeba puscic pakiet
LMOVE ateq
TWAIT 0.5
SIGNAL openfingers
WAIT SIG(-leftfingerc,-rightfingerc,leftfingero,rightfingero)
LAPPRO ateq,-20
WAIT SIG(donext) ;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
SIGNAL -donext
IF type<5 THEN
width = (jawwidth[type]+110)
ELSE
width = (jawwidth[type]+70)
END
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
WAIT SIG(donext) ;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
SIGNAL -donext
;LMOVE wait_ateq
POINT wait_test = ateq+TRANS(0,-500)
LMOVE wait_test
;VVVVVto zakomentowac jak bedzie obsluga ateq VVVVVV
;SIGNAL HeatExPuttedInAteq
;SIGNAL -HeatExTaken
TWAIT 1
CALL ateq
TWAIT 1
SPEED ateqspd MM/S ALWAYS
WAIT SIG(-testinprogres)
LMOVE wait_test
;LMOVE wait_ateq
;SIGNAL OpenFingers
;WAIT SIG(-LeftFingerC,-RightFingerC,LeftFingerO,RightFingerO)
;width = (jawWidth[type] + 70)
;BITS 81+16,16 = 0
;BITS 81+16+8,16 = width
;TWAIT(3)
LAPPRO ateq,-20
TWAIT (0.5)
LAPPRO ateq,-underateq[type]    ;jestem w ATEQ - podjazd zeby sito bylo miedzy szczekami
TWAIT 0.5
IF SIG(-heatexingripper) THEN
SIGNAL errorateq   ;wstawilem cos do ateq a teraz to zniknelo 
loop = TRUE
WHILE loop DO
SIGNAL errorateq
END
END
WAIT SIG(donext) ;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
SIGNAL -donext
width = jawwidth[type]-20
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
cshunkpos = BITS(1201,16) ;current Shunk Position odczytanie na jakiej pozycji stanal shunk
BITS 81+16,16 = 0
BITS 81+16+8,16 = cshunkpos+3  ;lekkie rozwarcie - pakiet nie spadnie a shunk bedzie "na pozycji"
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
LMOVE ateq
TWAIT (0.5)
LAPPRO ateq,5 ;troche w gore - gorne sito opiera sie na szczekach 
TWAIT (0.5)
SIGNAL -openfingers
WAIT SIG(leftfingerc,rightfingerc,-leftfingero,-rightfingero)
LAPPRO ateq,15
WAIT SIG(donext) ;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
SIGNAL -donext
LMOVE wait_ateq
SPEED spd MM/S ALWAYS
LMOVE #before_ateqr
JMOVE #safe90
.END
.PROGRAM gripperup()
;objectIn[1]=2010
;objectIn[2]=2011
;moveObject[1]=2012
;moveObject[2]=2013
;moveObject[3]=2014
;dla tool null
;point #over_conveyors
;point #over_lift
;point pick_palette
;point pick_spacer
;point put_palette
;point put_spacer
;point pick_heatEx
;point #before_ateq
;point wait_ateq
;point ateq
;point #safe
;point #midway
;===========podnoszenie chytaka============
;BASE NULL
;TOOL big_gripper
;SIGNAL -OpenFingers
;SIGNAL LeavePalette
;SIGNAL LeaveGripper
;SIGNAL -ConnectorOn
;LAPPRO get_grip, 1000
;LMOVE get_grip
;SIGNAL ConnectorOn
;SIGNAL -LeaveGripper
;PAUSE
;LAPPRO get_grip, 1000
;PAUSE
;LMOVE get_grip
;SIGNAL -ConnectorOn
;SIGNAL LeaveGripper
;LAPPRO get_grip, 1000
;==============przenoszenie pakietu==============
BASE NULL
TOOL big_gripper
;jmove #safe
;jmove #over_conveyors
;jmove #over_lift
;lappro pick_heatEx,500
;lmove pick_heatEx
LAPPRO pick_heatex,500
LMOVE #midway
LMOVE #before_ateq
LMOVE wait_ateq
LMOVE ateq
PAUSE
LMOVE wait_ateq
LMOVE #before_ateq
LMOVE #midway
JMOVE #over_lift
JMOVE #over_conveyors
JMOVE #safe
.END
.PROGRAM init()
IF $task=="Search" THEN
PRINT "Skanowanie palety"
END
IF $task=="PickEx" THEN
PRINT "Pobieranie wymniennika"
IF $zone<>"Safe" THEN
LDEPART 100
BREAK
$zone = "Safe"
END
IF SIG(go) THEN
CALL pickex
END
$task = "PlaceEx"
BREAK
END
IF $task=="PlaceEx" THEN
PRINT "Ukladanie wymiennika"
IF $zone<>"Safe" THEN
LDEPART 200
BREAK
$zone = "Safe"
END
IF SIG(gc) THEN
CALL placeex
END
JMOVE #placeweight
BREAK
$task = "PickWeight"
END
IF $task=="PickWeight" THEN
PRINT "Pobieranie obciaznika"
IF $zone<>"Safe" THEN
LDEPART 200
BREAK
$zone = "Safe"
END
IF SIG(go) THEN
CALL pickweight
END
JMOVE #cart
BREAK
$task = "PlaceWeight"
END
IF $task=="PlaceWeight" THEN
PRINT "Ukladanie obciaznika"
IF $zone<>"Safe" THEN
LDEPART 200
BREAK
$zone = "Safe"
END
IF SIG(gc) THEN
CALL placeweight
END
JMOVE #placeex
BREAK
END
RETURN
.END
.PROGRAM lasersearch()
;"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
LMOVE searchstart
BREAK
SIGNAL laser
SIGNAL -searchok
TWAIT 0.5
WAIT SIG(-lasersignal)
SPEED searchspeed MM/S
PCEXECUTE 2: tsk
LMOVE searchend
ONI searchok GOTO laserend
BREAK
PRINT ""
PRINT "NIE ZNALEZIONO ZBOCZA ! ! !"
PRINT ""
laserend:
PCABORT 2: 
IGNORE lasersignal
SIGNAL -laser
LMOVE searchpoint
BREAK
SIGNAL laser
TWAIT 1
SIGNAL -laser
RETURN
.END
.PROGRAM log(.$text)
$sendlogdata[0] = "L"+$ENCODE(/I2,logudpcounter)+"0M"
$sendlogdata[1] = .$text
.repeat = 1
.ack = 0
WHILE .ack==0 AND .repeat>0 DO
; Wyslanie komunikatu do PC
ONE errlogudpsend
UDP_SENDTO .error,logudpadrip[0],logudp.port,$sendlogdata[0],2,2
IF .error<>0 THEN
PRINT "###  Wystapil blad podczas wysylania danych do PC (UDP)"
;		ELSE
;			; Oczekiwanie na potwierdzenie odebrania komunikatu
;			ONE ErrLogUDPRecv
;			UDP_RECVFROM .error,logUDP.port,.$receiveData[0],.numOfElem,logUDPwaitTime,logUDPadrIP[0],logUDPmaxSize
;			IF .error==0 THEN
;				;PRINT "Odebrano: ",.$receiveData[0],"   oczekiwano:",.$sendData[0]
;				IF .$receiveData[0]==.$sendData[0] THEN
;					.ack = 1
;				END
;			ELSE
;				;PRINT "###  Nie odebrano potwierdzenia odebrania komunikatu"
;			END
END
.repeat = .repeat-1
END
logudpcounter = logudpcounter+1
IF logudpcounter>99 THEN
logudpcounter = 0
END
RETURN
.END
.PROGRAM log2(.$text)
$sendlog2data[0] = "L"+$ENCODE(/I2,logudpcounter2)+"1M"
$sendlog2data[1] = .$text
.repeat = 2
.ack = 0
WHILE .ack==0 AND .repeat>0 DO
; Wyslanie komunikatu do PC
ONE errlogudpsend2
UDP_SENDTO .error,logudpadrip[0],logudp.port,$sendlog2data[0],2,2
IF .error<>0 THEN
PRINT "###  Wystapil blad podczas wysylania danych do PC (UDP)"
;		ELSE
;			; Oczekiwanie na potwierdzenie odebrania komunikatu
;			ONE ErrLogUDPRecv2
;			UDP_RECVFROM .error,logUDP.port,.$receiveData2[0],.numOfElem2,logUDPwaitTime,logUDPadrIP2[0],logUDPmaxSize
;			IF .error==0 THEN
;				;PRINT "Odebrano: ",.$receiveData[0],"   oczekiwano:",.$sendData[0]
;				IF .$receiveData2[0]==.$sendData2[0] THEN
;					.ack = 1
;				END
;			ELSE
;				;PRINT "###  Nie odebrano potwierdzenia odebrania komunikatu"
;			END
END
.repeat = .repeat-1
END
logudpcounter2 = logudpcounter2+1
IF logudpcounter2>99 THEN
logudpcounter2 = 0
END
RETURN
.END
.PROGRAM log2d(.$text)
; Wyslanie komunikatu - watek komunikacji - dane (zielony)
IF log==1 THEN
$sendlog2data[0] = "L"+$ENCODE(/I2,logudpcounter2)+"1D"
$sendlog2data[1] = .$text
CALL sendlog2
END
RETURN
.END
.PROGRAM log2e(.$text)
; Wyslanie komunikatu - watek komunikacji - error (czerwony)
$sendlog2data[0] = "L"+$ENCODE(/I2,logudpcounter2)+"1E"
$sendlog2data[1] = .$text
CALL sendlog2
RETURN
.END
.PROGRAM log2i(.$text)
; Wyslanie komunikatu - watek komunikacji - info (niebieski)
$sendlog2data[0] = "L"+$ENCODE(/I2,logudpcounter2)+"1I"
$sendlog2data[1] = .$text
CALL sendlog2
RETURN
.END
.PROGRAM log2int(.$text,.value)
; Wyslanie komunikatu - watek glowny - logowanie liczby (zielony)
IF log==1 THEN
$sendlog2data[0] = "L"+$ENCODE(/I2,logudpcounter2)+"1D"
$sendlog2data[1] = .$text+$ENCODE(/F8.0,.value)
CALL sendlog2
END
RETURN
.END
.PROGRAM log2m(.$text)
; Wyslanie komunikatu - watek komunikacji - wiadomosc (czarny)
IF log==1 THEN
$sendlog2data[0] = "L"+$ENCODE(/I2,logudpcounter2)+"1M"
$sendlog2data[1] = .$text
CALL sendlog2
END
RETURN
.END
.PROGRAM log2num(.$text,.value)
; Wyslanie komunikatu - watek glowny - logowanie liczby (zielony)
IF log==1 THEN
$sendlog2data[0] = "L"+$ENCODE(/I2,logudpcounter2)+"1D"
$sendlog2data[1] = .$text+$ENCODE(/F10.4,.value)
CALL sendlog2
END
RETURN
.END
.PROGRAM log2t(.$text)
; Wyslanie komunikatu - watek komunikacji - tlo (szary)
IF log==1 THEN
$sendlog2data[0] = "L"+$ENCODE(/I2,logudpcounter2)+"1T"
$sendlog2data[1] = .$text
CALL sendlog2
END
RETURN
.END
.PROGRAM log2w(.$text)
; Wyslanie komunikatu - watek komunikacji - warrning (pomaranczowy)
$sendlog2data[0] = "L"+$ENCODE(/I2,logudpcounter2)+"1W"
$sendlog2data[1] = .$text
CALL sendlog2
RETURN
.END
.PROGRAM logd(.$text)
; Wyslanie komunikatu - watek glowny - dane (zielony)
IF log==1 THEN
$sendlogdata[0] = "L"+$ENCODE(/I2,logudpcounter)+"0D"
$sendlogdata[1] = .$text
CALL sendlog
END
RETURN
.END
.PROGRAM loge(.$text)
; Wyslanie komunikatu - watek glowny - error (czerwony)
$sendlogdata[0] = "L"+$ENCODE(/I2,logudpcounter)+"0E"
$sendlogdata[1] = .$text
CALL sendlog
RETURN
.END
.PROGRAM logi(.$text)
; Wyslanie komunikatu - watek glowny - info (niebieski)
$sendlogdata[0] = "L"+$ENCODE(/I2,logudpcounter)+"0I"
$sendlogdata[1] = .$text
CALL sendlog
RETURN
.END
.PROGRAM logint(.$text,.value)
; Wyslanie komunikatu - watek glowny - logowanie liczby (zielony)
IF log==1 THEN
$sendlogdata[0] = "L"+$ENCODE(/I2,logudpcounter)+"0D"
$sendlogdata[1] = .$text+$ENCODE(/I8,.value)
CALL sendlog
END
RETURN
.END
.PROGRAM logm(.$text)
; Wyslanie komunikatu - watek glowny - wiadomosc (czarny)
IF log==1 THEN
$sendlogdata[0] = "L"+$ENCODE(/I2,logudpcounter)+"0M"
$sendlogdata[1] = .$text
CALL sendlog
END
RETURN
.END
.PROGRAM lognum(.$text,.value)
; Wyslanie komunikatu - watek glowny - logowanie liczby (zielony)
IF log==1 THEN
$sendlogdata[0] = "L"+$ENCODE(/I2,logudpcounter)+"0D"
$sendlogdata[1] = .$text+$ENCODE(/F10.4,.value)
CALL sendlog
END
RETURN
.END
.PROGRAM logposee()
; Wysylanie komunikatu - watek glowny - logowanie pozycji PoseE
IF log==1 THEN
.x[0] = 0
.x[1] = 0
.x[2] = 0
.x[3] = 0
.x[4] = 0
.x[5] = 0
DECOMPOSE .x[0] = din.robposee
$sendlogdata[0] = "L"+$ENCODE(/I2,logudpcounter)+"0D"
$sendlogdata[1] = $ENCODE(/F10.4,"PoseE: X= ",.x[0],"  Y= ",.x[1],"  Z= ",.x[2],"  O= ",.x[3],"  A= ",.x[4],"  T= ",.x[5])
CALL sendlog
END
RETURN
.END
.PROGRAM logposej()
; Wysylanie komunikatu - watek glowny - logowanie pozycji PoseJ
IF log==1 THEN
.x[0] = 0
.x[1] = 0
.x[2] = 0
.x[3] = 0
.x[4] = 0
.x[5] = 0
DECOMPOSE .x[0] = #din.robposej
$sendlogdata[0] = "L"+$ENCODE(/I2,logudpcounter)+"0D"
$sendlogdata[1] = $ENCODE(/F10.4,"PoseJ: J1= ",.x[0],"  J2= ",.x[1],"  J3= ",.x[2],"  J4= ",.x[3],"  J5= ",.x[4],"  J6= ",.x[5])
CALL sendlog
END
RETURN
.END
.PROGRAM logspeed(.i)
; Wysylanie komunikatu - watek glowny - logowanie Speed
IF log==1 THEN
$sendlogdata[0] = "L"+$ENCODE(/I2,logudpcounter)+"0D"
$sendlogdata[1] = $ENCODE(/I2,"Speed[",.i,/F10.4,"] = [",tabspeed.vl[.i],",",tabspeed.vc[.i],"]")
CALL sendlog
END
RETURN
.END
.PROGRAM logt(.$text)
; Wyslanie komunikatu - watek glowny - tlo (szary)
IF log==1 THEN
$sendlogdata[0] = "L"+$ENCODE(/I2,logudpcounter)+"0T"
$sendlogdata[1] = .$text
CALL sendlog
END
RETURN
.END
.PROGRAM logtool(.i)
; Wysylanie komunikatu - watek glowny - logowanie def. narzedzia
IF log==1 THEN
DECOMPOSE .x[0] = tabtool.pose[.i]
DECOMPOSE .y[0] = tabtool.cogaom[.i]
$sendlogdata[0] = "L"+$ENCODE(/I2,logudpcounter)+"0D"
$sendlogdata[1] = $ENCODE(/I2,"Tool[",.i,/F10.4,"] = [",tabtool.robhold[.i],"[",.x[0],",",.x[1],",",.x[2],",",.x[3],",",.x[4],",",.x[5],"]",tabtool.mass[.i],",",.y[0],",",.y[1],",",.y[2],",",.y[3],",",.y[4],",",.y[5],"]")
CALL sendlog
END
RETURN
.END
.PROGRAM logudpinit()
; Opis protokolu komunikacji przy logowaniu
;		[L][id][thr][type][message]
; Opis:
;		[L]    - jeden bajt 'L' - stay identyfikator paczki danych
;		[id]   - liczba 00-99 zapisana dziesitnie - zmienny identyfikator paczki danych pozwalajcy wykry
;		         zagubienie komunikatw
;		[thr]  - '0' - '9' - identyfikator wtku, 0-wtek gwny, 1-wtek komunikacji
;		[type] - rodzaj komunikatu; 'E' - error (czerwony); 'W' - ostrzerzenie(pomaraczowy);
;		         'I' - Info (niebieski); 'M' - wiadomo (czarny); 'D' - dane (zielony);
;		         'T' - to (wiadomoci mao istotne - kolor szary)
;		[message] - wiadomo do wywietlenia
koniec = 0
; przypisanie pocztkowych wartoci wielkoci wystpujcym w komunikacji
logudp.port = 10064            ; numer portu logowania na robocie
logudpwaittime = 0.1              ; czas oczekiwania na potwierdzenie otrzymania komunikatu
logudpmaxsize = 255              ; maksymalny rozmiar otrzymanej paczki danych (podzial danych na lancuchy)
logudpadrip[0] = 10
logudpadrip[1] = 0
logudpadrip[2] = 21
logudpadrip[3] = 129
PRINT "logUDPadrIP=",logudpadrip[0],";",logudpadrip[1],";",logudpadrip[2],";",logudpadrip[3]
$sendlogdata[0] = "L000M"
$sendlogdata[1] = ""
$sendlog2data[0] = "L001M"
$sendlog2data[1] = ""
logsendmsgmain = 0                 ; watek glowny jest w trakcie wysylania komunikatu
logsendmsgcomm = 0                 ; watek komunikacji jest w trakcie wysylania komunikatu
logudpkomstop = 0                  ; 1 - wstrzymanie logowania w watku komunikacji
IF NOT EXISTREAL("logUDPcounter") THEN
logudpcounter = 0
END
IF NOT EXISTREAL("logUDPcounter2") THEN
logudpcounter2 = 0
END
RETURN
.END
.PROGRAM logw(.$text)
; Wyslanie komunikatu - watek glowny - warrning (pomaranczowy)
$sendlogdata[0] = "L"+$ENCODE(/I2,logudpcounter)+"0W"
$sendlogdata[1] = .$text
CALL sendlog
RETURN
.END
.PROGRAM logwobj(.i)
; Wysylanie komunikatu - watek glowny - logowanie workObjectu
IF log==1 THEN
DECOMPOSE .x[0] = tabwobj.uframe[.i]
DECOMPOSE .y[0] = tabwobj.oframe[.i]
$sendlogdata[0] = "L"+$ENCODE(/I2,logudpcounter)+"0D"
$sendlogdata[1] = $ENCODE(/I2,"Wobj[",.i,/F10.4,"] = [",tabwobj.robhold[.i],",",tabwobj.ufprog[.i],",",$tabwobj.ufmec[.i],",",.x[0],",",.x[1],",",.x[2],",",.x[3],",",.x[4],",",.x[5],"],[",.y[0],",",.y[1],",",.y[2],",",.y[3],",",.y[4],",",.y[5],"]")
CALL sendlog
END
RETURN
.END
.PROGRAM logzone(.i)
; Wysylanie komunikatu - watek glowny - logowanie Zone
IF log==1 THEN
$sendlogdata[0] = "L"+$ENCODE(/I2,logudpcounter)+"0D"
$sendlogdata[1] = $ENCODE(/I2,"Zone[",.i,/F10.4,"] = [",tabzone.finep[.i],",",tabzone.pzone_t[.i],"]")
CALL sendlog
END
RETURN
.END
.PROGRAM lubricateshunk()
;raz dziennie powinienem przejechac shunkiem przez caly zakres ruchu zeby go naoliwic 
;inaczej jesli wykonuje ciagle tylko male ruchy shunk moze sie uszkodzic przez nadmierne tarcie 
;bede wysylal 5 parametrow i komenda ruchu = 176
BITS 81,8 = 5
BITS 89,8 = 176
;przejedz na maksymalna pozycje - taka z jaka chwytam najwiekszy pakiet
width = (jawwidth[5]+90)
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
;przejedz na minimalna pozycje zerowa
BITS 81+16,16 = 0
BITS 81+16+8,16 = 0
TWAIT 0.5
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
;powrot do pozycji, ktorej uzywam obecnie - zeby zlapac pakiet ktory stoi w ateq 
IF type<5 THEN
width = (jawwidth[type]+110)
ELSE
width = (jawwidth[type]+70)
END
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
TWAIT 0.2
SIGNAL waitforshunkmov
WAIT (-waitforshunkmov)
.END
.PROGRAM mml()
SPEED mmlsppd
ACCURACY fastacu
JMOVE wait_test
.END
.PROGRAM mov()
BITS 81,8 = 5
BITS 81+8,8 = 176
BITS 81+24,8 = pos
.END
.PROGRAM move2ateq()
;przejazd z #safeT do miejsca przed ateq - powrot gdy zmienialem cos na tr3 
JMOVE #safet;juz powinien tam byc 
SPEED spd MM/S ALWAYS
JMOVE #safe90
JMOVE #before_ateqr
TOOL small_gripper
LMOVE wait_ateq
LMOVE wait_test
SPEED ateqspd MM/S ALWAYS
RETURN
.END
.PROGRAM move2safe()
;przejazd z przed ateq do safe - gdy bede cos robil na tr3 podczas trwania testu ateq
SIGNAL -fpositionnextat  ;bede zmienial cos na tr3 - nie ma mnie juz przed ATEQ 
LMOVE wait_ateq
SPEED spd MM/S ALWAYS
LMOVE #before_ateqr
JMOVE #safe90
TOOL big_gripper
JMOVE #safet
.END
.PROGRAM moveoutfullpale()
;wysuniecie calej palety		
CALL putspacer;ustwaienie przekladki
SIGNAL spacerputted[2]
;skoro to 2 warstwa to wyjazd - calosc jest gotowa 
JMOVE #safet
;czekaj az ktos odbierze poprzednia palete z wyminnikami - normalnie nie powinno wystapic
WHILE SIG(sensorfront[3]) DO
SIGNAL -getpaletteblink ;wylaczenie migania -zaraz wlacze na stale
TWAIT 0.2
SIGNAL getpalette
CALL allowentrance
;SIGNAL TrReady[3]
END
SIGNAL -getpalette
IF SIG(sensorback[3]) THEN ;jesli cos nadal stoi na tr3 to to wypchnij 
SIGNAL trready[3]
WAIT SIG(sensorfront[3]) ;wystaw sygnal i czekaj az dojedzie do konca
SIGNAL -trready[3]
WHILE SIG(sensorfront[3]) DO
SIGNAL -getpaletteblink
TWAIT 0.2
SIGNAL getpalette
CALL allowentrance;dopoki cos stoi na przodzie tr3 czekaj az ktos odbierze pelna palete
END
SIGNAL -getpalette
END
CALL putpalette
JMOVE #safet
.END
.PROGRAM odkladanie()
POINT mmltempbase = BASE
POINT mmltemptool = TOOL
TOOL small_gripper
BASE NULL
JMOVE #before_ateqr
BREAK
HERE mmltemppoint
;INIT I/O
;IN
transporterread = 1001
;OUT
packageontransp = 4
;INITED
IF (TRUE) THEN
;sciezka ruchu do pozycji odlozenie
SPEED 400 MM/S
ACCURACY fastacu
;	LMOVE  mmlTempPoint + TRANS(0, -300, -200)
SPEED mmlsppd
ACCURACY fastacu
JMOVE #safe90
SPEED mmlsppd
ACCURACY fastacu
JMOVE #mmlpodajnik
;nad pozycja odlozenia
SPEED mmlsppd
ACCURACY fastacu
JMOVE mmlpodajnik+TRANS(0,0,-200)
BREAK
;odlozenie na podajnik
WAIT SIG(transporterread)
SPEED supslow MM/S
ACCURACY 1
LMOVE mmlpodajnik
BREAK
POINT putpackage = mmlpodajnik
;------------------------------------CYKL ODKLADANIA (SZCZEKI)
TWAIT (0.5)
SIGNAL -closefingers
SIGNAL openfingers
WAIT SIG(-leftfingerc,-rightfingerc,leftfingero,rightfingero)
SPEED slow MM/S ALWAYS
LAPPRO putpackage,20
BREAK
SPEED supslow MM/S ALWAYS
ACCURACY supacu ALWAYS
LMOVE putpackage
LAPPRO putpackage,-20   ;zjazd w dol - zeby pakiet nie byl na szczekach
SPEED slow MM/S ALWAYS
ACCURACY acu ALWAYS
BREAK
IF type<>2 AND type<>5 THEN
width = (jawwidth[type]+120)  ;rozsuniecie szczek
ELSE
width = (jawwidth[type]+100)
END
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
;------------------------------------PAKIET ODLOZONY
;nad pozycje odlozenia - daj sygnal
SPEED supslow MM/S
ACCURACY fastacu
LMOVE mmlpodajnik+TRANS(0,0,-200)
BREAK
PULSE packageontransp,1
;powrot do safety
SPEED mmlsppd
ACCURACY fastacu
JMOVE #mmlpodajnik
SPEED mmlsppd
ACCURACY fastacu
JMOVE #safe90
BASE mmltempbase
TOOL mmltemptool
END
.END
.PROGRAM openjaws()
;otwieranie szczek do chwycenia pakietu
PAUSE
;BITS 81, 8 = 5		;ile bitow
;BITS 81+8, 8 = 176	; kod komendy ruchu
;BITS 81+16+8, 16 = width	;width podane chwile wczesniej
PAUSE
.END
.PROGRAM openschunkfimge()
SIGNAL -closefingers
SIGNAL openfingers
TIMER (1) = 0
WAIT SIG(-leftfingerc,-rightfingerc,leftfingero,rightfingero) OR TIMER(1)>5
IF NOT SIG(-leftfingerc,-rightfingerc,leftfingero,rightfingero) THEN
PRINT "Przekroczona czas otwierania palcow na schunku."
PRINT "-leftfingerc =",SIG(-leftfingerc)
PRINT "-rightfingerc =",SIG(-rightfingerc)
PRINT "leftfingero =",SIG(leftfingero)
PRINT "rightfingero =",SIG(rightfingero)
HOLD.STEP ON
END
.END
.PROGRAM pg0()
;###############################################################################
;#   Prpgram glowny obslugujacy stanowisko kontroli szczelnosci pakietow nPG
;###############################################################################
PRINT "START: pg0()"
;jesli jest przelacznik to jedz z tej pozycji do domu (potem jeszcze haslo sprawdza)
IF SIG(allowrobmove) THEN
PRINT "   CALL pg2"
CALL pg2
END
SIGNAL -initok ;natychmiast po starcie zgas sygnal ze jestem gotow 
CALL datainit
;WAIT SIG(doNext)
;SIGNAL -doNext
CALL gosafe;w pliku safe.pg
;WAIT SIG(doNext)	;to zmienic !!!! jaki sygnal od leszka dostane ze mam ruszac ??? 
;SIGNAL -doNext		;nic nie dostane, czekac na sygnal ze przyjechal pakiet 
IF SIG(errornogripper) OR SIG(errorateq) OR SIG(errortr3full) OR SIG(errorstuck) OR SIG(errorholdinghea) OR SIG(errorshunkfail) OR SIG(errorpalettesen) OR SIG(errorateqsensor) THEN
IF SIG(errornogripper) THEN
PRINT "! ! ! errornogripper ! ! !"
END
IF SIG(errorateq) THEN
PRINT "! ! ! errorateq ! ! !"
END
IF SIG(errortr3full) THEN
PRINT "! ! ! errortr3full ! ! !"
END
IF SIG(errorstuck) THEN
PRINT "! ! ! errorstuck ! ! !"
END
IF SIG(errorholdinghea) THEN
PRINT "! ! ! errorholdinghea ! ! !"
END
IF SIG(errorshunkfail) THEN
PRINT "! ! ! errorshunkfail ! ! !"
END
IF SIG(errorpalettesen) THEN
PRINT "! ! ! errorpalettesen ! ! !"
END
IF SIG(errorateqsensor) THEN
PRINT "! ! ! errorateqsensor ! ! !"
END
SIGNAL initok
PRINT "    WHILE SIG(initok) DO"
WHILE SIG(initok) DO
;bedzie sie petlil w niskonczonosc - jesli pojawily sie errory to operator musi zatrzymac linie
;usunac errory i wlaczyc inicjalizacje jeszcze raz 
CALL allowentrance
TWAIT 1
END
PRINT "    END WHILE"
END
;zezwalam na prace transporterow w automacie 
SIGNAL -stoptransporter[1]
SIGNAL -stoptransporter[2]
mainloop = TRUE
WHILE mainloop DO
IF firstcycle THEN
PRINT "   FirstCycle"
CALL conveyors;jak tylko mnie wlacza to przygotuj juz sobie miejsce 
;first cycle gaszone w recievie - zeby nie wyjezdzac pusta paleta
SIGNAL initok ;sygnal mowi leszkowi, ze skonczylem init, 
;jesli wszsytko ok to czekam na syg o pakiecie a jak sa bledy to mnie zrestartuja				
TWAIT 1
;WAIT SWITCH(CS)	;koniec procedury inicjalizacji - czzekam na sygnal od PLC ze rusza linia 
;WAIT SWITCH(CS)	;koniec procedury inicjalizacji - czzekam na sygnal od PLC ze rusza linia 
END
PRINT "   CYKL........................................"
PRINT "   CALL receive"
CALL receive;odebranie danych na temat nastepnego pakietu od PLC
PRINT "   CALL checktypspacers"
CALL checktypspacers; jesli jest nowy typ wymiennika i nie ma przekladek to wola o przekladki
PRINT "   CALL pickandgo"
CALL pickandgo; pobranie pakietu i wstawienie go to ATEQa
PRINT "   CALL ateq"
CALL ateq; wystawianie sygnalow dla ATEQa
PRINT "   CALL put"
CALL put; pobranie pakietu z ATEQa i na bazie info OK/NOK odstawienie go na palete badz tacke
PRINT "   ........................................CYKL"
END
PRINT "END: pg0()"
.END
.PROGRAM pg1()
;ObjectNotIn[1]=2010 - brak kasetki wiec przycisk symulowany z i/f
;ObjectNotIn[2]=2011 - brak kasetki wiec przycisk symulowany z i/f
;moveObject[1]=2012 - podtrzymanie sygnalu ObjectNotIn[1]
;moveObject[2]=2013 - podtrzymanie sygnalu ObjectNotIn[2]
;moveObject[3]=2014 - podtrzymanie ruchu transportera
;przeuczone punkty dla tool null
;point get_grip
;point #over_conveyors
;point #over_lift
;point pick_palette
;point pick_spacer
;point put_palette
;point put_spacer
;point pick_heatEx
;point #before_ateq
;point wait_ateq
;point ateq
;point #safe
;point #midway
;===========podnoszenie chwytaka i jezdzenie do palet============
BASE NULL
TOOL big_gripper
SIGNAL -openfingers
WAIT SIG(leftfingerc,rightfingerc,-leftfingero,-rightfingero)
SIGNAL leavepalette
WAIT SIG(palettegrippero,-palettegripperc)
SIGNAL leavegripper
WAIT SIG(leftgripper,-havegripper)
SIGNAL -connectoron
JMOVE #safe
LAPPRO get_grip,1000
LMOVE get_grip
SIGNAL connectoron
SIGNAL -leavegripper
WAIT SIG(leftgripper,-havegripper)
;jak bedzie podlaczony czujnik z lusterkiem na chwytaku to daj
;WAIT SIG(LeftGripper,-HaveGripper,PaletteDetect)
;moze trzeba bedzie dac -PaletteDetect nie pamietam jaka jest logika na czujniku
PAUSE
LAPPRO get_grip,1000
PAUSE
JAPPRO pick_palette,500
LMOVE pick_palette
LAPPRO pick_palette,500
JAPPRO put_palette,500
LMOVE put_palette
LAPPRO put_palette,500
JAPPRO pick_spacer,500
LMOVE pick_spacer
LAPPRO pick_spacer,500
JAPPRO put_spacer,300
LMOVE put_spacer
LAPPRO put_spacer,300
LAPPRO get_grip,1000
LMOVE get_grip
SIGNAL -connectoron
SIGNAL leavegripper
LAPPRO get_grip,1000
;==============przenoszenie pakietu==============
JMOVE #safe
JMOVE #over_conveyors
JMOVE #over_lift
LAPPRO pick_heatex,500
LMOVE pick_heatex
LAPPRO pick_heatex,500
LMOVE #midway
LMOVE #before_ateq
LMOVE wait_ateq
LMOVE ateq
PAUSE
LMOVE wait_ateq
LMOVE #before_ateq
LMOVE #midway
JMOVE #over_lift
JMOVE #over_conveyors
JMOVE #safe
.END
.PROGRAM pg2()
;jesli jest haslo to jedz dalej
IF move_pass==2315 THEN
move_pass = 0
CALL returntosafe
END
.END
.PROGRAM pg96()
PAUSE
CALL datainit
loop = TRUE
CALL conveyors
WHILE loop DO
CALL recieve
CALL coveyors
JMOVE #safet
JMOVE #safe90
TOOL small_gripper
LAPPRO test_pick,500+160*0
;otwarcie shunka
IF type<>5 AND type<>4 THEN
width = (jawwidth[type]+120)
ELSE
width = (jawwidth[type]+90) ;jesli to te najwieksze wymienniki to nie moge sie bardziej rozsunac bo wypadne z prowadnic
END
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
LAPPRO test_pick,150+160*0
SPEED slow MM/S
END
.END
.PROGRAM pg97()
toateq = TRUE
SPEED slow MM/S ALWAYS
JMOVE #safet
JMOVE next_conveyors
LMOVE #before_heatex
TOOL small_gripper
SIGNAL openfingers   ;otwieram chwytak do pakietow
WAIT SIG(-leftfingerc,-rightfingerc,leftfingero,rightfingero)
;---------tutaj otwarcie szczek do pakietow 
POINT pick_heatexch = SHIFT(pick_heatex BY 0,0,-(410-pacheight[type])) ;zteachowany jest punkt pick_heatEx 
;jest to punkt dla pakietu o wysokosci 410 
JAPPRO pick_heatexch,300
SPEED slow MM/S ALWAYS
width = (jwidth+80)
BITS 81+16,16 = 0
BITS 81+16+8,16 = width ;jWidth podawane z teachpendanta
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
LMOVE pick_heatexch
TWAIT (0.5)
width = jwidth
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
LAPPRO pick_heatexch,20
TWAIT (0.5)
SIGNAL (-openfingers)
WAIT SIG(leftfingerc,rightfingerc,-leftfingero,-rightfingero)
;BREAK ;chwytak do pakietow powinien byc zamkniety
LAPPRO pick_heatexch,400   ; mam chwycony pakiet
SIGNAL packagetaken
;##########chwycony pakiet######3
SPEED spd MM/S ALWAYS
LMOVE #midway
LMOVE #before_ateq
IF toateq THEN
LMOVE wait_ateq
SPEED slow MM/S ALWAYS
LAPPRO ateq,15
TWAIT 0.5 ;jestem w ATEQ - trzeba puscic pakiet
LMOVE ateq
TWAIT 0.5
SIGNAL openfingers
WAIT SIG(-leftfingerc,-rightfingerc,leftfingero,rightfingero)
LAPPRO ateq,-20
width = (jwidth+70)
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
POINT wait_test = ateq+TRANS(0,-500)
LMOVE wait_test
SIGNAL packageinateq
SIGNAL -packagetaken
TWAIT 1
LAPPRO ateq,-20
TWAIT (0.5)
LAPPRO ateq,-underateq[type]    ;jestem w ATEQ - trzeba pobrac pakiet
TWAIT 0.5
;BREAK
width = jwidth
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
;TWAIT(3)
LMOVE ateq
TWAIT (0.5)
LAPPRO ateq,15
TWAIT (0.5)
SIGNAL -openfingers
WAIT SIG(leftfingerc,rightfingerc,-leftfingero,-rightfingero)
LMOVE wait_ateq
END
;po ateq - jedziemy na palete
LMOVE #before_ateq
JMOVE #safe90
JMOVE #before_put
POINT putpackage = SHIFT(init_put[type] BY -xdist[type]*(colcount-1),-ydist[type]*(rowcount-1),(pacheight[type]+spacerthicknes)*(layercount-1))
JAPPRO putpackage,(pacheight[type]+50)
SPEED slow MM/S ALWAYS
LMOVE putpackage
TWAIT (0.5)
SIGNAL openfingers
WAIT SIG(-leftfingerc,-rightfingerc,leftfingero,rightfingero)
LAPPRO putpackage,-10   ;zjazd w dol - zeby pakiet nie byl na szczekach
width = (jwidth+80)  ;rozsuniecie szczek
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
;TWAIT(3)
LAPPRO putpackage,pacheight[type]+50 ;odjazd w gore 
SPEED spd MM/S ALWAYS
colcount = colcount+1
IF colcount>maxcolcount[type] THEN
colcount = 1
rowcount = rowcount+1
IF rowcount>maxrowcount[type] THEN
rowcount = 1
SIGNAL layerfull[layercount]
IF layercount<2 THEN
;poloz przekladke i pracuj nad druga warstwa
TOOL big_gripper
CALL putspacer
SIGNAL spacerputted[1]
;JMOVE #safeT
CALL putoutgripper;odlozenie chwytaka
gotobp = FALSE ;go to before put
ELSE
JMOVE #safet
TOOL big_gripper
CALL moveoutfullpale
END
;layerCount = layerCount + 1
END
END
SIGNAL packageonpalett
IF gotobp THEN
JMOVE #before_put
END
gotobp = TRUE
TOOL big_gripper
JMOVE #safet
.END
.PROGRAM pg98()
JMOVE #safet
JMOVE #over_gripper
SIGNAL (-openfingers)     ;zamykanie chwytaka do podoszenia pakietow
WAIT SIG(leftfingerc,rightfingerc,-leftfingero,-rightfingero)
SIGNAL -leavepalette
WAIT SIG(-palettegrippero,palettegripperc)
LMOVE inside_grip
SIGNAL leavepalette      ;rozsuniecie chwytaka palet - chwytak pobierany jest w poz otwartej
WAIT SIG(palettegrippero,-palettegripperc)
SIGNAL leavegripper      ; zeby podjazd po chwytak byl z zamknietym bolcem
WAIT SIG(leftgripper,-havegripper)
SIGNAL -connectoron
LMOVE get_grip
TWAIT (1)
SIGNAL connectoron
SIGNAL -leavegripper     ;mam chwytak do palet
WAIT SIG(havegripper,-leftgripper)
;LAPPRO get_grip, 1000					;odjazd nad pobranie chwytaka
LMOVE #over_gripper
JMOVE #safet
JAPPRO pick_palette,1000
LMOVE pick_palette
LAPPRO pick_palette,1000
JAPPRO pick_spacer,1000
LMOVE pick_spacer
LAPPRO pick_spacer,1000
JAPPRO put_palette,1000
LMOVE put_palette
LMOVE put_spacer
LAPPRO put_spacer,1000
JMOVE #over_gripper
LMOVE get_grip
TWAIT (1)
SIGNAL -connectoron
SIGNAL leavegripper
WAIT SIG(-havegripper,leftgripper)
LMOVE inside_grip
SIGNAL -leavepalette
WAIT SIG(-palettegrippero,palettegripperc)
;LAPPRO get_grip, 1000
LMOVE #over_gripper
JMOVE #safet
.END
.PROGRAM pg99()
JMOVE #safe
PAUSE
POINT safe1 = HERE
POINT safe1 = safe1+RZ(180)
BREAK
LMOVE safe1
PAUSE
POINT #safet = HERE
.END
.PROGRAM pg999()
JOINT SPEED9 ACCU1 TIMER0 TOOL1 WORK0 CLAMP1 (OFF,0,0,O) 2 (OFF,0,0,O) 3 (OFF,0,0,O) OX= WX= #[85.448,15.083,-22.389,271.71,0,0] ;
JOINT SPEED9 ACCU1 TIMER0 TOOL1 WORK0 CLAMP1 (OFF,0,0,O) 2 (OFF,0,0,O) 3 (OFF,0,0,O) OX= WX= #[85.448,15.083,-22.389,181.04,0,0] ;
JOINT SPEED9 ACCU1 TIMER0 TOOL1 WORK0 CLAMP1 (OFF,0,0,O) 2 (OFF,0,0,O) 3 (OFF,0,0,O) OX= WX= #[85.448,15.083,-22.389,272.12,0,0] ;
JOINT SPEED9 ACCU1 TIMER0 TOOL1 WORK0 CLAMP1 (OFF,0,0,O) 2 (OFF,0,0,O) 3 (OFF,0,0,O) OX= WX= #[85.448,-22.319,-22.389,272.12,0,0] ;
JOINT SPEED9 ACCU1 TIMER0 TOOL1 WORK0 CLAMP1 (OFF,0,0,O) 2 (OFF,0,0,O) 3 (OFF,0,0,O) OX= WX= #[85.448,15.487,-22.389,272.12,0,0] ;
JOINT SPEED9 ACCU1 TIMER0 TOOL1 WORK0 CLAMP1 (OFF,0,0,O) 2 (OFF,0,0,O) 3 (OFF,0,0,O) OX= WX= #[85.448,15.487,0.49721,272.12,0,0] ;
JOINT SPEED9 ACCU1 TIMER0 TOOL1 WORK0 CLAMP1 (OFF,0,0,O) 2 (OFF,0,0,O) 3 (OFF,0,0,O) OX= WX= #[85.448,15.487,-23.938,272.12,0,0] ;
JOINT SPEED9 ACCU1 TIMER0 TOOL1 WORK0 CLAMP1 (OFF,0,0,O) 2 (OFF,0,0,O) 3 (OFF,0,0,O) OX= WX= #[85.448,15.487,-16.099,272.12,0,0] ;
JOINT SPEED9 ACCU1 TIMER0 TOOL1 WORK0 CLAMP1 (OFF,0,0,O) 2 (OFF,0,0,O) 3 (OFF,0,0,O) OX= WX= #[83.482,-21.595,-5.8319,274.09,0,0] ;
JOINT SPEED9 ACCU1 TIMER0 TOOL1 WORK0 CLAMP1 (OFF,0,0,O) 2 (OFF,0,0,O) 3 (OFF,0,0,O) OX= WX= #[2.3273,-21.595,-5.8319,274.08,0,0] ;
JOINT SPEED9 ACCU1 TIMER0 TOOL1 WORK0 CLAMP1 (OFF,0,0,O) 2 (OFF,0,0,O) 3 (OFF,0,0,O) OX= WX= #[83.565,-21.595,-5.8319,274.08,0,0] ;
JOINT SPEED9 ACCU1 TIMER0 TOOL1 WORK0 CLAMP1 (OFF,0,0,O) 2 (OFF,0,0,O) 3 (OFF,0,0,O) OX= WX= #[86.82,5.5032,-5.8319,274.08,0,0] ;
.END
.PROGRAM pickandgo()
PRINT "START: pickandgo()"
;pojechanie po pakiet i wstawienie go do ateq 
;noHeatExError = true
;WHILE noHeatExError 
JMOVE #safet
IF SIG(havegripper,-leftgripper) THEN ;nie moge jechac w te rejony z chwytakiem 
;jesli trzymam chwytak to jade go odstawic 
CALL putoutgripper
END
SIGNAL -leavepalette  ;jezdzimy z zamknietymi szczekami do lapania palet (silownik schowany)
SIGNAL grabpalette
PRINT "   WAIT SIG(-palettegrippero,palettegripperc)"
WAIT SIG(-palettegrippero,palettegripperc)
PRINT "   WAIT OK"
SPEED fastspd
ACCURACY fastacu
PRINT "   JMOVE next_conveyors"
JMOVE next_conveyors
SPEED fastspd
ACCURACY fastacu
PRINT "   LMOVE #before_heatex"
LMOVE #before_heatex;obrot miedzy winda a ateq - specjalnie spowolniony 
SPEED deg ALWAYS
;ZMIANA TOOLA !! 
PRINT "   TOOL small_gripper"
TOOL small_gripper
SIGNAL -closefingers
SIGNAL openfingers   ;otwieram chwytak do pakietow
PRINT "   WAIT SIG(-leftfingerc,-rightfingerc,leftfingero,rightfingero)"
WAIT SIG(-leftfingerc,-rightfingerc,leftfingero,rightfingero)
PRINT "   WAIT OK"
;zapisany jest punkt pick_heatEx 
;jest to punkt dla pakietu o min wysokosci
POINT pick_heatexch = SHIFT(pick_heatex BY 0,0,pacheight[type]-minpacheight+pickcorrection[type])
POINT before_heatexpi = pick_heatexch+TRANS(0,-350) ;punkt do wyjazdu z miejsca podniesienia pakietu 
SPEED fastspd
ACCURACY fastacu
LAPPRO before_heatexpi,-20
SPEED slow MM/S ALWAYS
;otwarcie szczek zeby zlapac pakiet 
;zwiekszylem rozwarcie szczek o 25 mm aby swobodniej pobierac pakiet ze skrzyzowania
IF type<>5 AND type<>4 THEN
width = (jawwidth[type]+220)
ELSE
;jesli to te najwieksze wymienniki to nie moge sie bardziej rozsunac bo wypadne z prowadnic
width = (jawwidth[type]+190)
END
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
BREAK
TWAIT (0.2)
BREAK
SIGNAL waitforshunkmov
PRINT "   WAIT SIG(-waitforshunkmov)"
WAIT SIG(-waitforshunkmov)
PRINT "   WAIT OK"
LAPPRO pick_heatexch,-20
BREAK
LMOVE pick_heatexch;podjazd po wymiennik 
BREAK
;WAIT SIG(doNext)	;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
;SIGNAL -doNext
;IF SIG(-HeatExInGripper) THEN 	;jednak nie ma pakietu 
IF SIG(-heatexingripper) THEN  ;jednak nie ma pakietu 
;nie ma co zlapac !! odjazd z powrotem do safeT
LMOVE before_heatexpi
SIGNAL errornoheatex
SPEED spd MM/S ALWAYS
LMOVE #midway
LMOVE SHIFT(next_conveyors BY 0,-150,-200)+RZ(-300)
JMOVE #safe90
JMOVE #safet
PRINT "   TOOL big_gripper"
TOOL big_gripper
;error nie ma pakietu choc byl sygnal packageWaits
;noHeatExError = true
;WAIT SIG(ErrorConfHold) ;czekam az ktos potwierdzi error
;i jeszcze raz czekam na sygnal o tym, ze przyjechal pakiet 
;CALL receive
WHILE SIG(errornoheatex) DO ;nieskonczona petla  
SIGNAL errornoheatex
END
END
;ELSE
;jesli za pierwszym razem nic nie znalazlem a teraz juz cos jest to zgas error 
;	noHeatExError = false
;END
;END
;wykrylem pakiet 
;zamkniecie szczek do pakietow zgodnie z typem pakietu
TWAIT (0.05)
width = jawwidth[type]
BITS 81+16,16 = 0
BITS 81+16+8,16 = width-20  ;zacisniecie shunka za mocno - odpowie Move Blocked
TWAIT (0.2)
SIGNAL waitforshunkmov
PRINT "   WAIT SIG(-waitforshunkmov)"
WAIT SIG(-waitforshunkmov)
PRINT "   WAIT OK"
BREAK
TWAIT (0.2)
BREAK
LAPPRO pick_heatexch,20
BREAK
;cShunkPos = BITS(1201,16)	;stary nr bitu przed dodaniem kolejnego modulu wago - moze sie przyda 
cshunkpos = BITS(1265,16) ;current Shunk Position odczytanie na jakiej pozycji stanal shunk
;poluzowanie uchwytu schunka aby pakiet opadl na "polki" szczek
BITS 81+16,16 = 0
BITS 81+16+8,16 = cshunkpos+8  ;rozwarcie szczek aby pakiet opadl na "polki" szczek
SIGNAL waitforshunkmov
PRINT "   WAIT SIG(-waitforshunkmov)"
WAIT SIG(-waitforshunkmov)
PRINT "   WAIT OK"
BREAK
TWAIT 0.5
BREAK
;zacisniecie szczek
BITS 81+16,16 = 0
BITS 81+16+8,16 = width-20  ;zacisniecie shunka za mocno - odpowie Move Blocked
TWAIT (0.2)
SIGNAL waitforshunkmov
PRINT "   WAIT SIG(-waitforshunkmov)"
WAIT SIG(-waitforshunkmov)
PRINT "   WAIT OK"
BREAK
TWAIT 0.5
BREAK
;cShunkPos = BITS(1201,16)	;stary nr bitu przed dodaniem kolejnego modulu wago - moze ssie przyda 
cshunkpos = BITS(1265,16) ;current Shunk Position odczytanie na jakiej pozycji stanal shunk
BITS 81+16,16 = 0
BITS 81+16+8,16 = cshunkpos+3  ;lekkie rozwarcie szczek - pakiet nie spadnie a shunk bedzie "na pozycji"
TWAIT (0.2)
SIGNAL waitforshunkmov
PRINT "   WAIT SIG(-waitforshunkmov)"
WAIT SIG(-waitforshunkmov)
PRINT "   WAIT OK"
LAPPRO pick_heatexch,40
BREAK
SIGNAL closefingers
SIGNAL (-openfingers)
PRINT "WAIT SIG(leftfingerc,rightfingerc,-leftfingero,-rightfingero)"
WAIT SIG(leftfingerc,rightfingerc,-leftfingero,-rightfingero)
PRINT "WAIT OK"
;mam chwycony pakiet
LAPPRO before_heatexpi,40
SIGNAL heatextaken
SPEED spd MM/S ALWAYS
LMOVE #midway
LMOVE SHIFT(next_conveyors BY 0,-150,-200)+RZ(-300)
LMOVE #before_ateqr
LMOVE wait_ateq
SPEED ateqspd MM/S ALWAYS
;stoje przed ateq
;sprawdzenie czy korekty pozycji pakietow w ATEQ nie sa zbyt duze
CALL checkateqcor
;wprowadzenie korekty odlozenia pakietu w ATEQ'u
POINT ateq = SHIFT(ateqorg BY ateqcorx[type],ateqcory[type])
;przygotowanie ateq- odjazd na sama gore i zgaszenie wszystkich sygnalow 
CALL prepareateq
;POINT ateqS = SHIFT(ateq BY ateqShift[type])
IF mnitest THEN
;wstawianie do ATEQ'a po malborsku (by MNI)
LAPPRO ateq,22
BREAK
TWAIT 1;jestem w ATEQ - trzeba puscic pakiet
SPEED supslow2 MM/S ALWAYS
ACCURACY supacu ALWAYS
BREAK
TWAIT 0.05
LMOVE ateq
BREAK
TWAIT 0.2
ELSE
;oryginalne wstawianie do ATEQ'a
LAPPRO ateq,20
TWAIT 0.5 ;jestem w ATEQ - trzeba puscic pakiet
SPEED supslow MM/S ALWAYS
ACCURACY supacu ALWAYS
BREAK
LMOVE ateq
TWAIT 0.5
END
SIGNAL -closefingers
SIGNAL openfingers
PRINT "   WAIT SIG(-leftfingerc,-rightfingerc,leftfingero,rightfingero)"
WAIT SIG(-leftfingerc,-rightfingerc,leftfingero,rightfingero)
PRINT "   WAIT OK"
;zjazd w dol zeby pakiet stanal na gumie a nie wisial oparty na szczekach shunka 
LAPPRO ateq,-5
BREAK
TWAIT 0.2
BREAK
;WAIT SIG(doNext)	;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
;SIGNAL -doNext
SPEED ateqspd MM/S ALWAYS
ACCURACY acu ALWAYS
BREAK
;otwarcie szczek 
IF type<5 THEN
width = (jawwidth[type]+110)
ELSE
width = (jawwidth[type]+70)
END
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
TWAIT (0.2)
SIGNAL waitforshunkmov
PRINT "   WAIT SIG(-waitforshunkmov)"
WAIT SIG(-waitforshunkmov)
PRINT "   WAIT OK"
LAPPRO ateq,-25
BREAK
;jestem w ateq, postawilem i puscilem pakiet 
;WAIT SIG(doNext)	;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
;SIGNAL -doNext
;wyjazd prosto w tyl - zeby nie uderzyc w sciane ateq 
POINT wait_test = ateq+TRANS(0,-500)
SPEED spd MM/S
LMOVE wait_test
BREAK
IF SIG(heatexingripper) OR SIG(-heatexinateq) THEN
;jesli nadal widze sygnal o tym, ze trzymam pakiet lub gdy nie zapalil sie czujnik z ateq
;to znaczy ze ktorys czujnik sie zepsul lub zabrudzil 
IF SIG(heatexingripper) THEN
SIGNAL errorheatexsens
END
IF SIG(-heatexinateq) THEN
SIGNAL errorateqsensor
END
;odjazd do safeT 
SPEED spd MM/S ALWAYS
PRINT "   TOOL big_gripper"
TOOL big_gripper
LMOVE #before_ateqr
JMOVE #safe90
JMOVE #safet
;wchodze w petle i czekam w nieskonczonosc - ktos i tak musi wejsc w strefe pracy robota ->
;-> bedzie reset calego stanowiska 
WHILE SIG(errorheatexsens) OR SIG(-heatexinateq) DO
IF SIG(heatexingripper) THEN
SIGNAL errorheatexsens
END
IF SIG(-heatexinateq) THEN
SIGNAL errorateqsensor
END
END
END
PRINT "END: pickandgo()"
RETURN
.END
.PROGRAM pickex()
;"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
CP ON
SPEED spd ALWAYS
ACCEL acc ALWAYS
DECEL acc ALWAYS
ACCURACY acu ALWAYS
JMOVE #new
$zone = "Safe"
$task = "PickEx"
PRINT $task
.n = 0
WHILE SIG(new+.n) DO
.n = .n+1
IF .n>3 THEN
.n = 0
END
END
;TWAIT 3
ACCURACY high ALWAYS
POINT pickpoint = new+TRANS(0,-(.n)*newdim)
SIGNAL -gripper
WAIT SIG(-gc,go)
LAPPRO pickpoint+RZ(pickangle),newappro
LAPPRO pickpoint+RZ(pickangle),10
SPEED slow MM/S
$zone = "New"
PRINT $zone
LAPPRO pickpoint+RZ(pickangle),0
BREAK
TWAIT 0.5
SIGNAL gripper
WAIT SIG(gc,-go)
SPEED slow ALWAYS
SPEED slow MM/S
LAPPRO pickpoint+RZ(pickangle),10
LAPPRO pickpoint+RZ(pickangle),newappro
$zone = "Safe"
PRINT $zone
ACCURACY acu ALWAYS
JMOVE #new
BREAK
RETURN
.END
.PROGRAM pickgripper()
;"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
CP ON
SPEED spd ALWAYS
ACCEL acc ALWAYS
DECEL acc ALWAYS
ACCURACY acu ALWAYS
JMOVE #pajak
$task = "PickGripper"
PRINT $task
LAPPRO pajak,lifth
ACCURACY high ALWAYS
SIGNAL unlock
SIGNAL close
WAIT SIG(-opened,closed)
WAIT SIG(-locked,unlocked)
;"dodac sprawdzanie czujnikow czy na pewno NIE mam pajaka w reku"
SPEED slow
LAPPRO pajak,pickh
BREAK
SIGNAL open
WAIT SIG(opened,-closed)
SPEED slow MM/S
LMOVE pajak
BREAK
SIGNAL lock
WAIT SIG(locked,-unlocked)
SPEED slow MM/S
LAPPRO pajak,pickh
ACCURACY acu ALWAYS
SPEED slow
LAPPRO pajak,lifth
JMOVE #pajak
JMOVE #store
RETURN
.END
.PROGRAM picknplace()
WHILE TRUE DO
CALL pickex
CALL placeex
END
.END
.PROGRAM pickpal(.nr)
;"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
SPEED spd ALWAYS
ACCEL acc ALWAYS
DECEL acc ALWAYS
ACCURACY acu ALWAYS
SIGNAL open
WAIT SIG(opened,-closed)
POINT pickpal = pickpal+center
LAPPRO pickpal,storeh
$task = "PickPal"
PRINT $task
LAPPRO pickpal,(.nr-1)*palh
BREAK
SPEED medium ALWAYS
ACCEL medium ALWAYS
DECEL medium ALWAYS
ACCURACY acu ALWAYS
SIGNAL close
WAIT SIG(closed,-opened)
ACCURACY high
SPEED slow MM/S
LAPPRO pickpal,(.nr-1)*palh+palappro
ACCURACY acu
LAPPRO pickpal,storeh
RETURN
.END
.PROGRAM picktest()
WHILE TRUE DO
CALL pickweight
END
.END
.PROGRAM pickweight()
;"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
CP ON
SPEED spd ALWAYS
ACCEL acc ALWAYS
DECEL acc ALWAYS
ACCURACY acu ALWAYS
$zone = "Safe"
JMOVE #cart
$task = "PickWeight"
PRINT $task
IF weight>=(wrows*wcols) THEN
weight = 0
IF layer==0 THEN
PRINT "KONIEC OBCIAZNIKOW NA WOZKU ! ! !"
IF cartno==1 THEN
SIGNAL emptyl
END
IF cartno==2 THEN
SIGNAL emptyr
END
ELSE
layer = 4;Layer - 1
END
END
CALL cartsel
wrow = weight MOD wrows
wcol = INT(weight/wcols)
POINT weight = cart+TRANS(wrow*79.5,wcol*79.5)+RZ(weightangle)
ACCURACY high ALWAYS
SPEED slow
LAPPRO weight,weightappro
LAPPRO weight,130
SIGNAL -gripper
WAIT SIG(-gc,go)
$zone = "Cart"
PRINT $zone
SPEED slow MM/S
LAPPRO weight,weightpos+layer*weighth
BREAK
TWAIT 0.5
SIGNAL gripper
weight = weight+1
WAIT SIG(gc,-go)
TWAIT 0.5
SPEED slow MM/S
LAPPRO weight,weightpos+(layer+1)*weighth
SPEED slow
LAPPRO weight,weightappro
ACCURACY acu ALWAYS
JMOVE #cart
$zone = "Safe"
PRINT $zone
RETURN
.END
.PROGRAM pickweight2()
;"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
CP ON
SPEED spd ALWAYS
ACCEL acc ALWAYS
DECEL acc ALWAYS
ACCURACY acu ALWAYS
BASE global
TOOL schunk
JMOVE #pajak
JMOVE #new
.n = 0
WHILE SIG(-(new+.n)) DO
.n = .n+1
IF .n>3 THEN
.n = 0
END
END
POINT pickpoint = new+TRANS(.n*newdim,0,-hath)
LAPPRO pickpoint+TRANS(0,-200,0)+RZ(pickangle),100
SIGNAL go
LAPPRO pickpoint+RZ(pickangle),100
LAPPRO pickpoint+RZ(pickangle),10
SPEED slow MM/S
LAPPRO pickpoint+RZ(pickangle),0
BREAK
TWAIT 0.5
SIGNAL gc
SPEED slow ALWAYS
SPEED slow MM/S
LAPPRO pickpoint+RZ(pickangle),10
LAPPRO pickpoint+RZ(pickangle),100
LAPPRO pickpoint+TRANS(0,-100,0)+RZ(pickangle),100
JMOVE #new
JMOVE #pajak
.END
.PROGRAM placeex()
;"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
CP ON
SPEED slow ALWAYS
ACCEL acc ALWAYS
DECEL acc ALWAYS
ACCURACY acu ALWAYS
JMOVE #placeex
$zone = "Safe"
ACCURACY high ALWAYS
$task = "PlaceEx"
PRINT $task
poscalc:
row = explaced MOD 9
col = INT(explaced/9)
IF ((row MOD 4)==0) AND ((col MOD 4)==0) AND NOT ((col==4) AND (row==4)) THEN
explaced = explaced+1
GOTO poscalc
END
POINT palmid = pal+TRANS(75/2+row*105,75/2+col*105,-pal*palh)+RZ(placeangle)
;"POZYCJA PALETKI OD NOWEGO PUNKTU SKANOWANIA WENGLOREM (70.75, -70.75)"
PRINT "Laduje wymiennik #",explaced," X: ",row," Y: ",col
LAPPRO palmid,explaceappro+explaceh
LAPPRO palmid,10+explaceh
$zone = "Pal"
PRINT $zone
SPEED slow MM/S
LAPPRO palmid,explaceh
BREAK
TWAIT 0.5
SIGNAL -gripper
explaced = explaced+1
WAIT SIG(-gc,go)
SPEED spd ALWAYS
LAPPRO palmid,explaceappro+explaceh
ACCURACY acu ALWAYS
JMOVE #placeweight
$zone = "Safe"
PRINT $zone
RETURN
.END
.PROGRAM placegripper()
;"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
CP ON
SPEED spd ALWAYS
ACCEL acc ALWAYS
DECEL acc ALWAYS
ACCURACY acu ALWAYS
LMOVE #store
$task = "PlaceGripper"
PRINT $task
JMOVE #pajak
SIGNAL open
WAIT SIG(opened,-closed)
;"dodac sprawdzanie czujnikow czy na pewno mam pajaka w reku"
LAPPRO pajak,lifth
ACCURACY high ALWAYS
SPEED slow
LAPPRO pajak,pickh
SPEED slow MM/S
LMOVE pajak
BREAK
SIGNAL unlock
WAIT SIG(-locked,unlocked)
SPEED slow MM/S
LAPPRO pajak,pickh
BREAK
SIGNAL close
WAIT SIG(-opened,closed)
ACCURACY acu ALWAYS
SPEED slow
LAPPRO pajak,lifth
;sprawdzic czy sie odczepil
JMOVE #pajak
RETURN
.END
.PROGRAM placepal(.nr)
;"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
SPEED medium ALWAYS
ACCEL medium ALWAYS
DECEL medium ALWAYS
ACCURACY acu ALWAYS
POINT placepal = placepal+center
LAPPRO placepal,storeh
$task = "PlacePal"
PRINT $task
ACCURACY high
LAPPRO placepal,(.nr-1)*palh+palappro
SPEED slow MM/S
LAPPRO placepal,(.nr-1)*palh
BREAK
SPEED spd ALWAYS
ACCEL acc ALWAYS
DECEL acc ALWAYS
ACCURACY acu ALWAYS
SIGNAL open
WAIT SIG(opened,-closed)
LAPPRO placepal,storeh
RETURN
.END
.PROGRAM placeweight()
;"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
CP ON
SPEED spd ALWAYS
ACCEL acc ALWAYS
DECEL acc ALWAYS
ACCURACY acu ALWAYS
$zone = "Safe"
JMOVE #placeweight
$task = "PlaceWeight"
PRINT $task
POINT palmid = pal+TRANS(75/2+row*105,75/2+col*105,-pal*palh-hath)+RZ(placeangle)
PRINT "Laduje ciezarek #",explaced," X: ",row," Y: ",col
ACCURACY high ALWAYS
LAPPRO palmid,explaceappro+explaceh
LAPPRO palmid,10+explaceh
$zone = "Pal"
PRINT $zone
SPEED slow MM/S
LAPPRO palmid,explaceh
BREAK
TWAIT 0.5
SIGNAL -gripper
WAIT SIG(-gc,go)
TWAIT 0.5
SPEED spd ALWAYS
LAPPRO palmid,explaceappro+explaceh
ACCURACY acu ALWAYS
JMOVE #placeex
$zone = "Safe"
PRINT $zone
RETURN
.END
.PROGRAM placeweight2()
;"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
CP ON
SPEED slow ALWAYS
ACCEL acc ALWAYS
DECEL acc ALWAYS
ACCURACY acu ALWAYS
BASE pal
TOOL schunk
JMOVE #placeweight
POINT palmid = TRANS(75/2,75/2,-pal*palh-hath)+RZ(placeangle)
PRINT "Laduje ciezarek #",explaced," X: ",row," Y: ",col
LAPPRO SHIFT(palmid BY row*105,col*105),explaceappro+explaceh
LAPPRO SHIFT(palmid BY row*105,col*105),10+explaceh
SPEED slow MM/S
LAPPRO SHIFT(palmid BY row*105,col*105),explaceh
BREAK
TWAIT 0.5
SIGNAL go
SPEED spd ALWAYS
LAPPRO SHIFT(palmid BY row*105,col*105),explaceappro+explaceh
JMOVE #placeex
.END
.PROGRAM pomoc()
PRINT "/C1"
PRINT "Kod pakietu:  ",heatexcode
PRINT "Rozmiar:      ",type
PRINT "/C1"
PRINT "RobAssT     - testowy podjazd do transportera robAssembly"
PRINT "TransAtqAss - testowy przejazd z transportera po chodzeniu"
PRINT "              przez ATQ do transportera do robAssembly"
PRINT "exe TransAtqAss"
PRINT "/C2"
IF SIG(errornogripper) THEN
PRINT "! ! ! errornogripper ! ! !"
END
IF SIG(errorateq) THEN
PRINT "! ! ! errorateq ! ! !"
END
IF SIG(errortr3full) THEN
PRINT "! ! ! errortr3full ! ! !"
END
IF SIG(errorstuck) THEN
PRINT "! ! ! errorstuck ! ! !"
END
IF SIG(errorholdinghea) THEN
PRINT "! ! ! errorholdinghea ! ! !"
END
IF SIG(errorshunkfail) THEN
PRINT "! ! ! errorshunkfail ! ! !"
END
IF SIG(errorpalettesen) THEN
PRINT "! ! ! errorpalettesen ! ! !"
END
IF SIG(errorateqsensor) THEN
PRINT "! ! ! errorateqsensor ! ! !"
END
HOLD.STEP ON
.END
.PROGRAM prepareateq()
;program do przygotowania ateq przed wstawieniem do niego pakietu
;upewnia sie ze kapelsuz jest podniesiony, silnik w najwyzszej pozycji Top 
;a sygnaly pozycji i referencji sa zgaszone 
SIGNAL -changepos
FOR i = 1 TO 5
SIGNAL -ref[i] ;zgas wszystkie sygnaly referencji
END
BREAK
FOR i = 1 TO 6
SIGNAL -ateqpos[i] ;zgas wszystkie sygnaly pozycji
END
BREAK
SIGNAL hatup
SIGNAL -hatdown
WAIT SIG(hatisup,-hatisdown) ;podnies kapelusz
BREAK
SIGNAL ateqpos[1] ; odjazd max do gory
SIGNAL changepos
WAIT SIG(ateqinpos)
SIGNAL -ateqpos[1]
SIGNAL -changepos
BREAK
.END
.PROGRAM prog()
IF oldpos<>pos THEN
PRINT "Move ",pos
oldpos = pos
bpos = pos
BITS 81,8 = 5
BITS 81+8,8 = 176
FOR i = 31 TO 0 STEP -1
IF bpos>=2^i THEN
bpos = bpos-2^i
SIGNAL 81+16+i
;PRINT "SIGNAL ",81+16+i
ELSE
SIGNAL -(81+16+i)
;PRINT "SIGNAL ",-(81+16+i)
END
END
END
.END
.PROGRAM put()
;##########################################################################
;# Pobranie pakietu z testu szczelnoci ATQ i odlozenie go wg sygnalow
;##########################################################################
;pobranie pakietu z ateq i odstawienie go albo z powrotem na skrzyzowanie(jesli jest zly) albo na palete
;jesli jest dobry 
CALL getatq; wyciagamy pakiet z ATQ
;##########################################################################
;##########################################################################
PRINT "   IF testokk =",SIG(testokk)," and -testnok =",SIG(-testnok)
; IF SIG(testokk,-testnok) THEN
IF SIG(-potoncross,-testinprogres) THEN
PRINT " PAKIET SZCZELNY"
; pakiet jest szczelny trafi na palete albo do robAssembly
IF SIG(gotogalanteria) THEN
; szczelny pakiet na transporter do robAssembly
CALL torobass
ELSE
; szczelny pakiet na palete wyjsciowa
CALL topaleta
END
ELSE
; pakiet jest nieszczelny odkladamy na elejke serwisowa
PRINT " PAKIET NIESZCZELNY !!!!!!!!!!!!!!"
CALL toserwis
END
;##########################################################################
;##########################################################################
IF gotobp THEN
SPEED fastspd
ACCURACY fastacu
JMOVE #before_putr
END
gotobp = TRUE
TOOL big_gripper
SPEED fastspd
ACCURACY fastacu
JMOVE #safet
IF SIG(heatexinateq) THEN
;wyjalem pakiet z ateq a czujnik nadal cos pokazuje - zglos blad czujnika
SIGNAL errorateqsensor
;nieskonczona petla - ktos musi wejsc w strefe a potem stanowisko bedzie zresetowane 
WHILE SIG(errorateqsensor) DO
SIGNAL errorateqsensor
END
END
RETURN
.END
.PROGRAM put2()
;##########################################################################
;# Pobranie pakietu z testu szczelnoci ATQ i odlozenie go wg sygnalow
;##########################################################################
;pobranie pakietu z ateq i odstawienie go albo z powrotem na skrzyzowanie(jesli jest zly) albo na palete
;jesli jest dobry 
CALL getatq; wyciagamy pakiet z ATQ
;##########################################################################
;##########################################################################
IF SIG(testokk,-testnok) THEN
; pakiet jest szczelny trafi na palete albo do robAssembly
IF gotogalanteria THEN
; szczelny pakiet na transporter do robAssembly
CALL torobass
ELSE
; szczelny pakiet na palete wyjsciowa
CALL topaleta
END
ELSE
; pakiet jest nieszczelny odkladamy na elejke serwisowa
CALL toserwis
END
;##########################################################################
;##########################################################################
IF gotobp THEN
SPEED fastspd
ACCURACY fastacu
JMOVE #before_putr
END
gotobp = TRUE
TOOL big_gripper
SPEED fastspd
ACCURACY fastacu
JMOVE #safet
IF SIG(heatexinateq) THEN
;wyjalem pakiet z ateq a czujnik nadal cos pokazuje - zglos blad czujnika
SIGNAL errorateqsensor
;nieskonczona petla - ktos musi wejsc w strefe a potem stanowisko bedzie zresetowane 
WHILE SIG(errorateqsensor) DO
SIGNAL errorateqsensor
END
END
RETURN
.END
.PROGRAM putheatexinateq()
;JMOVE #safe90
LMOVE #before_ateq
SPEED slow MM/S ALWAYS
TOOL small_gripper
LMOVE wait_ateq
LAPPRO ateq,15
TWAIT (0.5)
SIGNAL openfingers
WAIT SIG(-leftfingerc,-rightfingerc,leftfingero,rightfingero)
TWAIT 0.5
LMOVE ateq
TWAIT 0.5
SIGNAL openfingers
WAIT SIG(-leftfingerc,-rightfingerc,leftfingero,rightfingero)
LAPPRO ateq,-20
width = (jawwidth[type]+70)
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
TWAIT (0.5)
LMOVE wait_test
JMOVE #before_ateq
SPEED spd MM/S ALWAYS
JMOVE #safe90
JMOVE #safett
.END
.PROGRAM putheatexonpot()
JMOVE next_conveyors
LMOVE #before_heatex
TOOL small_gripper
POINT pick_heatexch = SHIFT(pick_heatex BY 0,0,-(410-pacheight[type])) ;zteachowany jest punkt pick_heatEx 
;jest to punkt dla pakietu o wysokosci 410 
JAPPRO pick_heatexch,300
SPEED slow MM/S ALWAYS
LAPPRO pick_heatexch,20
SIGNAL openfingers
WAIT SIG(-leftfingerc,-rightfingerc,leftfingero,rightfingero)
LAPPRO pick_heatexch,-20
width = (jawwidth[type]+80)
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
LAPPRO pick_heatexch,400
SPEED spd MM/S ALWAYS
LMOVE #before_heatex
JMOVE next_conveyors
JMOVE #safet
.END
.PROGRAM putoutgripper()
;odstawienie chywtaka 
SPEED spd MM/S ALWAYS
JMOVE #over_gripper
TOOL big_gripper
LAPPRO get_grip,200
SIGNAL leavepalette
SIGNAL -grabpalette
WAIT SIG(palettegrippero,-palettegripperc) ;upewniam sie ze przy odstawianiu chwytaka
;silownik od palet jest rozsuniety - nogi chwytaka trafia w bolce
SPEED slow MM/S ALWAYS
LMOVE get_grip
TWAIT (0.5)
BREAK
;chowam bolce 
SIGNAL -connectoron
SIGNAL leavegripper
SIGNAL -grabgripper
WAIT SIG(-havegripper,leftgripper)
LMOVE inside_grip
TWAIT 0.2
;chowam silownik do chwytania palet - inaczej uderze nim w rame chwytaka 
SIGNAL -leavepalette
SIGNAL grabpalette
WAIT SIG(-palettegrippero,palettegripperc)
LAPPRO get_grip,500
SPEED spd MM/S ALWAYS
LAPPRO get_grip,1000  ;jestem juz ponad chywtakiem - odjazd do safe
IF NOT safeprocedure THEN
JMOVE #safet
END
.END
.PROGRAM putoutheatex()
;odkladanie wymiennika do ateq jesli jest wolny, jesli nie, to wystawienie bledu - ktos musi zabrac wymiennik z ateq
IF SIG(heatexinateq) THEN ;cos stoi w ateq - normalnie nie powinno miec miejsca 
SIGNAL errorateq ;poza wystawieniem erroru nic wiecej nie moge zrobic 
SIGNAL errorholdinghea
ELSE
JMOVE #safe90
JMOVE #before_ateqr
TOOL small_gripper
LMOVE wait_ateq
;LMOVE wait_test 
CALL prepareateq
SPEED ateqspd MM/S ALWAYS
LAPPRO ateq,20
TWAIT 0.5 ;jestem w ATEQ - trzeba puscic pakiet
LMOVE ateq
TWAIT 0.5
SIGNAL -closefingers
SIGNAL openfingers
WAIT SIG(-leftfingerc,-rightfingerc,leftfingero,rightfingero)
LAPPRO ateq,-20
WAIT SIG(donext) ;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
;SIGNAL -doNext
width = (jawwidth[5]+70) ;rozsuniecie szczek maksymalnie bo nie wiem jaki pakiet trzymam
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
WAIT SIG(donext) ;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
;SIGNAL -doNext
;LMOVE wait_ateq
POINT wait_test = ateq+TRANS(0,-500)
LMOVE wait_test
LMOVE wait_ateq
LMOVE #before_ateqr
SPEED spd MM/S ALWAYS
JMOVE #safe90
JMOVE #safet
SIGNAL errorateq
IF SIG(-heatexinateq) THEN
;wstawilem pakiet do ateq a czujnik nadal pokazuje 0 - to znaczy ze sie zepsol 
SIGNAL errorateqsensor
END
END
.END
.PROGRAM putpalette()
;przygotowanie nowego stanowiska na tr3 - ustawienie palety i przekladki, wyzerowanie licznika warstw, rzedow
;i kolumn, wyzerowanie sygnalow o polozonych przekladkach 
;sprawdzanie gdzie jestem, jesli stoje przed ateq to musze wywolac 'move2safe' 
IF SIG(fpositionnextat) THEN
CALL move2safe
END
IF SIG(-havegripper,leftgripper) THEN  ;nie mam chwytaka - musze po niego pojechac
CALL getgripper
END
;dopoki nic nie stoi na tr1 to wpuszczaj ludzi i czekaj 
WHILE SIG(-sensorback[1]) DO
TWAIT 0.2 ; czekaj zeby signals zdazylo zalaczyc transporter
IF SIG(-movingback[1],-sensorback[1]) THEN ; jesli transporter nie jedzie->nic nie ma->wystaw sygnal ze brakuje palet
SIGNAL -qtyok[1]
SIGNAL qtynok[1]
SIGNAL needpaletts
SIGNAL -stoptransporter[1]
CALL allowentrance
SIGNAL trready[1]
END
END
SIGNAL stoptransporter[1]
palettenotfound = TRUE
WHILE palettenotfound DO
SIGNAL -trready[1]
SIGNAL stoptransporter[1]
CALL checkpaletts
ACCURACY acu ALWAYS
IF palettenotfound THEN
IF nrofpaletts>0 THEN ;jest za duzo palet lub nie udalo sie zlokalizowac 
LAPPRO pick_palette,paletteheight*maxnrofpaletts+200
JMOVE #safet
SIGNAL -stoptransporter[1]
SIGNAL moveout[1]
TWAIT 0.5
WAIT SIG(sensorfront[1]) OR SIG(errortrblocked[1])
SIGNAL -moveout[1]
SIGNAL stoptransporter[1]
END
;czekaj na potwierdzenie erroru przez operatora 
WHILE SIG(-errorconfhold) DO
SIGNAL errortr[1]
CALL allowentrance
SIGNAL stoptransporter[1]
END
SIGNAL -moveout[1]
SIGNAL -errortr[1]
SIGNAL -errortrblocked[1]
WHILE SIG(-sensorback[1]) DO
TWAIT 0.2 ; czekaj zeby signals zdazylo zalaczyc transporter
IF SIG(-movingback[1],-sensorback[1]) THEN ; jesli transporter nie jedzie->nic nie ma->wystaw sygnal ze brakuje palet
SIGNAL -qtyok[1]
SIGNAL qtynok[1]
SIGNAL needpaletts
SIGNAL -stoptransporter[1]
CALL allowentrance
END
SIGNAL trready[1]
END
END
END
SIGNAL -trready[1]
LMOVE SHIFT(pick_palette BY 0,correctionoy-50,paletteheight*(nrofpaletts-1))
TWAIT 0.5
;WAIT SIG(doNext)	;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
;SIGNAL -doNext
SIGNAL -leavepalette
SIGNAL grabpalette
WAIT SIG(-palettegrippero,palettegripperc)
LMOVE SHIFT(pick_palette BY 0,correctionoy-50,paletteheight*(nrofpaletts));podjazd troche wyzej prosto w gore
LAPPRO pick_palette,paletteheight*(nrofpaletts-1)+160
SPEED spd MM/S ALWAYS
LAPPRO pick_palette,spacerheight*maxnrofspacers+paletteheight+140 ;podnioslem	palete
;przejazd nad przekladkami 
LAPPRO pick_spacer,spacerheight*maxnrofspacers+paletteheight+140
SIGNAL -stoptransporter[1]
LAPPRO put_palette,spacerheight*maxnrofspacers+paletteheight+140
LAPPRO put_palette,150
SPEED slow MM/S ALWAYS
LMOVE put_palette
TWAIT 0.5
;WAIT SIG(doNext)	;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
;SIGNAL -doNext
SIGNAL leavepalette
SIGNAL -grabpalette
WAIT SIG(palettegrippero,-palettegripperc)
LAPPRO put_palette,150
SPEED spd MM/S ALWAYS
LAPPRO put_palette,1000
layercount = 0
rowcount = 1
colcount = 1
SIGNAL -layerfull[1]
SIGNAL -layerfull[2]
SIGNAL -spacerputted[1]
SIGNAL -spacerputted[2]
nrofpaletts = nrofpaletts-1
palettenotempty = FALSE ;flaga zeby pomimo zmieny typu pakietu nie wyjechala pusta paleta
;ustawiana w put po postawieniu pakietu
;jesli zostala tylko 1 paleta to wystaw sygnal do PLC 
IF nrofpaletts<2 THEN
SIGNAL qtynok[1]
SIGNAL -qtyok[1]
END
;SIGNAL PaletteWithoutSpacer	;gaszony po polozeniu przekladki
CALL putspacer
CALL putoutgripper
.END
.PROGRAM putspacer()
;ustawianie przekladki 
;sprawdzam gdzie jestem - jesli stoje przed ateq to musze pojechac do #safeT
IF SIG(fpositionnextat) THEN
CALL move2safe
END
IF SIG(-havegripper,leftgripper) THEN  ;nie mam chwytaka - musze po niego pojechac
CALL getgripper
END
WHILE SIG(-sensorback[2]) DO ;czekam zeby bylo co podnosic
TWAIT 0.2 ;zeby w signals zdazyl wlaczyc sie transporter wtedy nie wejde do ponizszego if'a
IF SIG(-movingback[2],-sensorback[2]) THEN ;jesli transporter nie jest w ruchu->nic tam nie ma->wystaw sygnal ze brak przekladek
SIGNAL -qtyok[2]
SIGNAL qtynok[2]
SIGNAL needspacers
SIGNAL -stoptransporter[2]
CALL allowentrance
SIGNAL trready[2]
END
END
SIGNAL stoptransporter[2]
spacernotfound = TRUE
WHILE spacernotfound DO    ;flaga ustawiana w checkSpacers
SIGNAL -trready[2]
SIGNAL stoptransporter[2]
CALL checkspacers;sprawdzanie ile mam przekladek na transporterze
ACCURACY acu ALWAYS
IF spacernotfound THEN
IF nrofspacers==0 THEN ;gdy znalazlem sama palete 
;jesli nie ma nic to nrofspacers = -1 - wtedy tylko czekaj 
LAPPRO pick_spacer,spacerheight*maxnrofspacers
CALL relocatepalette
END
;GDY JEST ZA DUZO PRZEKLADEK lub nie moge zlokalizowac przekladki 
IF nrofspacers>0 THEN
LAPPRO pick_spacer,spacerheight*maxnrofspacers+200
JMOVE #safet
SIGNAL -stoptransporter[2]
SIGNAL moveout[2]
TWAIT 0.5
WAIT SIG(sensorfront[2]) OR SIG(errortrblocked[2]) ;wystawiam sygnal zeby wyjechalo i czekam az wyjedzie
SIGNAL -moveout[2]
SIGNAL stoptransporter[2]
END
IF nrofspacers<>0 THEN
WHILE SIG(-errorconfhold) DO ;czekam na potrwierdzenie erroru
SIGNAL errortr[2]
CALL allowentrance
SIGNAL stoptransporter[2]
END
END
SIGNAL -moveout[2]
SIGNAL -errortr[2] ;to powinno sie zrobic juz w signals
SIGNAL -errortrblocked[2]
WHILE SIG(-sensorback[2]) DO ;czekam zeby bylo co podnosic
SIGNAL -stoptransporter[2]
TWAIT 0.2 ;zeby w signals zdazyl wlaczyc sie transporter i wtedy nie wejde do if'a ponizej
IF SIG(-movingback[2],-sensorback[2]) THEN ;jesli transporter nie jest w ruchu->nic tam nie ma->wystaw sygnal ze brak przekladek
SIGNAL -qtyok[2]
SIGNAL qtynok[2]
SIGNAL needspacers
CALL allowentrance
END
SIGNAL trready[2]
END
END
END
SIGNAL -trready[2]
LMOVE SHIFT(pick_spacer BY 0,correctionoy-50,spacerheight*(nrofspacers-1))
TWAIT 0.5
;WAIT SIG(doNext)	;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
;SIGNAL -doNext
SIGNAL -leavepalette
SIGNAL grabpalette
WAIT SIG(-palettegrippero,palettegripperc)
LMOVE SHIFT(pick_spacer BY 0,correctionoy-50,spacerheight*nrofspacers);podjazd prosto w gore
;petrze co jest wyzej czy stos przekladek czy juz ulozona paleta 
IF ((pacheight[type]+spacerthicknes)*(layercount)+50)>(spacerheight*(nrofspacers-1)+500) THEN
LAPPRO pick_spacer,(pacheight[type]+spacerthicknes)*(layercount)+50     ;mam przekladke
ELSE
LAPPRO pick_spacer,spacerheight*(nrofspacers-1)+500
END
SPEED spd MM/S ALWAYS
IF ((pacheight[type]+spacerthicknes)*(layercount)+100)>(spacerheight*(nrofspacers-1)+500) THEN
LAPPRO put_spacer,(pacheight[type]+spacerthicknes)*(layercount)+100
ELSE
LAPPRO put_spacer,spacerheight*(nrofspacers-1)+500
END
SIGNAL -stoptransporter[2]
LAPPRO put_spacer,(pacheight[type]+spacerthicknes)*(layercount)+100
SPEED slow MM/S ALWAYS
LAPPRO put_spacer,(pacheight[type]+spacerthicknes)*(layercount)   ;punkt podwyzszony zgodnie z tym ktora to warstwa
;WAIT SIG(doNext)	;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
;SIGNAL -doNext
;puszczam przekladke
SIGNAL leavepalette
SIGNAL -grabpalette
WAIT SIG(palettegrippero,-palettegripperc) ;odlozylem przekladke
LAPPRO put_spacer,(pacheight[type]+spacerthicknes)*(layercount)+100
SPEED spd MM/S ALWAYS
IF layercount>0 THEN
SIGNAL spacerputted[layercount]
END
layercount = layercount+1
nrofspacers = nrofspacers-1
;SIGNAL -PaletteWithoutSpacer	;polozylem przekladke nie patrze nawet ktora to warstwa 
IF nrofspacers<3 THEN ;gdy mam malo przekladek to wystaw o tym sygnaly do PLC
SIGNAL -qtyok[2] ;gaszony w signals gdy cos wjezdza
SIGNAL qtynok[2]
END
IF layercount>2 THEN ;bezpieczny odjazd po ostatniej przekladce - do safe bo zaraz wyjedzie paleta i bede kladl nowa na tr3 
BREAK
POINT pavoid = HERE
POINT pavoid = SHIFT(pavoid BY -1300,0,50)
LMOVE pavoid
JMOVE #safet
ELSE
LAPPRO put_spacer,(pacheight[type]+spacerthicknes)*(layercount-1)+200
IF nrofspacers<1 OR SIG(endcycle) THEN
LMOVE #safet;zaraz bede musial przelozyc palete spod przekladek lub jest koniec cyklu 
ELSE
LMOVE #over_gripper
END
END
IF nrofspacers<1 AND nrofspacers>=0 THEN ;znalazlem tylko palete lub zostala tylko paleta 
CALL relocatepalette
END
.END
.PROGRAM receive()
PRINT "START: receive()"
;czekanie na sygnal o tym, ze przyjechal pakiet i przypisanie go do odpowiedniego typu wg rozmiaru
decoded = FALSE
PRINT "   WHILE decoded==FALSE DO"
WHILE decoded==FALSE DO
BREAK
CALL allowentrance
oldheatexcode = -1
prevtype = type
prevcode = heatexcode
PRINT "   WHILE SIG(-packagewaits) DO"
WHILE SIG(-packagewaits) DO ;dopoki nie dostane syg ze pakiet przyjechal to zezwalam na wejscie lub pauze  
heatexcode = BITS(packagetype,5)
IF oldheatexcode<>heatexcode THEN
SIGNAL -ref[1]
SIGNAL -ref[2]
SIGNAL -ref[3]
SIGNAL -ref[4]
SIGNAL -ref[5]
CALL setreference
oldheatexcode = heatexcode
END
CALL allowentrance
IF SIG(endcycle) THEN ;jesli jest sygnal o koncu pracy to oproznij stanowisko 
CALL emptyworkstatio
SIGNAL endconf ;sygnal do plc ze skonczylem procedure oprozniania 
WHILE SIG(endconf) DO
SIGNAL stoptransporter[1]
SIGNAL stoptransporter[2]
SIGNAL -trready[3]
SIGNAL enterconf  ;koniec pracy wpuszczam ludzi i sie zatrzymuje (petla while)
END
END
$actualdatea = $DATE(1)
IF $prevdatea<>$actualdatea THEN ;jesli mamy nowy dzien to przejedz shunkiem max-min zeby go nasmarowac
SIGNAL ateqcal
TWAIT 1
WAIT SIG(ateqcalok)
SIGNAL -ateqcal
$prevdatea = $actualdatea
END
END
PRINT "   END WHILE SIG(-packagewaits) DO"
SIGNAL -errornoheatex
;=====zakomentowac linijke ponizej jak bedzie komunikacja z PLC
;BITS PackageType, 5 = pType
;=====================
heatexcode = BITS(packagetype,5)
;przypisanie odpowiedniego kodu pakietu do odpowiedniego typu
CALL decodetype
IF decoded==FALSE THEN
SIGNAL errorheatexwron
ELSE
SIGNAL -errorheatexwron
END
SIGNAL -heatexonpalette
SIGNAL -heatexoncross
SIGNAL -heatexongalante
SIGNAL -stoptransporter[1]
SIGNAL -stoptransporter[2]
IF firstcycle AND SIG(-errorheatexwron) THEN
prevtype = type ;zeby nie wyjechala pusta paleta
prevcode = heatexcode ;zeby nie wyjechala pusta paleta
firstcycle = FALSE
END
END
PRINT "   END WHILE decoded==FALSE DO"
PRINT "END: receive()"
RETURN
.END
.PROGRAM recieve()
;czekanie na sygnal o tym, ze przyjechal pakieti przypisanie go do odpowiedniego typu wg rozmiaru
BREAK
WHILE SIG(-packagewaits) DO ;dopoki nie dostane syg ze pakiet przyjechal to zezwalam na wejscie lub pauze  
CALL allowentrance
END
SIGNAL -errornoheatex
prevtype = type
prevcode = heatexcode
;VVVVjak bedzie polaczenie z Leszkiem to te linijki zakomentowacVVVV 
BITS packagetype,5 = ptype
type = BITS(packagetype,5)
;=====dotad komentowac=======
;=====to odkomentowac jak bedzie kodowanie i komunikacja z leszkiem====
;heatExCode = BITS(PackageType, 5)
;tutaj trzeba przypisac odpowiedni kod pakietu do odpowiedniego typu
;====dotad odkomentowac====== 
SIGNAL -heatexonpalette
SIGNAL -heatexoncross
SIGNAL -stoptransporter[1]
SIGNAL -stoptransporter[2]
IF firstcycle THEN
prevtype = type ;zeby nie wyjechala pusta paleta
prevcode = heatexcode ;zeby nie wyjechala pusta paleta
firstcycle = FALSE
END
.END
.PROGRAM ref()
BITS 81,8 = 1
BITS 81+8,8 = 146
.END
.PROGRAM relocatepalette()
;procedura, gdy skoncza sie przekladki - trzeba cos zrobic z paleta
LMOVE #safet
SIGNAL stoptransporter[2]
IF SIG(sensorfront[1]) THEN ;jesli cos czeka na wjzad to to wpusc
WHILE SIG(-sensorback[1]) DO
SIGNAL -stoptransporter[1]
SIGNAL trready[1]
END
END
SIGNAL stoptransporter[1]
IF SIG(sensorback[1]) THEN ;paleta musi isc na tr1 czyli musze sprawdzic ile ich tam stoi 
palettenotfound = TRUE
WHILE palettenotfound DO
SIGNAL -trready[1]
SIGNAL stoptransporter[1]
CALL checkpaletts
ACCURACY acu ALWAYS
IF palettenotfound THEN
IF nrofpaletts>0 THEN ;jest za duzo palet lub nie udalo sie ich zlokalizowac 
LAPPRO pick_palette,paletteheight*maxnrofpaletts+200
JMOVE #safet
SIGNAL -stoptransporter[1]
SIGNAL moveout[1]
TWAIT 0.5
WAIT SIG(sensorfront[1]) OR SIG(errortrblocked[1])
SIGNAL -moveout[1]
SIGNAL stoptransporter[1]
END
;potrzebuje potrwierdzenia czlowieka bo byl sygnal ze cos stoi a nic nie moge znalezc 
WHILE SIG(-errorconfhold) DO
SIGNAL errortr[1]
CALL allowentrance
SIGNAL stoptransporter[1]
END
SIGNAL -moveout[1]
SIGNAL -errortr[1]
SIGNAL -errortrblocked[1]
IF SIG(sensorfront[1]) OR SIG(-objectnotin[1]) THEN ;cos czeka na wjazd - powinno wjechac z automatu
WHILE SIG(-sensorback[1]) DO
TWAIT 0.2 ;czekaj zeby signals zdazylo zalaczyc transporter
IF SIG(-movingback[1]) THEN ; jesli transporter nie jedzie->nic nie ma->wystaw sygnal ze brakuje palet
SIGNAL -qtyok[1]
SIGNAL qtynok[1]
CALL allowentrance
SIGNAL -stoptransporter[1]
END
SIGNAL trready[1]
END
END
;TO DO SPRAWDZENIA !!
;jesli po wejsciu operatora nic nie ma na tr1 to jedz dalej 
;zaraz poloze tam palete spod przekladek 
;zdejmuje paletteNorFound zeby wyjsc z tej petli while 
IF SIG(-sensorfront[1],objectnotin[1],-sensorback[1]) THEN
palettenotfound = FALSE
nrofpaletts = 0
END
END
END
END
IF SIG(sensorback[1]) THEN ;jesli cos stoi na tr1 a tr3 jest zajety to musze odlozyc na tr1 - sprawdzilem 
SPEED spd MM/S ALWAYS          ;ile mam palet i pewnie jestem w miejscu pobrania najwyzszej - musze odjechac 
LAPPRO pick_palette,paletteheight*(nrofpaletts-1)+500
END
LAPPRO pick_spacer,500
LAPPRO pick_spacer,200
SPEED slow MM/S ALWAYS
LAPPRO pick_spacer,-70
TWAIT 0.5
SIGNAL -leavepalette
SIGNAL grabpalette
WAIT SIG(-palettegrippero,palettegripperc)
LAPPRO pick_spacer,200
SPEED spd MM/S ALWAYS
LAPPRO pick_spacer,spacerheight*maxnrofspacers+200
;trzymam palete i jestem nad miejscem pobrania - klade palete na tr1
IF SIG(-sensorback[1]) THEN ;nic nie stoi na tr1 czyli liczba palet = 0 potrzebne do ustalenia wysokosci gdzie puscic
nrofpaletts = 0
END
POINT putb_palette = SHIFT(pick_palette BY 10,0,0) ;o tyle trzeba przesunac zeby palety byly rowno
LAPPRO putb_palette,spacerheight*maxnrofspacers+200
LAPPRO putb_palette,paletteheight*(nrofpaletts)+150
SPEED slow MM/S ALWAYS
LAPPRO putb_palette,paletteheight*(nrofpaletts) ; nie ma -1 bo odkladam o 1 palete wyzej niz jest 
TWAIT 0.5
;WAIT SIG(doNext)	;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
;SIGNAL -doNext
SIGNAL leavepalette
SIGNAL -grabpalette
WAIT SIG(palettegrippero,-palettegripperc)
LAPPRO putb_palette,paletteheight*(nrofpaletts)+200
nrofpaletts = nrofpaletts+1
SPEED spd MM/S ALWAYS
LAPPRO putb_palette,spacerheight*maxnrofspacers+200
LMOVE #safet
SIGNAL -stoptransporter[1]
SIGNAL -stoptransporter[2]
.END
.PROGRAM returntosafe()
PRINT "operator wywolal ruch robota do domu"
;FUNKCJA JESZCZE NIE DOKONCZONA !!!
;SPEED slow MM/S ALWAYS
;JMOVE #safet
.END
.PROGRAM robasst()
;####################################################################
;# Testowe uruchomienie ruchu do transportera robAssembly
;####################################################################
PRINT "/C2"
CALL datainit
CALL decodetype
PRINT "Testowe uruchomienie dojazdu do transportera robAssembly"
PRINT "Kod pakietu:  ",heatexcode
PRINT "Rozmiar:      ",type
CALL torobass
.END
.PROGRAM safetycheck()
;program do badania bezpieczenstwa robota - czy np nie upusci pakietow/ chwytaka 
SPEED spd MM/S ALWAYS
JMOVE #safet
TOOL big_gripper
;POINT p0 = HERE
;POINT p0 = p0 + Rz(90)
;POINT p0 = SHIFT(p0 BY 0,0,)
;POINT p1 = SHIFT(p0 BY -200)
;POINT p2 = SHIFT(p0 BY 2000)
;POINT p3 = SHIFT(p0 BY 2000,-1500)
;IF SIG(HaveGripper,-LeftGripper) THEN
;	POINT p1 = SHIFT(pick_palette BY 1000,0,800)
;	POINT p2 = SHIFT(put_palette BY 0,0,800)
;	POINT p3 = SHIFT(p2 BY 0,-1500)
;END
LMOVE #p22
SPEED 100 ALWAYS
WAIT SIG(donext)
SIGNAL -donext
JMOVE #p33
WAIT SIG(donext)
SIGNAL -donext
JMOVE #p22
WAIT SIG(donext)
SIGNAL -donext
JMOVE #p11
WAIT SIG(donext)
SIGNAL -donext
JMOVE #p331
WAIT SIG(donext)
SIGNAL -donext
JMOVE #p11
WAIT SIG(donext)
SIGNAL -donext
JMOVE #p331
SPEED spd MM/S ALWAYS
JMOVE #safet
.END
.PROGRAM safetyheatexpic()
;program, ktory pobierze pakiet i odjedzie do #safe
JMOVE #safet
TOOL big_gripper
SPEED spd MM/S ALWAYS
CALL receive
IF SIG(havegripper,-leftgripper) THEN ;nie moge jechac w te rejony z chwytakiem 
CALL putoutgripper
END
SIGNAL -leavepalette  ;jezdzimy z zamknietymi szczekami do lapania palet (silownik schowany)
SIGNAL grabpalette
WAIT SIG(-palettegrippero,palettegripperc)
JMOVE next_conveyors
SPEED slowdeg
LMOVE #before_heatex
SPEED deg ALWAYS
;CALL allowEntrance ;jesli ktos zglosil chec wejscia to
TOOL small_gripper
SIGNAL -closefingers
SIGNAL openfingers   ;otwieram chwytak do pakietow
WAIT SIG(-leftfingerc,-rightfingerc,leftfingero,rightfingero)
;zteachowany jest punkt pick_heatEx 
;jest to punkt dla pakietu o min wysokosci
POINT pick_heatexch = SHIFT(pick_heatex BY 0,0,pacheight[type]-minpacheight+pickcorrection[type])
POINT before_heatexpi = pick_heatexch+TRANS(0,-500) ;punkt do wyjazdu z miejsca podniesienia pakietu 
LAPPRO before_heatexpi,-20
SPEED slow MM/S ALWAYS
IF type<>5 AND type<>4 THEN
width = (jawwidth[type]+120)
ELSE
width = (jawwidth[type]+90) ;jesli to te najwieksze wymienniki to nie moge sie bardziej rozsunac bo wypadne z prowadnic
END
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
LAPPRO pick_heatexch,-20
TWAIT (0.5)
LMOVE pick_heatexch
TWAIT 0.5
WAIT SIG(donext) ;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
SIGNAL -donext
TWAIT (0.5)
width = jawwidth[type]
BITS 81+16,16 = 0
BITS 81+16+8,16 = width-20  ;zacisniecie shunka - odpowie Move Blocked
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
;cShunkPos = BITS(1201,16)	;current Shunk Position odczytanie na jakiej pozycji stanal shunk
cshunkpos = BITS(1265,16) ;current Shunk Position odczytanie na jakiej pozycji stanal shunk
BITS 81+16,16 = 0
BITS 81+16+8,16 = cshunkpos+3  ;lekkie rozwarcie - pakiet nie spadnie a shunk bedzie "na pozycji"
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
LAPPRO pick_heatexch,40
TWAIT (0.5)
SIGNAL closefingers
SIGNAL (-openfingers)
WAIT SIG(leftfingerc,rightfingerc,-leftfingero,-rightfingero)
; mam chwycony pakiet
LAPPRO before_heatexpi,40
LMOVE #midway
SPEED spd MM/S ALWAYS
LMOVE SHIFT(next_conveyors BY 0,-150,-200)+RZ(-300)
;LMOVE #before_ateqR	
JMOVE #safe90
JMOVE #safet
TOOL big_gripper
.END
.PROGRAM safetyheatexput()
;program, ktory odlozy trzymany pakiet na palete - mniej wiecej na srodku 
SPEED spd MM/S ALWAYS
TOOL big_gripper
JMOVE #safet
JMOVE #safe90
JMOVE #before_put
TOOL small_gripper
;punkt gdzie odstawic pakiet- zalezne od tego ile juz istawilem
POINT putpackage = SHIFT(initial_put[1] BY -xdist[1]*(2-1),-ydist[1]*(3-1),(pacheight[type]+spacerthicknes)*(0))
JAPPRO putpackage,(pacheight[type]+50)
SPEED slow MM/S ALWAYS
LMOVE putpackage
TWAIT (0.5)
SIGNAL -closefingers
SIGNAL openfingers
WAIT SIG(-leftfingerc,-rightfingerc,leftfingero,rightfingero)
LAPPRO putpackage,-20   ;zjazd w dol - zeby pakiet nie byl na szczekach
IF type<>2 AND type<>5 THEN
width = (jawwidth[type]+120)  ;rozsuniecie szczek
ELSE
width = (jawwidth[type]+100)
END
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
WAIT SIG(donext) ;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
SIGNAL -donext
LAPPRO putpackage,pacheight[type]+50 ;odjazd w gore 
SPEED spd MM/S ALWAYS
palettenotempty = TRUE ;flaga zeby pomimo zmieny typu pakietu nie wyjechala pusta paleta
;gasze bo wlasnie cos na niej postawilem teraz paleta nie jest pusta 
JMOVE #before_putr
gotobp = TRUE
TOOL big_gripper
JMOVE #safet
.END
.PROGRAM safetypalettepi()
;program, ktory pobierze palete i pojedzie do #safeT
JMOVE #safet
TOOL big_gripper
SPEED spd MM/S ALWAYS
IF SIG(-havegripper,leftgripper) THEN  ;nie mam chwytaka - musze po niego pojechac
CALL getgripper
END
CALL checkpaletts
ACCURACY acu ALWAYS
LMOVE SHIFT(pick_palette BY 0,correctionoy-50,paletteheight*(nrofpaletts-1))
TWAIT 0.5
WAIT SIG(donext) ;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
SIGNAL -donext
SIGNAL -leavepalette
SIGNAL grabpalette
WAIT SIG(-palettegrippero,palettegripperc)
LMOVE SHIFT(pick_palette BY 0,correctionoy-50,paletteheight*(nrofpaletts));podjazd troche wyzej prosto w gore
LAPPRO pick_palette,paletteheight*(nrofpaletts-1)+160
SPEED spd MM/S ALWAYS
LAPPRO pick_palette,spacerheight*maxnrofspacers+paletteheight+140
;podnioslem	palete
JMOVE #safet
.END
.PROGRAM safetypalettepu()
;program, ktory odlozy trzymana palete 
SPEED spd MM/S ALWAYS
TOOL big_gripper
JMOVE #safet
LAPPRO put_palette,spacerheight*maxnrofspacers+paletteheight+140
LAPPRO put_palette,150
SPEED slow MM/S ALWAYS
LMOVE put_palette
TWAIT 0.5
WAIT SIG(donext) ;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
SIGNAL -donext
SIGNAL leavepalette
SIGNAL -grabpalette
WAIT SIG(palettegrippero,-palettegripperc)
LAPPRO put_palette,150
SPEED spd MM/S ALWAYS
LAPPRO put_palette,1000
layercount = 0
rowcount = 1
colcount = 1
SIGNAL -layerfull[1]
SIGNAL -layerfull[2]
SIGNAL -spacerputted[1]
SIGNAL -spacerputted[2]
nrofpaletts = nrofpaletts-1
palettenotempty = FALSE ;flaga zeby pomimo zmieny typu pakietu nie wyjechala pusta paleta
;ustawiana w put po postawieniu pakietu
JMOVE #safet
.END
.PROGRAM safetyspacerpic()
;program, ktory podniesie przekladke i odjedzie do #safeT
SPEED spd MM/S ALWAYS
TOOL big_gripper
JMOVE #safet
IF SIG(-havegripper,leftgripper) THEN  ;nie mam chwytaka - musze po niego pojechac
CALL getgripper
END
CALL checkspacers;sprawdzanie ile mam przekladek na transporterze
LMOVE SHIFT(pick_spacer BY 0,correctionoy-50,spacerheight*(nrofspacers-1))
TWAIT 0.5
WAIT SIG(donext) ;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
SIGNAL -donext
SIGNAL -leavepalette
SIGNAL grabpalette
WAIT SIG(-palettegrippero,palettegripperc)
LMOVE SHIFT(pick_spacer BY 0,correctionoy-50,spacerheight*nrofspacers);podjazd prosto w gore
LAPPRO pick_spacer,spacerheight*(nrofspacers-1)+500
SPEED spd MM/S ALWAYS
JMOVE #safet
.END
.PROGRAM safetyspacerput()
;program, ktory odlozy trzymana przekladke - musi byc paleta na tr3 !!! 
SPEED spd MM/S ALWAYS
TOOL big_gripper
JMOVE #safet
LAPPRO put_spacer,spacerheight*(nrofspacers-1)+500
layercount = 0
LAPPRO put_spacer,(pacheight[type]+spacerthicknes)*(layercount)+100
SPEED slow MM/S ALWAYS
LAPPRO put_spacer,(pacheight[type]+spacerthicknes)*(layercount)  ;punkt podwyzszony zgodnie z tym ktora to warstwa
WAIT SIG(donext) ;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
SIGNAL -donext
SIGNAL leavepalette
SIGNAL -grabpalette
WAIT SIG(palettegrippero,-palettegripperc) ;odlozylem przekladke
LAPPRO put_spacer,(pacheight[type]+spacerthicknes)*(layercount)+100
SPEED spd MM/S ALWAYS
LAPPRO put_spacer,(pacheight[type]+spacerthicknes)*(layercount+1)+200
JMOVE #safet
.END
.PROGRAM schunk(.szer)
BITS 81+16,16 = 0
BITS 81+16+8,16 = .szer
TWAIT (0.2)
SIGNAL waitforshunkmov
TIMER (1) = 0
WAIT SIG(-waitforshunkmov) OR TIMER(1)>maxtimershunk ;czekam na odpowiedz shunka
IF SIG(-waitforshunkmov) THEN  ;shunk odpowiedzial porpawnie
; ok udalo sie ustawic szczeki schunka
shunkfail = FALSE
ELSE
PRINT "Przekroczona czas ustawiania schunka. maxtimershunk =",maxtimershunk
HOLD.STEP ON
END
RETURN
.END
.PROGRAM sendlog()
; Wyslanie komunikatu do PC - watek glowny
; Oczekiwanie na zwolnienie portu UDP przez watek komunikacji
WHILE logsendmsgcomm==1 DO
END
logsendmsgmain = 1
.first = 1
WHILE logsendmsgcomm==1 DO
IF .first==1 THEN
PRINT "sendLog - oczekiwanie na zwolnienie portu"
;			PRINT "MSG: ",$sendLogData[1]
.first = 0
END
END
ONE errlogudpsend
UDP_SENDTO .error,logudpadrip[0],logudp.port,$sendlogdata[0],2,2
ONE errlogudpsend
UDP_SENDTO .error,logudpadrip[0],logudp.port,$sendlogdata[0],2,2
logsendmsgmain = 0
; Zmiana identyfikatora komunikatu
logudpcounter = logudpcounter+1
IF logudpcounter>99 THEN
logudpcounter = 0
END
RETURN
.END
.PROGRAM sendlog2()
; Wyslanie komunikatu do PC - watek komunikacji
; Jesli logUDPkomStop==0 - wstrzymanie wysylania komunikatow w watku komunikacji
IF logudpkomstop==0 THEN
; Oczekiwanie na zwolnienie portu UDP przez watek komunikacji
logsendmsgcomm = 1
TIMER (8) = 0
.first = 1
WHILE logsendmsgmain==1 AND TIMER(8)<0.1 DO
IF .first==1 THEN
PRINT "send2Log - oczekiwanie na zwolnienie portu"
;				PRINT "MSG2: ",$sendLog2Data[1]
.first = 0
END
END
ONE errlogudpsend2
UDP_SENDTO .error,logudpadrip[0],logudp.port,$sendlog2data[0],2,2
ONE errlogudpsend2
UDP_SENDTO .error,logudpadrip[0],logudp.port,$sendlog2data[0],2,2
logsendmsgcomm = 0
END
; Zmiana identyfikatora komunikatu
logudpcounter2 = logudpcounter2+1
IF logudpcounter2>99 THEN
logudpcounter2 = 0
END
RETURN
.END
.PROGRAM setreference()
;SIGNAL Ref[type]
;tutaj zdekodowac jaka referencja powinna byc zadana - jest to uzaleznione od kodu pakietu a nie od typu 
; przejcie na nowe kody pakietw 1 z 12 Krzysztof Olejnik
;
IF heatexcode==1 OR heatexcode==2 OR heatexcode==3 OR heatexcode==4 THEN
SIGNAL ref[1]
PRINT "   WYBRANO REF 1"
END
IF heatexcode==5 OR heatexcode>=6 THEN
SIGNAL ref[2]
PRINT "   WYBRANO REF 2"
END
IF (heatexcode>=7 AND heatexcode<=9) THEN
SIGNAL ref[3]
PRINT "   WYBRANO REF 3"
END
IF heatexcode==10 THEN
SIGNAL ref[4]
PRINT "   WYBRANO REF 4"
END
IF heatexcode>=11 AND heatexcode<=12 THEN
SIGNAL ref[5]
PRINT "   WYBRANO REF 5"
END
IF heatexcode<1 OR heatexcode>12 THEN
PRINT "   nie prawidowy heatexcode ! ! ! ! !"
END
RETURN
.END
.PROGRAM settool()
;"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
TOOL NULL
LMOVE narzedzie
BREAK
POINT narzedzie1 = narzedzie+RZ(-90)
LMOVE narzedzie1
BREAK
PAUSE
LMOVE narzedzie
BREAK
POINT narzedzie2 = narzedzie+RZ(90)
LMOVE narzedzie2
BREAK
PAUSE
POINT/OAT p1 = NULL
POINT/OAT p2 = NULL
POINT mytool = p2-p1
TOOL TRANS(DY(mytool)/2,-DX(mytool)/2)
.END
.PROGRAM signals()
MC ZPOWER ON
IF SIG(testok,-testnok,-testokk) THEN ;podtrzymanie wyniku testu w ateq 
PRINT " ustawiamy synal: testokk = true"
SIGNAL testokk
END
;
;
; analiza zmian sygnalow z atq
IF SIG(testok)<>SIG(tok_m) THEN
PRINT "! ! ! testok =",SIG(testok)
IF SIG(testok) THEN
SIGNAL tok_m
ELSE
SIGNAL -tok_m
END
END
IF SIG(testnok)<>SIG(tnok_m) THEN
PRINT "! ! ! tnok =",SIG(testnok)
IF SIG(testnok) THEN
SIGNAL tok_m
ELSE
SIGNAL -tok_m
END
END
IF SIG(testokk)<>SIG(tokk_m) THEN
PRINT "! ! ! testokk =",SIG(testokk)
IF SIG(testokk) THEN
SIGNAL tokk_m
ELSE
SIGNAL -tokk_m
END
END
IF SIG(potoncross)<>SIG(ptc_m) THEN
PRINT "! ! ! potoncross =",SIG(potoncross)
IF SIG(potoncross) THEN
SIGNAL ptc_m
ELSE
SIGNAL -ptc_m
END
END
IF SIG(testinprogres)<>SIG(tip_m) THEN
PRINT "! ! ! testinprogres =",SIG(testinprogres)
IF SIG(testinprogres) THEN
SIGNAL tip_m
ELSE
SIGNAL -tip_m
END
END
; koniec analizy
;
;
IF SWITCH(POWER ) AND SWITCH(CS ) THEN ;jesli nie beda chodzic teraz transportery to wyrzucic warunek SWITCH(CS)
IF SIG(-trmanual) THEN
;automatyczna praca transporterow 
FOR n = 1 TO 2
IF SIG(-stoptransporter[n]) THEN
SIGNAL trready[n]
ELSE
SIGNAL -trready[n]
END
IF (SIG(-objectnotin[n]) OR SIG(sensorfront[n])) AND SIG(-sensorback[n],-moveout[n]) THEN
SIGNAL moveobject[n]
SIGNAL qtyok[n]
SIGNAL -qtynok[n]
IF n==1 THEN
SIGNAL -needpaletts
ELSE
SIGNAL -needspacers
END
;SIGNAL -ErrorTr[n]
END
IF SIG(sensorback[n]) THEN
SIGNAL -moveobject[n]
SIGNAL -trready[n]
END
IF SIG(-sensorback[n],moveobject[n],trready[n]) THEN
SIGNAL goback[n]
IF logowanie==TRUE THEN
PRINT "goback[",n,"] 1"
END
ELSE
SIGNAL -goback[n]
IF logowanie==TRUE THEN
PRINT "-goback[",n,"] 2"
END
END
;gdy wjechalo za duzo palet/przekladek 
IF SIG(moveout[n]) THEN
IF SIG(sensorback[n]) AND (SIG(sensorfront[n]) OR SIG(-objectnotin[n])) THEN
;gdy mam cos przy robocie i cos czekajace na wjazd to wystaw error i zatrzymaj linie 
SIGNAL -moveobjectout[n]
SIGNAL errortrblocked[n]
END
IF SIG(sensorback[n],-sensorfront[n],objectnotin[n],-stoptransporter[n],-errortrblocked[n]) THEN
SIGNAL moveobjectout[n]
END
IF SIG(sensorfront[n]) THEN
SIGNAL -moveobjectout[n]
END
IF SIG(-sensorfront[n],moveobjectout[n]) THEN
SIGNAL goforward[n]
IF logowanie==TRUE THEN
PRINT "goforward[",n,"] 3"
END
ELSE
SIGNAL -goforward[n]
IF logowanie==TRUE THEN
PRINT "-goforward[",n,"] 4"
END
END
ELSE
SIGNAL -goforward[n]
IF logowanie==TRUE THEN
PRINT "-goforward[",n,"] 5"
END
END
END
;TR3
IF SIG(trready[3],sensorback[3]) THEN
SIGNAL moveobject[3]
END
IF SIG(sensorfront[3]) THEN
SIGNAL -moveobject[3]
SIGNAL -trready[3]
END
IF SIG(moveobject[3],-sensorfront[3],trready[3]) THEN
SIGNAL goforward[3]
IF logowanie==TRUE THEN
PRINT "goforward[3] 6"
END
ELSE
SIGNAL -goforward[3]
IF logowanie==TRUE THEN
PRINT "-goforward[3] 7"
END
END
IF safeprocedure AND SIG(-trready[3]) THEN
;potrzebne na poczatku, gdy nie widze nic na sensorach i przez 15s krece transporterami 
;w kierunku robota, zeby ewentualnie cos dojechalo
END
ELSE ;warunek o SIG(-TrManual)
SIGNAL -moveobject[1]
SIGNAL -moveobject[2]
SIGNAL -moveobject[3]
SIGNAL -moveobjectout[1]
SIGNAL -moveobjectout[2]
IF log70==TRUE THEN
PRINT "jestem tu 70"
END
FOR n = 1 TO 3
IF log70==TRUE THEN
PRINT "jestem tu 71"
END
IF SIG(mantrforward[n]) THEN
SIGNAL goforward[n]
IF logowanie==TRUE THEN
PRINT "goforward[",n,"] 8"
END
ELSE
SIGNAL -goforward[n]
IF logowanie==TRUE THEN
PRINT "-goforward[",n,"] 9"
END
END
IF SIG(mantrback[n]) THEN
SIGNAL goback[n]
IF logowanie==TRUE THEN
PRINT "goback[",n,"] 10"
END
ELSE
SIGNAL -goback[n]
IF logowanie==TRUE THEN
PRINT "-goback[",n,"] 11"
END
END
END
END
ELSE ;jesli nie ma power ->przecieta kurtyna, gdyby byl grzyb to sprzetowo jest wylaczane wszystko
IF SIG(-trmanual) THEN
;jesli jest tryb reczny to tam wylacza sie transportery 
FOR n = 1 TO 3
SIGNAL -goforward[n]
SIGNAL -moveobject[n]
SIGNAL -goback[n]
IF logowanie==TRUE THEN
PRINT "-goforward[",n,"] 12"
PRINT "-goback[",n,"] 13"
END
END
SIGNAL -moveobjectout[1]
SIGNAL -moveobjectout[2]
END
FOR n = 1 TO 2
IF SIG(moverequest[n],objectnotin[n]) THEN ;jest ObjectNotIn bo sensor ma odwrocona logike
SIGNAL goback[n]
IF logowanie==TRUE THEN
PRINT "goback[",n,"] 14"
END
ELSE
SIGNAL -goback[n]
IF logowanie==TRUE THEN
PRINT "-goback[",n,"] 15"
END
END
END
IF SIG(moverequest[3]) THEN  ;pedal wcisniety
IF SIG(sensorfront[3],-sensorback[3]) THEN
SIGNAL goforward[3]
IF logowanie==TRUE THEN
PRINT "goforward[3] 16"
END
ELSE
SIGNAL -goforward[3]
IF logowanie==TRUE THEN
PRINT "-goforward[3] 17"
END
END
ELSE
SIGNAL -goforward[3]
IF logowanie==TRUE THEN
PRINT "-goforward[3] 18"
END
END
IF SIG(trmanual) THEN
FOR n = 1 TO 3
IF SIG(mantrforward[n]) THEN
SIGNAL goforward[n]
IF logowanie==TRUE THEN
PRINT "goforward[",n,"] 19"
END
ELSE
SIGNAL -goforward[n]
IF logowanie==TRUE THEN
PRINT "-goforward[",n,"] 20"
END
END
IF SIG(mantrback[n]) THEN
SIGNAL goback[n]
IF logowanie==TRUE THEN
PRINT "goback[",n,"] 21"
END
ELSE
SIGNAL -goback[n]
IF logowanie==TRUE THEN
PRINT "-goback[",n,"] 22"
END
END
END
END
END ;koniec ifa odnosnie switch(power)
;oblsuga mrugania lampki gdy paleta jest zapelniona w ponad 80%
IF SIG(getpaletteblink) THEN
IF TIMER(2)>1 THEN ;co jedna sekunde zrob:
TIMER (2) = 0  ;wyzeruj timer
IF SIG(getpalette) THEN
SIGNAL -getpalette  ;jesli lampka sie pali to ja zgas
ELSE
SIGNAL getpalette  ;jesli lampka jest zgaszona to ja zapal 
END
END
END
;PRZEKAZYWANIE SYGNALOW DO PLC 
;wago
FOR n = 33 TO 80
IF SIG(1000+n) THEN ;przekazanie wejsc WAGO
SIGNAL (112+n)
ELSE
SIGNAL -(112+n)
END
IF SIG(n) THEN ;przekazanie wyjsc WAGO
SIGNAL (160+n)
ELSE
SIGNAL -(160+n)
END
END
;analog wago in
FOR wordcount = 0 TO 9
BITS 241+wordcount*16+8,8 = BITS(1081+wordcount*16,8)
BITS 241+wordcount*16,8 = BITS(1081+wordcount*16+8,8)
;BITS 256+wordCount*16,-16=BITS (1081+wordCount*16,16)
END
;FOR n = 81 TO 176 
;	IF SIG(1000+n) THEN	;analog wago in
;		SIGNAL (241+(176-n)) 
;	ELSE
;		SIGNAL -(241+(176-n))
;	END	
;END
;shunk
FOR n = 241 TO 368
IF SIG(1000+n) THEN ;shunk in
SIGNAL (160+n)
ELSE
SIGNAL -(160+n)
END
END
FOR n = 81 TO 144
IF SIG(n) THEN ;shunk out
SIGNAL (448+n)
ELSE
SIGNAL -(448+n)
END
END
;OCZEKIWANIE AZ SHUNK DOJEDZIE NA POZYCJE 
IF waitforshunkmov THEN
;response = BITS(1185,8)
response = BITS(1249,8)
IF response==148 OR response==147 THEN ;"position reached" lub "pos blocked" 
SIGNAL -waitforshunkmov
END
END
IF SIG(makingtestateq) AND readytotest THEN
PCABORT 3: 
PCEXECUTE 3: ateqtest
readytotest = FALSE
END
IF SIG(errortr[1]) OR SIG(errortr[2]) THEN
IF SIG(errorconf) THEN
SIGNAL errorconfhold
END
ELSE
SIGNAL -errorconfhold
END
IF SIG(sch_manual) THEN
BITS 81+16+8,16 = sch_move
response1 = BITS(1249,8)
response2 = BITS(1257,8)
END
IF SIG(manfinop) THEN
;wykrycie z IFPanelu sygnalu do otwarcia palcow
SIGNAL -44
TWAIT 0.5
SIGNAL 45
END
IF SIG(manfincl) THEN
;wykrycie z IFPanelu sygnalu do zamkniecia palcow
SIGNAL -45
TWAIT 0.5
SIGNAL 44
END
IF SIG(shunkerrorreset) THEN
BITS 81+16,16 = 0  ;zerowanie dalszych parametrow wysylanych shunkowi
BITS 81+16+8,16 = 0  ;zerowanie dalszych parametrow wysylanych shunkowi
BITS 81,8 = 1
BITS 89,8 = 139 ;zresetuj ten error
TWAIT 0.5
BITS 81,8 = 1
BITS 89,8 = 146
TWAIT 0.5
TIMER (1) = 0
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov) OR TIMER(1)>10 ;czekam na odpowiedz shunka
BITS 81,8 = 5
BITS 89,8 = 176
BITS 81+16,16 = 0
BITS 81+16+8,16 = 530
TIMER (1) = 0
TWAIT 0.5
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov) OR TIMER(1)>10 ;czekam na odpowiedz shunka
END
.END
.PROGRAM srch()
;funkcja uzywana do szukania palet/przekladek - sprawdzanie ile ich jest
found = FALSE
WAIT SIG(-palettedetect)
WAIT SIG(palettedetect)
POINT rise = HERE
found = TRUE
.END
.PROGRAM srchoy()
;sprawdzanie przesuniecia palet/przekladek po OY - wzdluz dluzszej osi zeby bylo wiadomo jak leza  
found = FALSE
IF SIG(palettedetect) THEN
WAIT SIG(-palettedetect) ;jesli nie trafilem w otwor to bede sprawdzal gdzie sie zaczyna jade +OY 
ELSE
WAIT SIG(palettedetect)  ;trafilem w otwor bede patrzyl gdzie sie konczy	jade -OY
END
POINT rise = HERE
found = TRUE
.END
.PROGRAM stop_tr()
FOR i = 1 TO 3
;SIGNAL -mantrback[i] ;wylacz wszystkie transportery
;SIGNAL -mantrforward[i]
SIGNAL -goback[i]
SIGNAL -goforward[i]
END
.END
.PROGRAM stoptr()
FOR i = 1 TO 3
;SIGNAL -mantrback[i] ;wylacz wszystkie transportery
;SIGNAL -mantrforward[i]
SIGNAL -goback[i]
SIGNAL -goforward[i]
END
RETURN
.END
.PROGRAM tcpclose()
TCP_END_LISTEN retval,portno
.END
.PROGRAM tcptest()
PRINT ""
TCP_LISTEN retval,portno
PRINT "LISTEN RetVal",retval
TCP_ACCEPT socketid,portno,accepttimeout
PRINT "ACCEPT SocketID",socketid
IF socketid>=0 THEN
TCP_RECV retval,socketid,$received[1],size,recvtimeout
PRINT $received[1]
PRINT VAL($received[1])
ELSE
PRINT "ERROR"
END
TCP_END_LISTEN retval,portno
PRINT "End"
PRINT ""
.END
.PROGRAM test()
CP ON
SPEED spd ALWAYS
ACCEL acc ALWAYS
DECEL acc ALWAYS
ACCURACY acu ALWAYS
JMOVE #mid
JMOVE #ru
JMOVE #rd
JMOVE #ru
JMOVE #mid
JMOVE #lu
JMOVE #ld
JMOVE #lu
JMOVE #mid
.END
.PROGRAM testingpaletisi()
PAUSE
JAPPRO p1,800
;tu otworzyc szczeki
PAUSE
width = (jawwidth[type]+80)
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
PRINT width
PAUSE
LMOVE p1
PAUSE
;tu zamknac szczeki
width = jawwidth[type]
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
PAUSE
SIGNAL -openfingers
WAIT SIG(leftfingerc,rightfingerc,-leftfingero,-rightfingero)
LAPPRO p1,200
POINT putpackage = SHIFT(init_put[type] BY xdist[type]*(colcount-1),-ydist[type]*(rowcount-1),(pacheight[type]+spacerthicknes)*(layercount-1))
;POINT putPackage = init_put[type]
LAPPRO putpackage,pacheight[type]+300
LMOVE putpackage
SIGNAL openfingers
WAIT SIG(-leftfingerc,-rightfingerc,leftfingero,rightfingero)
;otworzyc szczeki 
LAPPRO putpackage,-10
width = (jawwidth[type]+80)
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
LAPPRO putpackage,pacheight[type]+300
colcount = colcount+1
IF colcount>maxcolcount[type] THEN
colcount = 1
rowcount = rowcount+1
IF rowcount>maxrowcount[type] THEN
rowcount = 1
SIGNAL layerfull[layercount]
IF layercount<2 THEN
;poloz przekladke i pracuj nad druga warstwa
CALL putspacer
JMOVE #safe
CALL putoutgripper;odlozenie chwytaka
ELSE
CALL moveoutfullpale
END
;layerCount = layerCount + 1
END
END
.END
.PROGRAM testlja()
;czekanie na sygnal o tym, ze przyjechal pakiet i przypisanie go do odpowiedniego typu wg rozmiaru
decoded = FALSE
WHILE decoded==FALSE DO
TWAIT 1
CALL allowentrance
oldheatexcode = -1
WHILE SIG(-packagewaits) DO ;dopoki nie dostane syg ze pakiet przyjechal to zezwalam na wejscie lub pauze  
heatexcode = BITS(packagetype,5)
IF oldheatexcode<>heatexcode THEN
SIGNAL -ref[1]
SIGNAL -ref[2]
SIGNAL -ref[3]
SIGNAL -ref[4]
SIGNAL -ref[5]
CALL setreference
oldheatexcode = heatexcode
END
CALL allowentrance
IF SIG(endcycle) THEN ;jesli jest sygnal o koncu pracy to oproznij stanowisko 
CALL emptyworkstatio
SIGNAL endconf ;sygnal do plc ze skonczylem procedure oprozniania 
WHILE SIG(endconf) DO
SIGNAL stoptransporter[1]
SIGNAL stoptransporter[2]
SIGNAL -trready[3]
SIGNAL enterconf  ;koniec pracy wpuszczam ludzi i sie zatrzymuje (petla while)
END
END
$actualdatea = $DATE(1)
IF $prevdatea<>$actualdatea THEN ;jesli mamy nowy dzien to przejedz shunkiem max-min zeby go nasmarowac
SIGNAL ateqcal
TWAIT 1
WAIT SIG(ateqcalok)
SIGNAL -ateqcal
$prevdatea = $actualdatea
END
END
SIGNAL -errornoheatex
prevtype = type
prevcode = heatexcode
;=====zakomentowac linijke ponizej jak bedzie komunikacja z PLC
;BITS PackageType, 5 = pType
;=====================
heatexcode = BITS(packagetype,5)
;przypisanie odpowiedniego kodu pakietu do odpowiedniego typu
CALL decodetype
IF decoded==FALSE THEN
SIGNAL errorheatexwron
ELSE
SIGNAL -errorheatexwron
END
SIGNAL -heatexonpalette
SIGNAL -heatexoncross
SIGNAL -stoptransporter[1]
SIGNAL -stoptransporter[2]
IF firstcycle AND SIG(-errorheatexwron) THEN
prevtype = type ;zeby nie wyjechala pusta paleta
prevcode = heatexcode ;zeby nie wyjechala pusta paleta
firstcycle = FALSE
END
END
.END
.PROGRAM testlog()
.$tekst = "TEst"
CALL log(.$tekst)
CALL log("Piotr F")
CALL log2("Akupaku")
CALL log2("Piotr F")
CALL log("Ak33333upaku")
.value = 12.2
CALL log("Wartosc = "+$ENCODE(/F4.1,.value))
CALL testemptyloop
CALL log("Rozpoczecie testow czasu logowania")
CALL loge("Error")
CALL logw("Warrning")
CALL logi("Info")
CALL logm("Message")
CALL logd("Dane")
CALL logt("Tlo")
CALL logint("Linczba Int = ",37)
CALL lognum("Liczba num = ",45.234)
CALL logposee
CALL logposej
CALL log2e("Error")
CALL log2w("Warrning")
CALL log2i("Info")
CALL log2m("Message")
CALL log2d("Dane")
CALL log2t("Tlo")
CALL log2int("Linczba Int = ",37)
CALL log2num("Liczba num = ",45.234)
CALL logposej
FOR .no = 1 TO 100
CALL log("Test nr: "+$ENCODE(/F4.0,.no))
CALL log2("Test log kom, "+$ENCODE(/F4.0,.no))
END
PRINT "Test predkosci logowania, nr 1"
.counter = 0
RETURN
.END
.PROGRAM testpalateq()
JMOVE #safet
IF SIG(havegripper,-leftgripper) THEN ;nie moge jechac w te rejony z chwytakiem 
CALL putoutgripper
END
SIGNAL -leavepalette  ;jezdzimy z zamknietymi szczekami do lapania palet (silownik schowany)	
WAIT SIG(-palettegrippero,palettegripperc)
JMOVE next_conveyors
LMOVE #before_heatex
;CALL allowEntrance ;jesli ktos zglosil chec wejscia to
TOOL small_gripper
LMOVE #midway
LMOVE SHIFT(next_conveyors BY 0,-150,-200)+RZ(-300)
LMOVE #before_ateqr
LMOVE wait_ateq
SPEED ateqspd MM/S ALWAYS
;stoje przed ateq
;ODKOMENTOWAC GDY BEDZIE JUZ OBSLUGA ATEQ
SIGNAL -changepos
FOR i = 1 TO 5
SIGNAL -ref[i]
END
BREAK
FOR i = 1 TO 6
SIGNAL -ateqpos[i]
END
BREAK
SIGNAL hatup
SIGNAL -hatdown
WAIT SIG(hatisup,-hatisdown)
BREAK
SIGNAL ateqpos[1] ; odjazd max do gory
SIGNAL changepos
WAIT SIG(ateqinpos)
SIGNAL -ateqpos[1]
SIGNAL -changepos
BREAK
;KONIEC PRZYGOTOWANIA ATEQ
SPEED ateqspd MM/S ALWAYS
WAIT SIG(-testinprogres)
LMOVE wait_test
;LMOVE wait_ateq
;SIGNAL OpenFingers
;WAIT SIG(-LeftFingerC,-RightFingerC,LeftFingerO,RightFingerO)
;width = (jawWidth[type] + 70)
;BITS 81+16,16 = 0
;BITS 81+16+8,16 = width
;TWAIT(3)
LAPPRO ateq,-20
TWAIT (0.5)
LAPPRO ateq,-underateq[type]    ;jestem w ATEQ - podjazd zeby sito bylo miedzy szczekami
TWAIT 0.5
IF SIG(-heatexingripper) THEN
SIGNAL errorateq   ;wstawilem cos do ateq a teraz to zniknelo 
loop = TRUE
WHILE loop DO
SIGNAL errorateq
END
END
WAIT SIG(donext) ;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
SIGNAL -donext
width = jawwidth[type]
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
cshunkpos = BITS(1201,16) ;current Shunk Position odczytanie na jakiej pozycji stanal shunk
BITS 81+16,16 = 0
BITS 81+16+8,16 = cshunkpos+3  ;lekkie rozwarcie - pakiet nie spadnie a shunk bedzie "na pozycji"
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
LMOVE ateq
TWAIT (0.5)
LAPPRO ateq,5 ;troche w gore - gorne sito opiera sie na szczekach 
TWAIT (0.5)
SIGNAL -openfingers
WAIT SIG(leftfingerc,rightfingerc,-leftfingero,-rightfingero)
LAPPRO ateq,15
WAIT SIG(donext) ;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
SIGNAL -donext
LMOVE wait_ateq
SPEED spd MM/S ALWAYS
LMOVE #before_ateqr
IF SIG(testokk,-testnok) THEN
SIGNAL -testokk
SIGNAL -heatexinateq
;wszystko ponizej dzieje sie gdy test ateq wyjdzie dobrze 
JMOVE #safe90
JMOVE #before_put
;punkt gdzie odstawic pakiet- zalezne od tego ile juz istawilem 
POINT putpackage = SHIFT(initial_put[type] BY -xdist[type]*(colcount-1),-ydist[type]*(rowcount-1),(pacheight[type]+spacerthicknes)*(layercount-1))
JAPPRO putpackage,(pacheight[type]+50)
SPEED slow MM/S ALWAYS
LMOVE putpackage
TWAIT (0.5)
SIGNAL openfingers
WAIT SIG(-leftfingerc,-rightfingerc,leftfingero,rightfingero)
LAPPRO putpackage,-20   ;zjazd w dol - zeby pakiet nie byl na szczekach
IF type<>2 AND type<>5 THEN
width = (jawwidth[type]+120)  ;rozsuniecie szczek
ELSE
width = (jawwidth[type]+100)
END
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
WAIT SIG(donext) ;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
SIGNAL -donext
LAPPRO putpackage,pacheight[type]+50 ;odjazd w gore 
SPEED spd MM/S ALWAYS
palettenotempty = TRUE ;flaga zeby pomimo zmieny typu pakietu nie wyjechala pusta paleta
;gasze bo wlasnie cos na niej postawilem
colcount = colcount+1
IF colcount>maxcolcount[type] THEN
colcount = 1
rowcount = rowcount+1
IF rowcount>maxrowcount[type] THEN
rowcount = 1
SIGNAL layerfull[layercount]
IF layercount<2 THEN
;poloz przekladke i pracuj nad druga warstwa
LAPPRO putpackage,pacheight[type]+100
TOOL big_gripper
gotosafe = FALSE ;zeby pojachal tutaj bezposrednio nad chwytak a nie do #safeT uzywane w getGripper
CALL putspacer
SIGNAL spacerputted[1]
CALL putoutgripper;odlozenie chwytaka
gotobp = FALSE ;go to before put
ELSE
gotosafe = FALSE
TOOL big_gripper
CALL moveoutfullpale
gotobp = FALSE
END
END
END
SIGNAL heatexonpalette
ELSE ;test wyszedl zle 
LMOVE #before_ateqr
LMOVE SHIFT(next_conveyors BY 0,-150,-200)+RZ(-300)
SIGNAL -heatexinateq
;IF SIG(-TestOk,TestNOK)
LMOVE #midway
WAIT SIG(potoncross)
LAPPRO before_heatexch,40
SPEED slow MM/S ALWAYS
LAPPRO pick_heatexch,40
TWAIT (0.5)
SIGNAL openfingers
WAIT SIG(-leftfingerc,-rightfingerc,leftfingero,rightfingero)
LMOVE pick_heatexch
LAPPRO pick_heatexch,-10   ;zjazd w dol - zeby pakiet nie byl na szczekach
width = (jawwidth[type]+80)  ;rozsuniecie szczek
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
WAIT SIG(donext) ;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
SIGNAL -donext
LAPPRO before_heatexch,20
SPEED spd MM/S ALWAYS
SIGNAL heatexoncross
LMOVE #midway
LMOVE SHIFT(next_conveyors BY 0,-150,-200)+RZ(-300)
TOOL big_gripper
JMOVE #safe90
JMOVE #safet
gotobp = FALSE
;ELSE
;LMOVE #before_ateq
;LMOVE #midway
;END
END
IF gotobp THEN
JMOVE #before_putr
END
gotobp = TRUE
TOOL big_gripper
JMOVE #safet
.END
.PROGRAM testpaletising()
noheatexerror = TRUE
WHILE noheatexerror DO
JMOVE #safet
IF SIG(havegripper,-leftgripper) THEN ;nie moge jechac w te rejony z chwytakiem 
CALL putoutgripper
END
SIGNAL -leavepalette  ;jezdzimy z zamknietymi szczekami do lapania palet (silownik schowany)	
WAIT SIG(-palettegrippero,palettegripperc)
JMOVE next_conveyors
LMOVE #before_heatex
;CALL allowEntrance ;jesli ktos zglosil chec wejscia to
TOOL small_gripper
SIGNAL openfingers   ;otwieram chwytak do pakietow
WAIT SIG(-leftfingerc,-rightfingerc,leftfingero,rightfingero)
;zteachowany jest punkt pick_heatEx 
;jest to punkt dla pakietu o min wysokosci
POINT pick_heatexch = SHIFT(pick_heatex BY 0,0,pacheight[type]-minpacheight+pickcorrection[type])
POINT before_heatexch = pick_heatexch+TRANS(0,-500) ;punkt do wyjazdu z miejsca podniesienia pakietu 
LAPPRO before_heatexch,-20
SPEED slow MM/S ALWAYS
IF type<>5 AND type<>4 THEN
width = (jawwidth[type]+120)
ELSE
width = (jawwidth[type]+90) ;jesli to te najwieksze wymienniki to nie moge sie bardziej rozsunac bo wypadne z prowadnic
END
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
LAPPRO pick_heatexch,-20
TWAIT (0.5)
LMOVE pick_heatexch
TWAIT 0.5
WAIT SIG(donext) ;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
SIGNAL -donext
IF SIG(-heatexingripper) THEN  ;jednak nie ma pakietu 
;nie ma co zlapac !!
LMOVE before_heatexch
SPEED spd MM/S ALWAYS
LMOVE #midway
LMOVE SHIFT(next_conveyors BY 0,-150,-200)+RZ(-300)
;LMOVE #before_ateqR	
JMOVE #safe90
JMOVE #safet
TOOL big_gripper
;error nie ma pakietu choc byl packageWaits
SIGNAL errornoheatex
CALL recieve
CALL conveyors
noheatexerror = TRUE
ELSE
noheatexerror = FALSE
END
END
;zamkniecie szczek do pakietow zgodnie z typem pakietu 
TWAIT (0.5)
width = jawwidth[type]
BITS 81+16,16 = 0
BITS 81+16+8,16 = width-20  ;zacisniecie shunka - odpowie Move Blocked
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
cshunkpos = BITS(1201,16) ;current Shunk Position odczytanie na jakiej pozycji stanal shunk
BITS 81+16,16 = 0
BITS 81+16+8,16 = cshunkpos+3  ;lekkie rozwarcie - pakiet nie spadnie a shunk bedzie "na pozycji"
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
LAPPRO pick_heatexch,40
TWAIT (0.5)
SIGNAL (-openfingers)
WAIT SIG(leftfingerc,rightfingerc,-leftfingero,-rightfingero)
; mam chwycony pakiet
LAPPRO before_heatexch,40
SIGNAL packagetaken
SPEED spd MM/S ALWAYS
LMOVE #midway
LMOVE SHIFT(next_conveyors BY 0,-150,-200)+RZ(-300)
LMOVE #before_ateqr
;STOJE PRZED ATEQ 
TWAIT 1
LMOVE #before_ateqr
IF SIG(testokk,-testnok) THEN
SIGNAL -testokk
SIGNAL -packageinateq
;wszystko ponizej dzieje sie gdy test ateq wyjdzie dobrze 
JMOVE #safe90
JMOVE #before_put
;punkt gdzie odstawic pakiet- zalezne od tego ile juz istawilem 
POINT putpackage = SHIFT(initial_put[type] BY -xdist[type]*(colcount-1),-ydist[type]*(rowcount-1),(pacheight[type]+spacerthicknes)*(layercount-1))
JAPPRO putpackage,(pacheight[type]+50)
SPEED slow MM/S ALWAYS
LMOVE putpackage
TWAIT (0.5)
SIGNAL openfingers
WAIT SIG(-leftfingerc,-rightfingerc,leftfingero,rightfingero)
LAPPRO putpackage,-20   ;zjazd w dol - zeby pakiet nie byl na szczekach
IF type<>2 AND type<>5 THEN
width = (jawwidth[type]+120)  ;rozsuniecie szczek
ELSE
width = (jawwidth[type]+100)
END
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
WAIT SIG(donext) ;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
SIGNAL -donext
LAPPRO putpackage,pacheight[type]+50 ;odjazd w gore 
SPEED spd MM/S ALWAYS
palettenotempty = TRUE ;flaga zeby pomimo zmieny typu pakietu nie wyjechala pusta paleta
;gasze bo wlasnie cos na niej postawilem
colcount = colcount+1
IF colcount>maxcolcount[type] THEN
colcount = 1
rowcount = rowcount+1
IF rowcount>maxrowcount[type] THEN
rowcount = 1
SIGNAL layerfull[layercount]
IF layercount<2 THEN
;poloz przekladke i pracuj nad druga warstwa
LAPPRO putpackage,pacheight[type]+100
TOOL big_gripper
gotosafe = FALSE ;zeby pojachal tutaj bezposrednio nad chwytak a nie do #safeT uzywane w getGripper
CALL putspacer
SIGNAL spacerputted[1]
CALL putoutgripper;odlozenie chwytaka
gotobp = FALSE ;go to before put
ELSE
gotosafe = FALSE
TOOL big_gripper
CALL moveoutfullpale
gotobp = FALSE
END
END
END
SIGNAL packageonpalett
IF layercount>1 THEN
filllvl = (maxcolcount[type]*(rowcount-1)+colcount)/(maxrowcount[type]*maxcolcount[type])
filllvl = filllvl*100  ;teraz mam tu wartosc procentowa zapelnienia palety
IF filllvl>=80 AND filllvl<100 THEN ;jesli zapelnilem ponad 80% palety to zacznij mrugac lampka
SIGNAL getpaletteblink
ELSE
SIGNAL -getpaletteblink
END
END
ELSE ;test wyszedl zle 
LMOVE #before_ateqr
LMOVE SHIFT(next_conveyors BY 0,-150,-200)+RZ(-300)
SIGNAL -packageinateq
;IF SIG(-TestOk,TestNOK)
LMOVE #midway
WAIT SIG(potoncross)
LAPPRO before_heatexch,40
SPEED slow MM/S ALWAYS
LAPPRO pick_heatexch,40
TWAIT (0.5)
SIGNAL openfingers
WAIT SIG(-leftfingerc,-rightfingerc,leftfingero,rightfingero)
LMOVE pick_heatexch
LAPPRO pick_heatexch,-10   ;zjazd w dol - zeby pakiet nie byl na szczekach
width = (jawwidth[type]+80)  ;rozsuniecie szczek
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
WAIT SIG(donext) ;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
SIGNAL -donext
LAPPRO before_heatexch,20
SPEED spd MM/S ALWAYS
SIGNAL packageoncross
LMOVE #midway
LMOVE SHIFT(next_conveyors BY 0,-150,-200)+RZ(-300)
TOOL big_gripper
JMOVE #safe90
JMOVE #safet
gotobp = FALSE
;ELSE
;LMOVE #before_ateq
;LMOVE #midway
;END
END
IF gotobp THEN
JMOVE #before_putr
END
gotobp = TRUE
TOOL big_gripper
JMOVE #safet
.END
.PROGRAM testpaletyzacji()
CALL conveyors
;pojechanie po pakiet i wstawienie go do ateq 
;noHeatExError = true
;WHILE noHeatExError 
JMOVE #safet
IF SIG(havegripper,-leftgripper) THEN ;nie moge jechac w te rejony z chwytakiem 
;jesli trzymam chwytak to jade go odstawic 
CALL putoutgripper
END
SIGNAL -leavepalette  ;jezdzimy z zamknietymi szczekami do lapania palet (silownik schowany)
SIGNAL grabpalette
WAIT SIG(-palettegrippero,palettegripperc)
SPEED fastspd
SPEED fastmms MM/S,fastdeg DEG/S
JMOVE next_conveyors
SPEED fastspd
SPEED fastmms MM/S,fastdeg DEG/S
LMOVE #before_heatex;obrot miedzy winda a ateq - specjalnie spowolniony 
SPEED deg ALWAYS
;ZMIANA TOOLA !! 
TOOL small_gripper
SIGNAL -closefingers
SIGNAL openfingers   ;otwieram chwytak do pakietow
WAIT SIG(-leftfingerc,-rightfingerc,leftfingero,rightfingero)
;zapisany jest punkt pick_heatEx 
;jest to punkt dla pakietu o min wysokosci
POINT pick_heatexch = SHIFT(pick_heatex BY 0,0,pacheight[type]-minpacheight+pickcorrection[type])
POINT before_heatexpi = pick_heatexch+TRANS(0,-350) ;punkt do wyjazdu z miejsca podniesienia pakietu 
SPEED fastspd
SPEED fastmms MM/S,fastdeg DEG/S
LAPPRO before_heatexpi,-20
SPEED slow MM/S ALWAYS
;otwarcie szczek zeby zlapac pakiet 
;zwiekszylem rozwarcie szczek o 25 mm aby swobodniej pobierac pakiet ze skrzyzowania
IF type<>5 AND type<>4 THEN
width = (jawwidth[type]+220)
ELSE
;jesli to te najwieksze wymienniki to nie moge sie bardziej rozsunac bo wypadne z prowadnic
width = (jawwidth[type]+190)
END
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
BREAK
TWAIT (0.2)
BREAK
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
LAPPRO pick_heatexch,-20
BREAK
LMOVE pick_heatexch;podjazd po wymiennik 
BREAK
;WAIT SIG(doNext)	;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
;SIGNAL -doNext
;IF SIG(-HeatExInGripper) THEN 	;jednak nie ma pakietu 
IF SIG(-heatexingripper) THEN  ;jednak nie ma pakietu 
;nie ma co zlapac !! odjazd z powrotem do safeT
LMOVE before_heatexpi
SIGNAL errornoheatex
SPEED spd MM/S ALWAYS
LMOVE #midway
LMOVE SHIFT(next_conveyors BY 0,-150,-200)+RZ(-300)
JMOVE #safe90
JMOVE #safet
TOOL big_gripper
;error nie ma pakietu choc byl sygnal packageWaits
;noHeatExError = true
;WAIT SIG(ErrorConfHold) ;czekam az ktos potwierdzi error
;i jeszcze raz czekam na sygnal o tym, ze przyjechal pakiet 
;CALL receive
WHILE SIG(errornoheatex) DO ;nieskonczona petla  
SIGNAL errornoheatex
END
END
;ELSE
;jesli za pierwszym razem nic nie znalazlem a teraz juz cos jest to zgas error 
;	noHeatExError = false
;END
;END
;wykrylem pakiet 
;zamkniecie szczek do pakietow zgodnie z typem pakietu
TWAIT (0.05)
width = jawwidth[type]
BITS 81+16,16 = 0
BITS 81+16+8,16 = width-20  ;zacisniecie shunka za mocno - odpowie Move Blocked
TWAIT (0.2)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
BREAK
TWAIT (0.2)
BREAK
LAPPRO pick_heatexch,20
BREAK
;cShunkPos = BITS(1201,16)	;stary nr bitu przed dodaniem kolejnego modulu wago - moze sie przyda 
cshunkpos = BITS(1265,16) ;current Shunk Position odczytanie na jakiej pozycji stanal shunk
;poluzowanie uchwytu schunka aby pakiet opadl na "polki" szczek
BITS 81+16,16 = 0
BITS 81+16+8,16 = cshunkpos+8  ;rozwarcie szczek aby pakiet opadl na "polki" szczek
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
BREAK
TWAIT 0.5
BREAK
;zacisniecie szczek
BITS 81+16,16 = 0
BITS 81+16+8,16 = width-20  ;zacisniecie shunka za mocno - odpowie Move Blocked
TWAIT (0.2)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
BREAK
TWAIT 0.5
BREAK
;cShunkPos = BITS(1201,16)	;stary nr bitu przed dodaniem kolejnego modulu wago - moze ssie przyda 
cshunkpos = BITS(1265,16) ;current Shunk Position odczytanie na jakiej pozycji stanal shunk
BITS 81+16,16 = 0
BITS 81+16+8,16 = cshunkpos+3  ;lekkie rozwarcie szczek - pakiet nie spadnie a shunk bedzie "na pozycji"
TWAIT (0.2)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
LAPPRO pick_heatexch,40
BREAK
SIGNAL closefingers
SIGNAL (-openfingers)
WAIT SIG(leftfingerc,rightfingerc,-leftfingero,-rightfingero)
;mam chwycony pakiet
LAPPRO before_heatexpi,40
SIGNAL heatextaken
SPEED spd MM/S ALWAYS
LMOVE #midway
LMOVE SHIFT(next_conveyors BY 0,-150,-200)+RZ(-300)
JMOVE #safe90
;jade do punktu na wprost do tr3 
JMOVE #before_put
;punkt gdzie odstawic pakiet- zalezne od tego ile juz ustawilem 
POINT putpackage = SHIFT(initial_put[type] BY -xdist[type]*(colcount-1),-ydist[type]*(rowcount-1),(pacheight[type]+spacerthicknes)*(layercount-1))
JAPPRO putpackage,(pacheight[type]+50)
SPEED spd/3 MM/S
LAPPRO putpackage,(pacheight[type]/2+50)
SPEED slow MM/S ALWAYS
LAPPRO putpackage,20
BREAK
SPEED supslow MM/S ALWAYS
ACCURACY supacu ALWAYS
LMOVE putpackage
TWAIT (0.5)
SIGNAL -closefingers
SIGNAL openfingers
WAIT SIG(-leftfingerc,-rightfingerc,leftfingero,rightfingero)
LAPPRO putpackage,-20   ;zjazd w dol - zeby pakiet nie byl na szczekach
SPEED slow MM/S ALWAYS
ACCURACY acu ALWAYS
BREAK
IF type<>2 AND type<>5 THEN
width = (jawwidth[type]+120)  ;rozsuniecie szczek
ELSE
width = (jawwidth[type]+100)
END
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
;WAIT SIG(doNext)	;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
;SIGNAL -doNext
LAPPRO putpackage,pacheight[type]+50 ;odjazd w gore
SIGNAL heatexonpalette
SPEED spd MM/S ALWAYS
palettenotempty = TRUE ;flaga zeby pomimo zmieny typu pakietu nie wyjechala pusta paleta
;gasze bo wlasnie cos na niej postawilem teraz paleta nie jest pusta 
colcount = colcount+1
IF colcount>maxcolcount[type] THEN
colcount = 1
rowcount = rowcount+1
IF rowcount>maxrowcount[type] THEN
rowcount = 1
SIGNAL layerfull[layercount]
;od razu ustawiam ostatnia rzekladke dla pakietow z iloscia rurek ponad 30 - wtedy mam na to czas 
;srodkowa przekladka jest kladziona zawsze w trakcie testu kolejnego pakietu 
IF layercount>1 AND (type>1 AND heatexcode<>4 AND heatexcode<>5) THEN
gotosafe = FALSE
TOOL big_gripper
CALL moveoutfullpale
gotobp = FALSE
END
END
END
;sprawdzam czy nie zaczac migac lampka, ze zaraz zapelnie cala palete i trzeba bedzie ja zabrac 
IF layercount>1 THEN
filllvl = (maxcolcount[type]*(rowcount-1)+colcount)/(maxrowcount[type]*maxcolcount[type])
filllvl = filllvl*100  ;teraz mam tu wartosc procentowa zapelnienia palety
IF filllvl>=80 AND filllvl<=100 THEN ;jesli zapelnilem ponad 80% palety to zacznij mrugac lampka
SIGNAL getpaletteblink
ELSE
SIGNAL -getpaletteblink
END
END
IF gotobp THEN
SPEED fastspd
SPEED fastmms MM/S,fastdeg DEG/S
JMOVE #before_putr
END
gotobp = TRUE
TOOL big_gripper
SPEED fastspd
SPEED fastmms MM/S,fastdeg DEG/S
JMOVE #safet
.END
.PROGRAM testpick()
ilepalet = 0 ;ile palet ponad 1 (jesli na tr1 stoi jedna paleta to ilepalet = 0; jesli stoja dwie to ilepalet= 1)
goateq = FALSE
SPEED spd MM/S ALWAYS
JMOVE #safet
JMOVE #safe90
TOOL small_gripper
LAPPRO test_pick,500+160*ilepalet
;jestem wysoko nad, otwieram shunka 
TWAIT (0.2)
SIGNAL openfingers
WAIT SIG(-leftfingerc,-rightfingerc,leftfingero,rightfingero)
IF type<>5 AND type<>4 THEN
width = (jawwidth[type]+120)
ELSE
width = (jawwidth[type]+90) ;jesli to te najwieksze wymienniki to nie moge sie bardziej rozsunac bo wypadne z prowadnic
END
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
LAPPRO test_pick,150+160*ilepalet
SPEED slow MM/S ALWAYS
LAPPRO test_pick,(pacheight[type]-minpacheight)+160*ilepalet
WAIT SIG(donext)
SIGNAL -donext
;mam pakiet miedzy szczekami, zamykam je
width = jawwidth[type]
BITS 81+16,16 = 0
BITS 81+16+8,16 = width-20  ;zacisniecie shunka - odpowie Move Blocked
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
cshunkpos = BITS(1201,16) ;current Shunk Position odczytanie na jakiej pozycji stanal shunk
BITS 81+16,16 = 0
BITS 81+16+8,16 = cshunkpos+3  ;lekkie rozwarcie - pakiet nie spadnie a shunk bedzie "na pozycji"
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
LAPPRO test_pick,40+160*ilepalet
TWAIT (0.5)
SIGNAL (-openfingers)
WAIT SIG(leftfingerc,rightfingerc,-leftfingero,-rightfingero)
; mam chwycony pakiet
LAPPRO test_pick,150+160*ilepalet
SPEED spd MM/S ALWAYS
JMOVE #safe90
IF goateq THEN
CALL gotoateq
END
JMOVE #before_put
POINT putpackage = SHIFT(initial_put[type] BY -xdist[type]*(colcount-1),-ydist[type]*(rowcount-1),(pacheight[type]+spacerthicknes)*(layercount-1))
JAPPRO putpackage,(pacheight[type]+50)
SPEED slow MM/S ALWAYS
LMOVE putpackage
TWAIT (0.5)
SIGNAL openfingers
WAIT SIG(-leftfingerc,-rightfingerc,leftfingero,rightfingero)
LAPPRO putpackage,-20   ;zjazd w dol - zeby pakiet nie byl na szczekach
IF type<>2 AND type<>5 THEN
width = (jawwidth[type]+120)  ;rozsuniecie szczek
ELSE
width = (jawwidth[type]+100)
END
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
WAIT SIG(donext) ;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
SIGNAL -donext
LAPPRO putpackage,pacheight[type]+50 ;odjazd w gore 
SPEED spd MM/S ALWAYS
palettenotempty = TRUE ;flaga zeby pomimo zmieny typu pakietu nie wyjechala pusta paleta
;gasze bo wlasnie cos na niej postawilem
colcount = colcount+1
IF colcount>maxcolcount[type] THEN
colcount = 1
rowcount = rowcount+1
IF rowcount>maxrowcount[type] THEN
rowcount = 1
SIGNAL layerfull[layercount]
IF layercount<2 THEN
;poloz przekladke i pracuj nad druga warstwa
LAPPRO putpackage,pacheight[type]+100
TOOL big_gripper
gotosafe = FALSE ;zeby pojachal tutaj bezposrednio nad chwytak a nie do #safeT uzywane w getGripper
CALL putspacer
SIGNAL spacerputted[1]
CALL putoutgripper;odlozenie chwytaka
gotobp = FALSE ;go to before put
ELSE
gotosafe = FALSE
TOOL big_gripper
CALL moveoutfullpale
gotobp = FALSE
END
END
END
IF layercount>1 THEN
filllvl = (maxcolcount[type]*(rowcount-1)+colcount)/(maxrowcount[type]*maxcolcount[type])
filllvl = filllvl*100  ;teraz mam tu wartosc procentowa zapelnienia palety
IF filllvl>=80 AND filllvl<100 THEN ;jesli zapelnilem ponad 80% palety to zacznij mrugac lampka
SIGNAL getpaletteblink
ELSE
SIGNAL -getpaletteblink
END
END
IF gotobp THEN
JMOVE #before_putr
END
gotobp = TRUE
TOOL big_gripper
JMOVE #safet
.END
.PROGRAM testudp(.$string)
PRINT "Test wysyania komunikatw przez UDP"
IF NOT EXISTREAL("logUDPcounter") THEN
logudpcounter = 0
END
.$senddata[0] = "L0"+$ENCODE(/I2,logudpcounter)
.$senddata[1] = .$string
.$receivedata[0] = ""
.adrip[0] = 192
.adrip[1] = 168
.adrip[2] = 0
.adrip[3] = 6
.portudp = 10064
.waittime = 1
.maxsize = 255
.repeat = 3
.recack = 0
;	WHILE .recAck==0 AND .repeat>0 DO
; Wyslanie komunikatu do PC
UDP_SENDTO .odpudp,.adrip[0],.portudp,.$senddata[0],2,2
;		IF .odpUDP==0 THEN
;			; Oczekiwanie na potwierdzenie odebrania komunikatu
;			UDP_RECVFROM .odpUDP,.portUDP,.$receiveData[0],.numOfElem,.waitTime,.adrIP[0],.maxSize
;			IF .odpUDP==0 THEN
;				PRINT .$receiveData[0]
;				IF .$receiveData[0]==.$sendData[0] THEN
;					.recAck = 1
;				END
;			ELSE
;				PRINT "###  Nie odebrano potwierdzenia odebrania komunikatu"
;			END
;			
;		ELSE
;			PRINT "###  Wystpi bd podczas wysyania danych do PC (UDP)"
;		END
; Zmniejszenie liczby pozostalych prob wyslania komunikatu
;		.repeat = .repeat-1
;	END
logudpcounter = logudpcounter+1
IF logudpcounter>255 THEN
logudpcounter = 0
END
PRINT "Koniec testu wysyania komunikatw przez UDP"
RETURN
.END
.PROGRAM topaleta()
;####################################################################
;# Przeniesienie szczelnego pakietu na palete wyjsciowa
;####################################################################
PRINT "Pakiet na palete wyjsciowa"
TOOL small_gripper
;
;wszystko ponizej dzieje sie gdy test ateq wyjdzie dobrze 
;
SIGNAL -testokk
SIGNAL -heatexputtedina  ;zdjecie sygnau rozpoczecia testu
SPEED (2*spd) MM/S
JMOVE #safe90
;jade do punktu na wprost do tr3 
SPEED (2*spd) MM/S
JMOVE #before_put
;punkt gdzie odstawic pakiet- zalezne od tego ile juz ustawilem 
POINT putpackage = SHIFT(initial_put[type] BY -xdist[type]*(colcount-1),-ydist[type]*(rowcount-1),(pacheight[type]+spacerthicknes)*(layercount-1))
SPEED (2*spd) MM/S
JAPPRO putpackage,(pacheight[type]+50)
SPEED spd/3 MM/S
LAPPRO putpackage,(pacheight[type]/2+50)
TWAIT (0.5)
SIGNAL -closefingers
SIGNAL openfingers
WAIT SIG(-leftfingerc,-rightfingerc,leftfingero,rightfingero)
SPEED slow MM/S ALWAYS
LAPPRO putpackage,20
BREAK
SPEED supslow MM/S ALWAYS
ACCURACY supacu ALWAYS
LMOVE putpackage
LAPPRO putpackage,-20   ;zjazd w dol - zeby pakiet nie byl na szczekach
SPEED slow MM/S ALWAYS
ACCURACY acu ALWAYS
BREAK
IF type<>2 AND type<>5 THEN
width = (jawwidth[type]+120)  ;rozsuniecie szczek
ELSE
width = (jawwidth[type]+100)
END
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
;WAIT SIG(doNext)	;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
;SIGNAL -doNext
;LAPPRO putpackage,pacheight[type]+50 ;odjazd w gore
LAPPRO putpackage,250 ;odjazd w gore krotszy (szybszy)
SIGNAL heatexonpalette
SPEED spd MM/S ALWAYS
palettenotempty = TRUE ;flaga zeby pomimo zmieny typu pakietu nie wyjechala pusta paleta
;gasze bo wlasnie cos na niej postawilem teraz paleta nie jest pusta 
colcount = colcount+1
IF colcount>maxcolcount[type] THEN
colcount = 1
rowcount = rowcount+1
IF rowcount>maxrowcount[type] THEN
rowcount = 1
SIGNAL layerfull[layercount]
;od razu ustawiam ostatnia rzekladke dla pakietow z iloscia rurek ponad 30 - wtedy mam na to czas 
;srodkowa przekladka jest kladziona zawsze w trakcie testu kolejnego pakietu 
IF layercount>1 AND (type>1 AND heatexcode<>4 AND heatexcode<>5) THEN
gotosafe = FALSE
TOOL big_gripper
CALL moveoutfullpale
gotobp = FALSE
END
END
END
;sprawdzam czy nie zaczac migac lampka, ze zaraz zapelnie cala palete i trzeba bedzie ja zabrac 
IF layercount>1 THEN
filllvl = (maxcolcount[type]*(rowcount-1)+colcount)/(maxrowcount[type]*maxcolcount[type])
filllvl = filllvl*100  ;teraz mam tu wartosc procentowa zapelnienia palety
IF filllvl>=80 AND filllvl<=100 THEN ;jesli zapelnilem ponad 80% palety to zacznij mrugac lampka
SIGNAL getpaletteblink
ELSE
SIGNAL -getpaletteblink
END
END
RETURN
.END
.PROGRAM torobass()
;####################################################################
;# Przeniesienie szczelnego pakietu na transporter do robAssembly
;####################################################################
PRINT "Pakiet na transporter do robAssembly"
;odlozenie pakietu do spawania galanterii
TOOL small_gripper
;wszystko ponizej dzieje sie gdy test ateq wyjdzie dobrze 
SIGNAL -testokk
SIGNAL -heatexputtedina  ;zdjecie sygnau rozpoczecia testu
SPEED (2*spd) MM/S
PRINT "   JMOVE #safe90"
JMOVE #safe90
;jade do punktu na wprost do tr3 
SPEED (2*spd) MM/S
PRINT "   JMOVE #before_put"
JMOVE #before_put
IF SIG(-palettegalanter) THEN
;jesli nie ma paletki to zglos blad i czekaj na paletke
PRINT "   czekamy na sygnal z transportera do robAssembly"
WHILE SIG(-palettegalanter) DO ;nieskonczona petla
SIGNAL errorateqsensor
END
PRINT "   koniec czekania"
END
;punkt gdzie odstawiamy pakiet
SPEED (2*spd) MM/S
PRINT "   JAPPRO putgalanteria,(pacheight[type]+50)"
JAPPRO putgalanteria,(pacheight[type]+50)
SPEED spd/3 MM/S
PRINT "   LAPPRO putgalanteria,(pacheight[type]/2+50)"
LAPPRO putgalanteria,(pacheight[type]/2+50)
TWAIT (0.5)
SIGNAL -closefingers
SIGNAL openfingers
WAIT SIG(-leftfingerc,-rightfingerc,leftfingero,rightfingero)
SPEED slow MM/S ALWAYS
PRINT "   LAPPRO putgalanteria,20"
LAPPRO putgalanteria,20
BREAK
SPEED supslow MM/S ALWAYS
ACCURACY supacu ALWAYS
PRINT "   LMOVE putgalanteria"
LMOVE putgalanteria
PRINT "   LAPPRO putgalanteria,-20"
LAPPRO putgalanteria,-20   ;zjazd w dol - zeby pakiet nie byl na szczekach
SPEED slow MM/S ALWAYS
ACCURACY acu ALWAYS
BREAK
IF type<>2 AND type<>5 THEN
width = (jawwidth[type]+120)  ;rozsuniecie szczek
ELSE
width = (jawwidth[type]+100)
END
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
PRINT "   LAPPRO putgalanteria,250"
LAPPRO putgalanteria,250 ;odjazd w gore krotszy (szybszy)
SPEED spd MM/S ALWAYS
SIGNAL heatexongalante
PRINT "   WAIT SIG(-palettegalanter)"
WAIT SIG(-palettegalanter)
PRINT "   WAIT OK)"
SIGNAL -heatexongalante
RETURN
.END
.PROGRAM toserwis()
;####################################################################
;# Przeniesienie nieszczelnego pakietu na transporter serwisowy
;####################################################################
PRINT "Pakiet nieszczelny na transporter serwisowy"
TOOL small_gripper
;
;jesli nieszczelny to odkladamy na transporter serwisowy
;
LMOVE #before_ateqr
LMOVE SHIFT(next_conveyors BY 0,-150,-200)+RZ(-300)
SIGNAL -heatexputtedina
;IF SIG(-TestOk,TestNOK)
LMOVE #midway
;czekam na sygnal ze paletka na pewno jest na skrzyzowaniu 
WAIT SIG(potoncross)
LAPPRO before_heatexpi,40
SPEED slow MM/S ALWAYS
LAPPRO pick_heatexch,40
TWAIT (0.5)
SIGNAL -closefingers
SIGNAL openfingers
WAIT SIG(-leftfingerc,-rightfingerc,leftfingero,rightfingero)
;LAPPRO pick_heatEx, 20
SPEED supslow MM/S ALWAYS
ACCURACY supacu ALWAYS
BREAK
LMOVE pick_heatexch
LAPPRO pick_heatexch,-10   ;zjazd w dol - zeby pakiet nie byl na szczekach
SPEED slow MM/S ALWAYS
ACCURACY acu ALWAYS
BREAK
width = (jawwidth[type]+80)  ;rozsuniecie szczek troche aby pakiet nie spadl z tacki na wypadek gdyby byl zahaczony o rolki
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
;WAIT SIG(doNext)	;czekanie na przycisk z teachPendanta - dla bezpieczenstwa
;SIGNAL -doNext
LAPPRO pick_heatexch,-20   ;zjazd jeszcze w dol - zeby pakiet napewno nie byl na szczekach
BREAK
width = (jawwidth[type]+190)  ;rozsuniecie szczek bardzo szeroko do wyjazdu
BITS 81+16,16 = 0
BITS 81+16+8,16 = width
TWAIT (0.5)
SIGNAL waitforshunkmov
WAIT SIG(-waitforshunkmov)
LAPPRO before_heatexpi,20
SPEED spd MM/S ALWAYS
SIGNAL heatexoncross
;odlozylem pakiet teraz odjezdzam do safeT 
LMOVE #midway
LMOVE SHIFT(next_conveyors BY 0,-150,-200)+RZ(-300)
TOOL big_gripper
JMOVE #safe90
JMOVE #safet
gotobp = FALSE
;ELSE	;test wyszedl ani dobry ani zly 
;LMOVE #before_ateq
;LMOVE #midway
;END
RETURN
.END
.PROGRAM tr_wyj()
SIGNAL goforward[1]
SIGNAL goforward[2]
SIGNAL goforward[3]
WAIT 20
.END
.PROGRAM transatqass()
;########################################################## 
;#    Testowy przejazd z transportera po chodzeniu
;#    przez ATQ do transportera do robAssembly
;########################################################## 
PRINT "/C2"
CALL datainit
CALL decodetype
PRINT "Testowe uruchomienie przejazdu z transportera"
PRINT "     przez ATQ do transportera do robAssembly"
PRINT "/C1"
PRINT "Kod pakietu:  ",heatexcode
PRINT "Rozmiar:      ",type
PRINT "   CALL gosafe"
;zezwalam na prace transporterow w automacie 
SIGNAL -stoptransporter[1]
SIGNAL -stoptransporter[2]
JMOVE #safet
CALL gosafe
; nadpisuje typy
heatexcode = 5
CALL decodetype
PRINT "Kod pakietu:  ",heatexcode
PRINT "Rozmiar:      ",type
PRINT "   CALL pickandgo"
CALL pickandgo; pobranie pakietu i wstawienie go to ATEQa
PRINT "   CALL getATQ"
CALL getatq; wyciagamy pakiet z ATQ
PRINT "   CALL toRobAss"
CALL torobass
PRINT "   JMOVE #safet"
JMOVE #safet
PRINT "... KONIEC ..."
HOLD.STEP ON
.END
.PROGRAM tsk()
tsktop:
WAIT SIG(-lasersignal)
WAIT SIG(lasersignal)
POINT leading = HERE
WAIT SIG(-lasersignal)
POINT trailing = HERE
IF DISTANCE(leading,trailing)<10 GOTO tsktop
POINT searchpoint = leading
SIGNAL searchok
PRINT "FINISHED"
.END
.TRANS
ateq -2408.729980 -567.140015 1578.949951 90.939461 180.000000 0.000000
ateqorg -2408.729980 -563.840027 1578.949951 90.939461 180.000000 0.000000
atq 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000
b1 -2413.722900 -1811.988892 -1236.232178 179.740631 0.000005 0.000000
b2 -2416.768066 -2250.159912 -1236.247070 179.739197 0.000005 0.000000
baza -368.315765 1158.287598 -599.999939 -0.460939 0.000010 0.000000
bcenter 456.505432 459.093872 -331.538635 179.539230 0.000005 0.000000
before1 -2003.961060 656.793884 2069.827637 -130.813751 180.000000 0.000000
before_ateqr 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000
before_heatexch -2710.315430 1096.443115 1712.139404 36.112659 180.000000 0.000000
before_heatexh -2707.499512 1093.914307 1713.139404 36.111202 180.000000 0.000000
before_heatexpi -2790.118652 1408.688965 1699.119019 36.112659 180.000000 0.000000
bf -2003.963623 656.783081 2069.835449 49.184242 180.000000 0.000000
big_gripper 0.000000 0.000000 0.000000 -180.000000 0.000000 0.000000
blaser -10.787842 -630.657654 0.000000 180.000000 0.000000 0.000000
bpal -371.325409 1149.495361 -580.000000 -0.758387 0.000010 0.000000
bschunk 4.890198 -588.577881 150.000000 -180.000000 0.000000 0.000000
bstore -1518.791016 1208.242187 -460.000000 -0.503185 0.000010 0.000000
c 457.253571 1048.129395 -181.538635 -0.460778 0.000005 0.000000
calib 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000
calib0 1830.155029 162.068726 1452.074463 -89.999603 -180.000000 0.000000
calibbig 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000
calibbig0 1631.172363 161.399658 1658.272461 -179.999237 -180.000000 0.000000
calibbig1 1319.000977 398.825989 1647.374268 -90.000320 -180.000000 0.000000
caligbig 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000
caligbig0 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000
cart 1876.833984 -376.308807 -597.707581 -90.000031 0.000005 0.000000
cartl 1876.833984 -376.308807 -597.707581 -90.000031 0.000005 0.000000
cartr 2793.779053 -375.374756 -595.224365 -90.000031 0.000005 0.000000
center 457.253571 1048.129395 -181.538635 -0.460778 0.000005 0.000000
centre 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000
conveyors_borde -1319.401001 870.466125 2136.918701 -179.999191 180.000000 0.000000
conveyorsborder 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000
current 236.860931 1231.134277 2043.179443 -166.226105 -180.000000 0.000000
current1 2179.709961 1093.142456 1775.770020 -0.692907 180.000000 0.000000
get_grip 1300.503540 -441.844269 723.224976 -89.150093 180.000000 0.000000
get_gripper 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000
global 0.000000 0.000000 0.000000 0.000000 180.000000 0.000000
goh -1012.458984 -734.588440 1409.292236 89.448555 180.000000 0.000000
goup 236.860931 1231.134277 1985.000000 -166.226105 -180.000000 0.000000
gripper 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000
gripper_up 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000
init_out[1] 1818.697266 1172.937256 1085.922119 -1.068704 180.000000 0.000000
init_put[1] 2233.199951 1830.395996 1366.990967 -0.686128 180.000000 0.000000
init_put[2] 2223.236328 1854.395630 1366.990967 -0.686128 180.000000 0.000000
init_put[3] 2163.236328 1824.395630 1366.990967 -0.686128 180.000000 0.000000
init_put[4] 2203.236328 1864.395630 1366.990967 -0.686128 180.000000 0.000000
init_put[5] 2203.236328 1844.395630 1366.990967 -0.686128 180.000000 0.000000
initial_put[1] 2298.199951 1880.395996 1366.990967 -0.686128 180.000000 0.000000
initial_put[2] 2298.199951 1885.395996 1366.990967 -0.686128 180.000000 0.000000
initial_put[3] 2228.199951 1850.395996 1366.990967 -0.686128 180.000000 0.000000
initial_put[4] 2248.199951 1855.395996 1366.990967 -0.686128 180.000000 0.000000
initial_put[5] 2233.199951 1830.395996 1366.990967 -0.686128 180.000000 0.000000
inside_grip 1300.500000 -441.839996 766.659973 -89.067764 180.000000 0.000000
krata -344.403870 1150.123047 -1073.782593 -86.586754 0.000005 0.000000
kupa -368.315765 1158.287598 -580.000000 -0.460939 0.000010 0.000000
laser -7.353943 -638.979248 0.000000 -180.000000 0.000000 0.000000
leading 150.011658 -157.924530 0.025324 -89.995094 0.000005 0.000000
mati -540.691467 1413.607788 1128.021973 -179.833206 -180.000000 0.000000
mmlbeforeateq -1243.021973 -50.045002 1404.196533 145.381454 -180.000000 0.000000
mmlnadpod 2324.978271 -1460.585815 1674.666504 179.419708 -180.000000 0.000000
mmlpodajnik 2336.215332 -2186.767090 1697.858154 -179.959488 -180.000000 0.000000
mmlpoz1 -1072.586792 196.836273 1917.244751 -0.144286 -180.000000 0.000000
mmlpoz2 -546.987244 945.126343 1917.244141 -0.146724 -180.000000 0.000000
mmlpoz3 -102.772018 1087.150757 1917.244141 -24.807859 -180.000000 0.000000
mmlpoz4 310.556732 1046.906616 1917.244141 -46.730751 -180.000000 0.000000
mmlpoz5 888.216187 1171.574951 1917.235718 -46.730297 -180.000000 0.000000
mmlpoz6 1674.937866 1171.585449 1917.239624 -178.883621 -180.000000 0.000000
mmlpoz7 2301.059326 -656.776123 1917.225342 -178.885391 -180.000000 0.000000
mmltempbase 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000
mmltemppoint -1661.932373 -656.837219 1597.312012 145.381500 -180.000000 0.000000
mmltemptool 0.000000 -737.500000 -193.000000 180.000000 0.000000 0.000000
mmmpoz1 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000
mytool 1178.045044 7.977905 -1.031982 0.000000 0.000000 0.000000
narzedzie -487.799286 1849.078735 -1488.289795 180.000000 0.000005 0.000000
narzedzie1 -487.799286 1849.078735 -1488.289795 90.000031 0.000005 0.000000
narzedzie2 -487.799286 1849.078735 -1488.289795 -90.000023 0.000005 0.000000
new -2361.982910 -2258.364258 -1038.060425 179.600006 0.000005 0.000000
next_ateq -1319.390625 -102.141403 1955.745972 179.994446 180.000000 0.000000
next_conveyors -1589.427246 656.700317 2156.864258 -179.498611 180.000000 0.000000
oldateq -2410.000000 -729.000000 1587.292236 89.451683 180.000000 0.000000
over_conveyors 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000
over_conveyors1 -391.473969 1491.587891 2159.105469 -0.163064 180.000000 0.000000
over_lift -1320.456177 1552.684204 2180.427979 179.990158 180.000000 0.000000
over_lift1 -1982.496948 1145.810791 2120.945313 3.036727 180.000000 0.000000
p0 0.423687 1240.603882 2040.260498 89.992767 180.000000 0.000000
p1 1830.155029 162.068726 1452.074463 -179.999619 -180.000000 0.000000
p10 0.403832 1240.621460 2040.236328 179.682205 180.000000 0.000000
p2 1830.155029 162.068726 1452.074463 0.000405 -180.000000 0.000000
p3 2000.890991 -61.659058 1896.460937 -179.403366 180.000000 0.000000
pad 397.121460 1161.428345 750.005371 92.318863 180.000000 0.000000
pajak -2522.293213 108.744827 -145.123520 89.585037 0.000005 0.000000
pak 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000
pakl 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000
pal -368.315765 1158.287598 -580.000000 -0.460939 0.000010 0.000000
palmid -120.522171 1193.795288 -1034.800049 89.539062 0.000010 0.000000
pavoid 743.047363 1402.059448 2136.629883 -179.403137 -180.000000 0.000000
pick 755.601990 1410.036377 1323.549561 179.921555 -180.000000 0.000000
pick_gripper 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000
pick_heatex -2996.399902 1691.439941 1686.119019 36.112659 180.000000 0.000000
pick_heatexch -2996.399902 1691.439941 1699.119019 36.112659 180.000000 0.000000
pick_palette -540.700012 1413.599976 1090.000000 -179.834915 180.000000 0.000000
pick_palettet -595.175354 1479.544067 1100.902832 -179.834900 180.000000 0.000000
pick_spacer 755.599976 1410.000000 1185.000000 179.921417 180.000000 0.000000
pick_spacert 684.810730 1437.922241 1020.158508 -179.236191 180.000000 0.000000
pickopint 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000
pickpal -1052.350342 2252.315430 -641.538696 -0.963963 0.000005 0.000000
pickpoint -2361.982910 -2258.364258 -1038.060425 179.600006 0.000005 0.000000
picks 755.552734 1499.649902 1338.537109 179.920303 -180.000000 0.000000
placepal 97.354980 2202.704590 -761.538696 -0.921717 0.000005 0.000000
poz1 983.148621 244.875427 1758.433716 -89.063988 180.000000 0.000000
poz2 1076.715820 589.545288 2031.105225 -89.063240 180.000000 0.000000
put_package 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000
put_palete 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000
put_paleter 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000
put_palette 2043.000000 1415.599976 1096.460937 -179.403366 180.000000 0.000000
put_paletteb 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000
put_paletter 2000.882324 1375.370361 1108.708252 -179.402618 180.000000 0.000000
put_paletterel 1990.904907 1380.355957 1096.448120 -179.402725 180.000000 0.000000
put_palettet 1990.891479 1473.138916 1096.460937 -179.403366 180.000000 0.000000
put_spacer 2043.000000 1402.000000 1163.850098 -179.403000 180.000000 0.000000
put_spacert 1988.604248 1434.047241 1166.474854 -179.240143 180.000000 0.000000
putb_palette -530.700012 1413.599976 1100.902832 -179.834915 180.000000 0.000000
putgalanteria 2336.219971 -2186.770020 1697.859985 -179.960007 180.000000 0.000000
putgalenteria 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000
putpackage 2036.199951 1885.395996 1366.990967 -0.686128 180.000000 0.000000
putpalette 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000
rise 755.552734 1499.649902 1338.537109 179.920303 -180.000000 0.000000
safe1 0.410448 1240.607910 2040.245239 179.994919 180.000000 0.000000
schunk 3.988953 -589.022522 150.000000 180.000000 0.000000 0.000000
searchend 150.000000 0.000000 0.000000 -90.000031 0.000000 0.000000
searchpoint 150.011658 -157.924530 0.025324 -89.995094 0.000005 0.000000
searchstart 150.000000 -170.000000 0.000000 -90.000031 0.000000 0.000000
smal_gripper 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000
small_gripper 0.000000 -737.500000 -193.000000 -180.000000 0.000000 0.000000
stoer 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000
store -1518.791016 1208.242187 -460.000000 -0.503185 0.000010 0.000000
sy1 -466.007019 1316.155640 -1300.000000 -90.000046 0.000005 0.000000
sy2 -455.785583 1944.436646 -1300.000000 -90.000053 0.000005 0.000000
t1 1827.927856 162.870117 1444.100098 -179.998337 -180.000000 0.000000
t2 1828.106812 163.464600 1442.855713 0.000405 -180.000000 0.000000
temp 2.644605 -738.966675 -193.000000 -180.000000 0.000000 0.000000
temp1 -2995.701904 1693.254883 1585.995850 90.940865 180.000000 0.000000
tempbiggrip1 -517.958984 -287.805695 0.000000 -180.000000 0.000000 0.000000
tempbiggrip2 526.223083 334.727692 0.000000 -180.000000 0.000000 0.000000
temptool 8.094604 -738.706665 -193.000000 -180.000000 0.000000 0.000000
test_pick -803.786011 1184.362427 1331.165527 89.982666 180.000000 0.000000
tmep -2790.156738 1409.730591 1701.476440 36.166744 -180.000000 0.000000
tmp 0.278270 503.105835 2233.252930 179.989212 -180.000000 0.000000
tool0 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000
trailing 150.035095 -84.070801 0.028132 -90.000946 0.000005 0.000000
wait_ateq -1891.974365 -527.000000 1597.196411 89.460594 180.000000 0.000000
wait_test -1908.797119 -558.942078 1578.949951 90.939461 180.000000 0.000000
weight 1956.333984 -455.808807 -597.707581 -90.000031 0.000005 0.000000
x -1518.791016 1208.242187 -489.999878 -0.503185 0.000010 0.000000
y1 -367.045105 1316.207031 -1300.009766 -89.994705 0.000005 0.000000
y2 -361.991089 1944.419312 -1300.005493 -90.000221 0.000005 0.000000
.END
.JOINTS
#before_ateq -141.472137 -37.239769 -10.429166 117.684013 0.000000 0.000000
#before_ateqr -92.305527 -36.327000 -9.642230 -53.076687 0.000000 0.000000
#before_heatex -71.853859 5.311954 7.338240 22.669615 0.000000 0.000000
#before_heatexr -71.853859 5.311456 7.337934 202.669632 0.000000 0.000000
#before_put 96.563591 -8.970271 7.215192 -93.026062 0.000000 0.000000
#before_putr 71.046997 -30.625998 13.610000 18.958000 0.000000 0.000000
#bf -71.853859 5.311954 7.338240 22.669615 0.000000 0.000000
#calib 90.000000 -19.451487 14.999792 5.285773 0.000000 0.000000
#calib2 90.000000 -40.356529 -0.685233 5.285773 0.000000 0.000000
#calibbig 67.030174 -38.857731 7.558280 112.813789 0.000000 0.000000
#cart -99.849091 -35.323753 4.806676 8.621762 0.000000 0.000000
#init_put[1] 58.557465 12.995145 -28.182131 -58.461918 0.000000 0.000000
#ld -104.553841 19.327663 -34.739716 3.686781 0.000000 0.000000
#lu -89.524498 -26.967684 -4.155657 3.686781 0.000000 0.000000
#mid -0.269970 -26.967684 -4.155657 3.686781 0.000000 0.000000
#mid_pac2tr3 -94.432266 -48.734051 0.185198 70.704163 0.000000 0.000000
#mid_pac2tr3h -93.858688 -33.989368 10.841623 105.935959 0.000000 0.000000
#mid_pal2tr3 18.346941 -8.819565 15.000107 -17.683750 0.000000 0.000000
#midway -75.270523 -11.891853 -8.914619 30.990700 0.000000 0.000000
#mmlpodajnik 103.777870 8.011746 -1.598354 77.878036 0.000000 0.000000
#new 101.928436 3.784467 -17.182932 75.213562 0.000000 0.000000
#over_conveyors -14.705865 -19.724726 13.660713 14.868935 0.000000 0.000000
#over_conveyorst -14.705865 -19.724726 13.660713 104.868942 0.000000 0.000000
#over_gripper 109.208763 -30.218079 0.118647 -20.144693 0.000000 0.000000
#over_lift -59.973660 14.367013 10.733016 56.936935 0.000000 0.000000
#over_liftt -59.973660 14.367006 10.733014 146.936951 0.000000 0.000000
#p1 50.720085 -15.870208 7.843928 -52.354290 0.000000 0.000000
#p11 50.720089 -14.481006 -13.957348 -52.352753 0.000000 0.000000
#p2 45.564671 -9.092543 6.571708 43.000107 0.000000 0.000000
#p22 45.564972 -7.211423 -15.113111 43.000111 0.000000 0.000000
#p3 105.937927 -30.450994 12.858400 -17.373819 0.000000 0.000000
#p31 109.740135 -29.444901 12.413605 -111.378250 0.000000 0.000000
#p33 105.937637 -31.631836 -8.050467 -17.374596 0.000000 0.000000
#p331 109.739838 -30.376293 -8.594133 -111.375938 0.000000 0.000000
#p4 109.740135 -22.414164 -28.170210 -111.375168 0.000000 0.000000
#pajak 88.000000 -25.000000 0.000000 2.000000 0.000000 0.000000
#pal 0.000000 -25.000000 0.000000 0.000000 0.000000 0.000000
#pick_heatex1 -70.653519 35.248791 -5.532402 34.305099 0.000000 0.000000
#pick_palette 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000
#pick_palettet -21.913416 -8.538318 -32.320210 201.748306 0.000000 0.000000
#pick_spacer1 27.764698 -13.917480 -27.898684 153.258133 0.000000 0.000000
#pick_spacert 27.764698 -13.917480 -27.898684 153.258133 0.000000 0.000000
#placeex -9.294544 -41.712109 8.257953 99.294052 0.000000 0.000000
#placeweight -44.356071 -19.994598 -1.314593 134.356247 0.000000 0.000000
#put_last_spacer 54.782166 22.847683 9.105155 125.067596 0.000000 0.000000
#put_palettet 53.500805 29.535128 -25.800922 125.902573 0.000000 0.000000
#put_spacert 56.108780 24.484524 -25.058243 123.128601 0.000000 0.000000
#rd 86.710762 29.353138 -43.491112 3.686781 0.000000 0.000000
#rot_grip 109.209068 -1.871535 -53.539219 69.852997 0.000000 0.000000
#ru 86.710762 12.543283 -16.088066 3.686781 0.000000 0.000000
#safe 0.019262 -34.893349 14.986922 -0.013106 0.000000 0.000000
#safe2 0.020768 -39.135757 17.278538 89.985397 0.000000 0.000000
#safe90 0.019000 -40.000000 14.987001 -90.000000 0.000000 0.000000
#safet 0.019262 -34.893616 14.987242 179.988449 0.000000 0.000000
#search 42.038860 -22.198843 -3.093750 -132.300827 0.000000 0.000000
#store 45.000000 -25.000000 0.000000 -45.000000 0.000000 0.000000
#temp 109.177261 -30.219379 0.122733 -20.092260 0.000000 0.000000
#wait_ateq 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000
#wait_ateq1 -129.171860 -41.787079 -6.593995 39.694969 0.000000 0.000000
.END
.REALS
a = 0
acc = 100
accepttimeout = 60
actualdate = 0
acu = 10
addheight = 45
allowrobmove = 2045
angle = 0.460939
angletolerance = 3
ateqcal = 64
ateqcalok = 1064
ateqcorx[1] = -1.5
ateqcorx[2] = 0
ateqcorx[3] = 0.5
ateqcorx[4] = -1
ateqcorx[5] = -1.5
ateqcorxtype1 = 0
ateqcorxtype2 = 0
ateqcorxtype3 = 0
ateqcorxtype4 = 0
ateqcorxtype5 = 0
ateqcory[1] = 0
ateqcory[2] = -3.3
ateqcory[3] = 0
ateqcory[4] = -2
ateqcory[5] = -2
ateqcorytype1 = 0
ateqcorytype2 = 0
ateqcorytype3 = 0
ateqcorytype4 = 0
ateqcorytype5 = 0
ateqinpos = 1063
ateqpos[1] = 58
ateqpos[2] = 59
ateqpos[3] = 60
ateqpos[4] = 61
ateqpos[5] = 62
ateqpos[6] = 63
ateqsafety = 1060
ateqspd = 150
ateqz = 1409.29
belowateq = 3
bpos = 0
cartno = 1
cartswitched = 0
changepos = 57
checkcorrection = 15
checkingsafe = -1
checkp = 0
checks = 0
checksenorsfrow[1] = -1
checksensorsbac[1] = 2035
checksensorsbac[2] = 2037
checksensorsfor[1] = 2036
checksensorsfor[2] = 2038
checksensorsfor[3] = 2039
cloded = 1006
close = 2
closed = 1006
closefingers = 44
col = 0
colcount = 3
connectoron = 67
correctionoy = 89.6135
cshunkpos = 60
curtainbreak = 598
cx = 236.861
cy = 1231.13
cz = 2043.18
data[0] = 5
data[1] = 176
data[2] = 0
data[3] = 255
data[4] = 0
data[5] = 0
data[6] = 0
data[7] = 0
decode = 0
decoded = 0
deg = 90
donext = 2090
emptyl = 43
emptyr = 50
endconf = 608
endcycle = 1381
enginedown = 1062
enginesafety[1] = 1033
enginesafety[2] = 1036
enginesafety[3] = 1039
engineup = 1061
enterconf = 598
enterreq = 1383
err2pallettr3 = 67
errateqfull = 68
errorateq = 600
errorateqfull = 536
errorateqsensor = 614
errorconf = 1384
errorconfhold = 2034
erroremptytr[1] = 541
erroremptytr[2] = 542
errorheatexsens = 612
errorheatexwron = 611
errorholdinghea = 603
errornogripper = 599
errornoheatex = 607
errorpalettesen = 613
errorshunkfail = 604
errorstuck = 602
errortr[1] = 605
errortr[2] = 606
errortr3full = 601
errortrblocked[1] = 609
errortrblocked[2] = 610
errortrsensorsf[1] = 615
errortrsensorsf[2] = 616
errortrsensorsf[3] = 617
explaceappro = 300
explaced = 3
explaceh = -58
failcount = 0
fastacu = 100
fastdeg = 300
fastmms = 9000
fastmss = 2000
fastspd = 100
filllvl = 0
firstcycle = 0
fonpositionpale = 2016
fonpositionspac = 2015
found = -1
fpositionnextat = 2015
gc = 1001
getpalette = 43
getpaletteblink = 2027
go = 1002
goateq = 0
goback[1] = 34
goback[2] = 36
goback[3] = 38
goforward[1] = 33
goforward[2] = 35
goforward[3] = 37
gotoateq = -1
gotobp = -1
gotogalanteria = 1393
gotosafe = -1
grabgripper = 48
grabpalette = 46
gripper = -1
hatdown = 65
hath = 53
hatisdown = 1065
hatisup = 1066
hatup = 66
havegripper = 1057
heatexcode = 5
heatexinateq = 1067
heatexingripper = 1054
heatexoncross = 596
heatexongalante = 4
heatexonpalette = 595
heatexputtedina = 594
heatextaken = 593
heightp = 1266.32
heights = 1342.4
hevegripper = 1057
high = 5
i = 7
ilepalet = 0
in[0] = 5
in[1] = 148
in[2] = 236
in[3] = 43
in[4] = 0
in[5] = 0
in[6] = 0
in[7] = 0
initok = 597
jawwidth[1] = 20
jawwidth[2] = 50
jawwidth[3] = 140
jawwidth[4] = 340
jawwidth[5] = 530
jw = 519
jwidth = 500
laser = 6
lasersensor = 1059
lasersignal = 1004
layer = 4
layercount = 1
layercounter = 2
layerfull[1] = 2017
layerfull[2] = 2018
layers = 5
leavegripper = 49
leavepalette = 47
leftfingerc = 1051
leftfingero = 1050
leftgripper = 1058
lifth = 400
llayercount = 2
llogowanie = 0
localizationok = -1
lock = -3
locked = 1010
lockedl = 1041
lockedr = 1048
log70 = 0
logowanie = 0
loop = -1
lowonpaletts = 72
mainloop = -1
makingtestateq = 2033
manfincl = 2042
manfinop = 2041
mantransp = 2019
mantrback[1] = 1388
mantrback[2] = 1390
mantrback[3] = 1392
mantrforward[1] = 1387
mantrforward[2] = 1389
mantrforward[3] = 1391
max = 3
maxcolcount[1] = 3
maxcolcount[2] = 3
maxcolcount[3] = 2
maxcolcount[4] = 2
maxcolcount[5] = 2
maxex = 78
maxnrofpaletts = 5
maxnrofspacers = 10
maxrowcount[1] = 5
maxrowcount[2] = 5
maxrowcount[3] = 4
maxrowcount[4] = 4
maxrowcount[5] = 3
maxtimerfingers = 3
maxtimershunk = 20
maxweight = 4
medium = 60
minpacheight = 395
minpacketheight = 410
mmlspd = 30
mmlsppd = 100
mnitest = -1
move_pass = 0
moveobject[1] = 2012
moveobject[2] = 2013
moveobject[3] = 2014
moveobjectout[1] = 2030
moveobjectout[2] = 2031
moveout[1] = 2028
moveout[2] = 2029
moverequest[1] = 2081
moverequest[2] = 2082
moverequest[3] = 2083
movingback[1] = 1035
movingback[2] = 1038
movingback[3] = 1041
movingforward[1] = 1034
movingforward[2] = 1037
movingforward[3] = 1040
n = 145
needpaletts = 615
needspacers = 616
new = 1098
newappro = 300
newdim = 120
newl = 1044
newr = 1051
nogriperr = 0
nogriperror = 0
noheatexerror = -1
notnewl = 44
notnewr = 51
nrofpaletts = 1
nrofpallets = 0
nrofspacers = 2
objectin[1] = 1048
objectin[2] = 1049
objectnotin[1] = 1048
objectnotin[2] = 1049
oldheatexcode = 5
oldpos = 50000
onpositionl = 1042
onpositionr = 1049
open = -2
opened = 1005
openfingers = 45
out[0] = 5
out[1] = 176
out[2] = 0
out[3] = 300
out[4] = 0
out[5] = 0
out[6] = 0
out[7] = 0
overpick[1] = 1
pacheight[1] = 395
pacheight[2] = 396
pacheight[3] = 400
pacheight[4] = 406
pacheight[5] = 410
packageinate = 69
packageinateq = 530
packageoncross = 532
packageonpalett = 531
packageontransp = 4
packageout = 70
packagetaken = 529
packagetype = 1370
packagewaits = 1375
packetheight = 0
pal = 2
palappro = 120
palapro = 55
palettedetect = 1068
palettegalanter = 1001
palettegripperc = 1056
palettegrippero = 1055
paletteheight = 160
palettenotempty = -1
palettenotfound = 0
palettewithouts = 2026
palettnotfound = -1
palh = 200.9
pallets = 3
pauseconf = 608
pausecycle = 1380
pickangle = 0
pickcorrection[1] = 14
pickcorrection[2] = 12
pickcorrection[3] = 8
pickcorrection[4] = 4
pickcorrection[5] = -2
pickh = 40
placeangle = 90
portno = 10000
pos = 500
potoncross = 1379
pozycja = 200
prevcode = 5
prevtype = 2
programreset = 1070
ptc_m = 2103
ptype = 4
qtynok[1] = 40
qtynok[2] = 42
qtyok[1] = 39
qtyok[2] = 41
ready = 2001
readytotest = -1
reareadytotest = -1
recvtimeout = 60
ref[1] = 52
ref[2] = 53
ref[3] = 54
ref[4] = 55
ref[5] = 56
referenceset = 0
resetcycle = 1382
response = 148
response1 = 136
response2 = 118
retval = 0
rightfingerc = 1053
rightfingero = 1052
robotresetposit = 2044
rocount = 4
row = 2
rowcount = 1
rowount = 4
safeprocedure = 0
safetygodown = 0
sch_manual = 2040
sch_move = 500
searchok = 2006
searchspeed = 40
searchwait = 0.1
sensorback[1] = 1042
sensorback[2] = 1043
sensorback[3] = 1044
sensorfront[1] = 1045
sensorfront[2] = 1046
sensorfront[3] = 1047
sherrres = 2043
shunkerrorreset = 2043
shunkfail = 0
size = 1
slow = 200
slowdeg = 60
slowsrchspd = 30
socketid = 15
spaceleft = 0
spacerheight = 60
spacernotfound = 0
spacerputted[1] = 2020
spacerputted[2] = 2021
spacerthicknes = 20
spacerthickness = 20
spd = 1500
spdqteq = 100
speed = 10
srchspd = 150
startcycle = 1369
stopcycle = 1069
stoptransporter[1] = 2023
stoptransporter[2] = 2024
storeh = 1000
supacu = 1
supslow = 30
supslow2 = 8
testinprogres = 1376
testnok = 1378
testnok_mem = 2101
testnokk_mem = 2102
testok = 1377
testok_mem = 2100
testokk = 2025
timeout = 60
tip_m = 2104
tnok_m = 2101
toateq = -1
tok_m = 2100
tokk_m = 2102
transporterread = 1001
trmanual = 1386
trready[1] = 2007
trready[2] = 2008
trready[3] = 2009
tx = -0.0894775
ty = -0.297241
type = 2
underateq[1] = 3
underateq[2] = 2
underateq[3] = 3
underateq[4] = 2
underateq[5] = 3
unlock = 3
unlocked = 1009
unlockl = 41
unlockr = 48
waitforshunkmov = 2022
waitforshunkref = -1
waitfort[1] = 0
waitfortr[1] = 0
waitfortr[2] = -1
waitfortr[3] = 0
waitfortr3 = -1
wcol = 1
wcols = 2
weight = 4
weightangle = 0
weightappro = 300
weighth = 31
weightmax = 5
weightpos = 0
width = 240
wordcount = 10
wrow = 1
wrows = 2
xdist[1] = 260
xdist[2] = 262
xdist[3] = 400
xdist[4] = 425
xdist[5] = 400
xdistance = 1023.86
ydist[1] = 230
ydist[2] = 230
ydist[3] = 280
ydist[4] = 283
ydist[5] = 390
zdif = -58.1794
zdist[1] = 395
.END
.STRINGS
$actualdate = "06/12/2013"
$actualdatea = "08/18/2015"
$actualdates = "08/18/2015"
$d = "06/06/2013"
$dd = "06/06/2013"
$prevdate = "0"
$prevdatea = "08/18/2015"
$prevdates = "08/18/2015"
$received[1] = "15.3 WALL ROT"
$task = "PickEx"
$txt = "123 abba"
$zone = "Safe"
.END
